<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>缺省配置Springboot Web应用中tomcat的启动过程@csdn | stelawliet | 迁移整理中...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="缺省配置Springboot Web应用中tomcat的启动过程@csdn概述独立部署的tomcat服务器的启动过程传统意义上一个独立部署和运行的tomcat服务器的启动可以理解成两个阶段 :  tomcat 容器本身的启动; tomcat容器中所部署的web app的启动；  完成了以上两个阶段，我们才能访问到我们所开发的业务逻辑。在这种情况下，web app的部署动作，通常是由系统部署人员通过">
<meta name="keywords" content="blog">
<meta property="og:type" content="article">
<meta property="og:title" content="缺省配置Springboot Web应用中tomcat的启动过程@csdn">
<meta property="og:url" content="http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/index.html">
<meta property="og:site_name" content="stelawliet">
<meta property="og:description" content="缺省配置Springboot Web应用中tomcat的启动过程@csdn概述独立部署的tomcat服务器的启动过程传统意义上一个独立部署和运行的tomcat服务器的启动可以理解成两个阶段 :  tomcat 容器本身的启动; tomcat容器中所部署的web app的启动；  完成了以上两个阶段，我们才能访问到我们所开发的业务逻辑。在这种情况下，web app的部署动作，通常是由系统部署人员通过">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-10T12:54:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缺省配置Springboot Web应用中tomcat的启动过程@csdn">
<meta name="twitter:description" content="缺省配置Springboot Web应用中tomcat的启动过程@csdn概述独立部署的tomcat服务器的启动过程传统意义上一个独立部署和运行的tomcat服务器的启动可以理解成两个阶段 :  tomcat 容器本身的启动; tomcat容器中所部署的web app的启动；  完成了以上两个阶段，我们才能访问到我们所开发的业务逻辑。在这种情况下，web app的部署动作，通常是由系统部署人员通过">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Stelawliet</h5>
          <a href="mailto:Stelawliet@gmail.com" title="Stelawliet@gmail.com" class="mail">Stelawliet@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Stelawliet" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Stelawliet" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                twitter
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Stelawliet"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">缺省配置Springboot Web应用中tomcat的启动过程@csdn</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">缺省配置Springboot Web应用中tomcat的启动过程@csdn</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-08-19T13:13:22.000Z" itemprop="datePublished" class="page-time">
  2018-08-19
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#缺省配置Springboot-Web应用中tomcat的启动过程-csdn"><span class="post-toc-number">1.</span> <span class="post-toc-text">缺省配置Springboot Web应用中tomcat的启动过程@csdn</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#概述"><span class="post-toc-number">2.</span> <span class="post-toc-text">概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#独立部署的tomcat服务器的启动过程"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">独立部署的tomcat服务器的启动过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#spring-boot-web应用启动过程和独立部署的tomcat服务器启动过程的不同点"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">spring boot web应用启动过程和独立部署的tomcat服务器启动过程的不同点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#spring-boot-web应用启动过程概述"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">spring boot web应用启动过程概述</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TomcatEmbeddedServletContainerFactory作为bean定义注册到容器"><span class="post-toc-number">3.</span> <span class="post-toc-text">TomcatEmbeddedServletContainerFactory作为bean定义注册到容器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EmbeddedServletContainerAutoConfiguration"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">EmbeddedServletContainerAutoConfiguration</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#内置Tomcat-servlet容器的创建和初始化"><span class="post-toc-number">4.</span> <span class="post-toc-text">内置Tomcat servlet容器的创建和初始化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EmbeddedWebApplicationContext的方法createEmbeddedServletContainer"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">EmbeddedWebApplicationContext的方法createEmbeddedServletContainer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#TomcatEmbeddedServletContainerFactory的方法getEmbeddedServletContainer"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">TomcatEmbeddedServletContainerFactory的方法getEmbeddedServletContainer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#TomcatEmbeddedServletContainer的创建和初始化"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">TomcatEmbeddedServletContainer的创建和初始化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Tomcat-StandardContxt启动过程中SCI的应用"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">Tomcat StandardContxt启动过程中SCI的应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#EmbeddedWebApplicationContext的selfInitialize"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">EmbeddedWebApplicationContext的selfInitialize</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ServerProperties内部类SessionConfiguringInitializer"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">ServerProperties内部类SessionConfiguringInitializer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InitParameterConfiguringServletContextInitializer"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">InitParameterConfiguringServletContextInitializer</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#内置Tomcat-servlet容器的启动"><span class="post-toc-number">5.</span> <span class="post-toc-text">内置Tomcat servlet容器的启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#启动入口点"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">启动入口点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#启动入口点代码分析"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">启动入口点代码分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内置servlet容器的启动过程"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">内置servlet容器的启动过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Tomcat-Connector的启动"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">Tomcat Connector的启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#启动入口点-1"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">启动入口点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#启动入口点逻辑分析"><span class="post-toc-number">5.4.2.</span> <span class="post-toc-text">启动入口点逻辑分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Connector启动过程分析"><span class="post-toc-number">5.4.3.</span> <span class="post-toc-text">Connector启动过程分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Http11NioProtocol启动过程分析"><span class="post-toc-number">5.4.4.</span> <span class="post-toc-text">Http11NioProtocol启动过程分析</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Java/spring/boot/embeddedTomcat"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">缺省配置Springboot Web应用中tomcat的启动过程@csdn</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-08-19 21:13:22" datetime="2018-08-19T13:13:22.000Z"  itemprop="datePublished">2018-08-19</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="缺省配置Springboot-Web应用中tomcat的启动过程-csdn"><a href="#缺省配置Springboot-Web应用中tomcat的启动过程-csdn" class="headerlink" title="缺省配置Springboot Web应用中tomcat的启动过程@csdn"></a>缺省配置Springboot Web应用中tomcat的启动过程@csdn</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="独立部署的tomcat服务器的启动过程"><a href="#独立部署的tomcat服务器的启动过程" class="headerlink" title="独立部署的tomcat服务器的启动过程"></a>独立部署的tomcat服务器的启动过程</h2><p>传统意义上一个独立部署和运行的tomcat服务器的启动可以理解成两个阶段 :</p>
<ol>
<li>tomcat 容器本身的启动;</li>
<li>tomcat容器中所部署的web app的启动；</li>
</ol>
<p>完成了以上两个阶段，我们才能访问到我们所开发的业务逻辑。在这种情况下，web app的部署动作，通常是由系统部署人员通过某种方式在启动服务器前完成的。</p>
<h2 id="spring-boot-web应用启动过程和独立部署的tomcat服务器启动过程的不同点"><a href="#spring-boot-web应用启动过程和独立部署的tomcat服务器启动过程的不同点" class="headerlink" title="spring boot web应用启动过程和独立部署的tomcat服务器启动过程的不同点"></a>spring boot web应用启动过程和独立部署的tomcat服务器启动过程的不同点</h2><p>相对于一个独立部署和运行的tomcat服务器，一个缺省配置的spring boot web应用，情况有些不同 ：</p>
<ol>
<li>tomcat 不再是独立存在的，是被内嵌到应用中的；</li>
<li>web app的部署不是系统部署人员部署的，是spring boot 应用按照某种约定运行时组装和部署的；</li>
</ol>
<p>在启动spring boot web应用之前，开发人员需要按照 spring boot的规范编码，实现特定的类，打包部署该spring boot web应用，然后才能启动该应用并提供相应的服务。</p>
<p>本文中介绍的 spring boot web应用的启动过程，指的是从输入spring boot web应用的启动命令开始到开发人员所实现web app的启动完成。</p>
<h2 id="spring-boot-web应用启动过程概述"><a href="#spring-boot-web应用启动过程概述" class="headerlink" title="spring boot web应用启动过程概述"></a>spring boot web应用启动过程概述</h2><p>前提 :</p>
<ol>
<li>缺省情况下web应用引用了依赖 spring-boot-starter-tomcat；</li>
<li>TomcatEmbeddedServletContainerFactory 是spring-boot-autoconfigure创建内置tomcat servlet容器的工厂类;</li>
</ol>
<p>启动过程 :</p>
<ol>
<li>在自动配置工具spring-boot-autoconfigure执行的自动配置阶段，EmbeddedServletContainerAutoConfiguration会因为spring-boot-starter-tomcat的存在而注册bean定义 TomcatEmbeddedServletContainerFactory ;</li>
<li>然后在spring boot启动web容器的阶段,应用上下文 application context 会使用注册的该bean定义 TomcatEmbeddedServletContainerFactory 创建并启动一个内置的 tomcat servlet 容器<br>TomcatEmbeddedServletContainer</li>
</ol>
<blockquote>
<p>该过程中spring boot会将以bean定义形式注册到bean容器的的Servlet,Filter,Event Listener,Web Controller等web app元素关联到tomcat形成一个web app，然后对外提供服务</p>
</blockquote>
<h1 id="TomcatEmbeddedServletContainerFactory作为bean定义注册到容器"><a href="#TomcatEmbeddedServletContainerFactory作为bean定义注册到容器" class="headerlink" title="TomcatEmbeddedServletContainerFactory作为bean定义注册到容器"></a>TomcatEmbeddedServletContainerFactory作为bean定义注册到容器</h1><h2 id="EmbeddedServletContainerAutoConfiguration"><a href="#EmbeddedServletContainerAutoConfiguration" class="headerlink" title="EmbeddedServletContainerAutoConfiguration"></a>EmbeddedServletContainerAutoConfiguration</h2><p>在spring boot自动配置工具spring-boot-autoconfigure的元数据文件META-INF/spring.factories中<br>定义自动配置属性org.springframework.boot.autoconfigure.EnableAutoConfiguration时，该属性<br>的值包含了如下值 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration1</span><br></pre></td></tr></table></figure>
<p>EmbeddedServletContainerAutoConfiguration 的实现(部分):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nested configuration if Tomcat is being used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="comment">// 这里 Servlet, Tomcat 是spring-boot-starter-tomcat提供的，</span></span><br><span class="line">    <span class="comment">// 当 spring-boot-starter-tomcat 被引入到 classpath 时，以下@ConditionalOnClass</span></span><br><span class="line">    <span class="comment">// 的条件会被满足，从而应用该配置类，注册bean定义 TomcatEmbeddedServletContainerFactory,</span></span><br><span class="line">    <span class="comment">// 也就是整个web应用启动web servlet容器时所要使用的servlet容器工厂类</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Tomcat.class &#125;)</span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>
<h1 id="内置Tomcat-servlet容器的创建和初始化"><a href="#内置Tomcat-servlet容器的创建和初始化" class="headerlink" title="内置Tomcat servlet容器的创建和初始化"></a>内置Tomcat servlet容器的创建和初始化</h1><p>调用入口点 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由此调用链可以看出，内置Tomcat servlet容器的创建和初始化实在Spring ApplicationContext</span></span><br><span class="line"><span class="comment">// 容器的refresh()过程中执行的。</span></span><br><span class="line">SpringApplication.run()</span><br><span class="line">=&gt;refresh(ApplicationContext applicationContext)</span><br><span class="line">    =&gt;EmbeddedWebApplicationContext.refresh()</span><br><span class="line">        =&gt; <span class="keyword">super</span>.refresh()</span><br><span class="line">    =&gt;EmbeddedWebApplicationContext.onRefresh()</span><br><span class="line">    =&gt;createEmbeddedServletContainer()<span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<h2 id="EmbeddedWebApplicationContext的方法createEmbeddedServletContainer"><a href="#EmbeddedWebApplicationContext的方法createEmbeddedServletContainer" class="headerlink" title="EmbeddedWebApplicationContext的方法createEmbeddedServletContainer"></a>EmbeddedWebApplicationContext的方法createEmbeddedServletContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createEmbeddedServletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取属性中记录的嵌入式servlet容器，spring boot web 应用启动时这里一定是 null</span></span><br><span class="line">    EmbeddedServletContainer localContainer = <span class="keyword">this</span>.embeddedServletContainer;</span><br><span class="line">    <span class="comment">// 获取属性中记录的嵌入式servlet上下文，spring boot web 应用启动时这里一定是 null</span></span><br><span class="line">    ServletContext localServletContext = getServletContext();</span><br><span class="line">    <span class="keyword">if</span> (localContainer == <span class="keyword">null</span> &amp;&amp; localServletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// spring boot web 应用启动时流程会走到这里</span></span><br><span class="line">        <span class="comment">// 获取ApplicationContext bean定义注册阶段注册的EmbeddedServletContainerFactory</span></span><br><span class="line">        <span class="comment">// 对于使用缺省配置的spring boot web 应用，这里实际上是 </span></span><br><span class="line">        <span class="comment">// TomcatEmbeddedServletContainerFactory</span></span><br><span class="line">        <span class="comment">// 该bean实例化过程中已经通过BeanPostProcessor应用了各种</span></span><br><span class="line">        <span class="comment">// EmbeddedServletContainerCustomizer，</span></span><br><span class="line">        <span class="comment">// 比如 bean ServerProperties,DuplicateServerPropertiesDetector 等</span></span><br><span class="line">        EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</span><br><span class="line">        <span class="comment">// 创建相应的嵌入式 servlet 容器并完成配置和初始化</span></span><br><span class="line">        <span class="keyword">this</span>.embeddedServletContainer = containerFactory</span><br><span class="line">                .getEmbeddedServletContainer(getSelfInitializer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (localServletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getSelfInitializer().onStartup(localServletContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Cannot initialize servlet context"</span>,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initPropertySources();</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>
<h2 id="TomcatEmbeddedServletContainerFactory的方法getEmbeddedServletContainer"><a href="#TomcatEmbeddedServletContainerFactory的方法getEmbeddedServletContainer" class="headerlink" title="TomcatEmbeddedServletContainerFactory的方法getEmbeddedServletContainer"></a>TomcatEmbeddedServletContainerFactory的方法getEmbeddedServletContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建内置tomcat servlet 容器的启动器            </span></span><br><span class="line">    <span class="comment">// tomcat有多种配置和启动方式，最常见的方式是基于server.xml配置的启动器 </span></span><br><span class="line">    <span class="comment">// org.apache.catalina.startup.Bootstrap, 而这里的Tomcat是一个内嵌tomcat的启动器</span></span><br><span class="line">    <span class="comment">// 这个Tomcat启动器缺省会 ： </span></span><br><span class="line">    <span class="comment">// 1. 创建一个Tomcat Server，</span></span><br><span class="line">    <span class="comment">// 2. 创建并关联到这个 Tomcat Server上一个 Tomcat Service,</span></span><br><span class="line">    <span class="comment">// 一个 Tomcat Service是一个Tomcat Engineer和围绕着这个Tomcat Engine的多个Connector</span></span><br><span class="line">    <span class="comment">// 3. 在所创建的那一个 Tomcat Engine 上创建了一个 Tomcat Host</span></span><br><span class="line">    <span class="comment">// 一个 Tomcat Engine 上面可以有多个 Tomcat Host</span></span><br><span class="line">    Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    <span class="comment">// 如果设置了baseDirectory使用之，如果没有设置，在操作系统当前用户的临时目录下创建基础工作目录</span></span><br><span class="line">    <span class="comment">// 缺省情况下，baseDirectory 是没有被设置的</span></span><br><span class="line">    File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">            : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">    <span class="comment">// 设置tomcat的基础工作目录              </span></span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    <span class="comment">// 创建tomcat的Connector,缺省协议为org.apache.coyote.http11.Http11NioProtocol</span></span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    <span class="comment">// 订制化 connector, 设置端口，uri encoding字符集，ssl,是否使用压缩等</span></span><br><span class="line">    <span class="comment">// 缺省情况下端口是 8080, uri encoding 是 utf-8</span></span><br><span class="line">    customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    <span class="comment">// 关闭应用的自动部署</span></span><br><span class="line">    tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">    configureEngine(tomcat.getEngine());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定了更多附加的Tomcat Connector，也添加进来</span></span><br><span class="line">    <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备Tomcat StandardContext，对应一个webapp,并将其通过host关联到tomcat</span></span><br><span class="line">    <span class="comment">// 参考下面方法prepareContext的注释</span></span><br><span class="line">    prepareContext(tomcat.getHost(), initializers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TomcatEmbeddedServletContainer 并初始化</span></span><br><span class="line">    <span class="comment">// 其中包括调用 tomcat.start()</span></span><br><span class="line">    <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 纯程序方式创建并准备Tomcat StandardContext，它对应一个web应用，把它绑定到host上。</span></span><br><span class="line"><span class="comment">  * 参数initializers是上面步骤提供的SCI，将它关联到Tomcat StandardContext。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备Host的docBase,</span></span><br><span class="line">    File docBase = getValidDocumentRoot();</span><br><span class="line">    <span class="comment">// spring boot web应用启动过程中上面获得docBase会为null，实际会采用下面的</span></span><br><span class="line">    <span class="comment">// 创建临时目录动作完成 docBase的创建</span></span><br><span class="line">    docBase = (docBase != <span class="keyword">null</span> ? docBase : createTempDir(<span class="string">"tomcat-docbase"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建StandardContext，这是Tomcat的标准概念，用来对应表示一个web应用，</span></span><br><span class="line">    <span class="comment">// 这里使用实现类TomcatEmbeddedContext，由 spring boot 提供。</span></span><br><span class="line">    <span class="comment">// 以下创建和初始化一个TomcatEmbeddedContext的过程，可以认为是往tomcat servlet</span></span><br><span class="line">    <span class="comment">// 容器中部署和启动一个web应用的过程，只不过在传统方式下，一个web应用部署到tomcat使用</span></span><br><span class="line">    <span class="comment">// war包的方式，而这里是完全程序化的方式。</span></span><br><span class="line">    <span class="keyword">final</span> TomcatEmbeddedContext context = <span class="keyword">new</span> TomcatEmbeddedContext();</span><br><span class="line">    <span class="comment">// 设置StandardContext的名字，使用 context path，这个路径以/开始，没有/结尾；如果是根</span></span><br><span class="line">    <span class="comment">// StandardContext,这个 context path 为空字符串(0长度字符串);</span></span><br><span class="line">    context.setName(getContextPath());</span><br><span class="line">    context.setDisplayName(getDisplayName());</span><br><span class="line">    context.setPath(getContextPath());</span><br><span class="line">    context.setDocBase(docBase.getAbsolutePath());</span><br><span class="line">    context.addLifecycleListener(<span class="keyword">new</span> FixContextListener());</span><br><span class="line">    context.setParentClassLoader(</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.resourceLoader.getClassLoader()</span><br><span class="line">                    : ClassUtils.getDefaultClassLoader());</span><br><span class="line">    resetDefaultLocaleMapping(context);</span><br><span class="line">    addLocaleMappings(context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        context.setUseRelativeRedirects(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodError ex) &#123;</span><br><span class="line">        <span class="comment">// Tomcat is &lt; 8.0.30. Continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    SkipPatternJarScanner.apply(context, <span class="keyword">this</span>.tldSkipPatterns);</span><br><span class="line">    WebappLoader loader = <span class="keyword">new</span> WebappLoader(context.getParentClassLoader());</span><br><span class="line">    loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());</span><br><span class="line">    loader.setDelegate(<span class="keyword">true</span>);</span><br><span class="line">    context.setLoader(loader);</span><br><span class="line">    <span class="keyword">if</span> (isRegisterDefaultServlet()) &#123;</span><br><span class="line">        <span class="comment">// 缺省情况下，会注册 Tomcat 的 DefaultServlet,</span></span><br><span class="line">        <span class="comment">// DefaultServlet是Tomcat缺省的资源服务Servlet,用来服务</span></span><br><span class="line">        <span class="comment">// HTML,图片等静态资源</span></span><br><span class="line">        addDefaultServlet(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldRegisterJspServlet()) &#123;</span><br><span class="line">        <span class="comment">// 是否要注册 jsp servlet，缺省情况下，不注册</span></span><br><span class="line">        addJspServlet(context);</span><br><span class="line">        addJasperInitializer(context);</span><br><span class="line">        context.addLifecycleListener(<span class="keyword">new</span> StoreMergedWebXmlListener());</span><br><span class="line">    &#125;</span><br><span class="line">    context.addLifecycleListener(<span class="keyword">new</span> LifecycleListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) &#123;</span><br><span class="line">                TomcatResources.get(context)</span><br><span class="line">                        .addResourceJars(getUrlsOfJarsWithMetaInfResources());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 合并参数提供的Spring SCI : EmbeddedWebApplicationContext$1,</span></span><br><span class="line">    <span class="comment">// 这是一个匿名内部类，封装的逻辑来自方法 selfInitialize()</span></span><br><span class="line">    <span class="comment">// 和当前servlet容器在bean创建时通过EmbeddedServletContainerCustomizer</span></span><br><span class="line">    <span class="comment">// ServerProperties添加进来的两个Spring SCI :</span></span><br><span class="line">    <span class="comment">// ServerProperties$SessionConfiguringInitializer</span></span><br><span class="line">    <span class="comment">// InitParameterConfiguringServletContextInitializer</span></span><br><span class="line">    <span class="comment">// 注意这里的SCI接口由spring定义，tomcat jar中也包含了一个servlet API规范</span></span><br><span class="line">    <span class="comment">// 定义的SCI接口,这是定义相同的两个接口而非同一个,最终实现了Spring SCI接口的</span></span><br><span class="line">    <span class="comment">// 类的逻辑必须通过某种方式封装成实现了servlet API规范定义的SCI的逻辑才能被</span></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);</span><br><span class="line">    <span class="comment">// 配置context，</span></span><br><span class="line">    <span class="comment">// 1.将Spring提供的SCI封装成Servlet API标准SCI配置到context中去，</span></span><br><span class="line">    <span class="comment">// 通过一个实现了Servlet API标准SCI接口的spring类 TomcatStarter</span></span><br><span class="line">    <span class="comment">// 2.将spring领域的MIME映射配置设置到context中去，</span></span><br><span class="line">    <span class="comment">// 3.将spring领域的session配置设置到context中去，比如 sessionTimeout</span></span><br><span class="line">    configureContext(context, initializersToUse);</span><br><span class="line">    <span class="comment">// 将该context关联到host上去</span></span><br><span class="line">    host.addChild(context);</span><br><span class="line">    <span class="comment">// 内部实现为空</span></span><br><span class="line">    postProcessContext(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TomcatEmbeddedServletContainer并初始化</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TomcatEmbeddedServletContainer <span class="title">getTomcatEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Tomcat tomcat)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数要填充目标实例的属性autoStart，</span></span><br><span class="line">    缺省端口为<span class="number">8080</span>，所以getPort() &gt;=<span class="number">0</span> 为 <span class="keyword">true</span>,也就是传递 autoStart为<span class="keyword">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainer(tomcat, getPort() &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;   <span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137</span></span><br></pre></td></tr></table></figure>
<h2 id="TomcatEmbeddedServletContainer的创建和初始化"><a href="#TomcatEmbeddedServletContainer的创建和初始化" class="headerlink" title="TomcatEmbeddedServletContainer的创建和初始化"></a>TomcatEmbeddedServletContainer的创建和初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TomcatEmbeddedServletContainer有一个成员变量started，初始化值为 false,</span></span><br><span class="line"><span class="comment">// 用来表示容器是否处于已经启动状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatEmbeddedServletContainer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line">    <span class="keyword">this</span>.autoStart = autoStart;<span class="comment">//设置是否要自动启动标志</span></span><br><span class="line">    initialize(); <span class="comment">// 初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> EmbeddedServletContainerException </span>&#123;</span><br><span class="line">    TomcatEmbeddedServletContainer.logger</span><br><span class="line">            .info(<span class="string">"Tomcat initialized with port(s): "</span> + getPortsDescription(<span class="keyword">false</span>));</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 往引擎名字中增加instance Id信息，如果 instance id为0，则不修改引擎名字</span></span><br><span class="line">            addInstanceIdToEngineName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Remove service connectors to that protocol binding doesn't happen</span></span><br><span class="line">                <span class="comment">// yet</span></span><br><span class="line">                <span class="comment">// 注意，从容器中把Connector删掉，这样下面随后马上执行的start()动作</span></span><br><span class="line">                <span class="comment">// 只会启动容器中除了Connector之外的其他部分</span></span><br><span class="line">                removeServiceConnectors();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Start the server to trigger initialization listeners</span></span><br><span class="line">                <span class="comment">// 1.触发启动Tomcat容器中除了Connector之外的其他部分，</span></span><br><span class="line">                <span class="comment">// Connector此处不没启动意味着该启动过程完成后，服务器还是不能接受来自</span></span><br><span class="line">                <span class="comment">// 网络的请求,因为Connector才是真正负责接受网络请求的入口。</span></span><br><span class="line">                <span class="comment">// 问题 : 这个过程，Spring 为什么要这么处理呢 ？</span></span><br><span class="line">                <span class="comment">// 2. 这里Tomcat启动的主要是</span></span><br><span class="line">                <span class="comment">// StandardServer[1实例,Tomcat Lifecycle]==&gt;</span></span><br><span class="line">                <span class="comment">// StandardService[1实例,Tomcat Lifecycle]==&gt;</span></span><br><span class="line">                <span class="comment">// StandardEngine[1实例,Tomcat Container]==异步startStopExecutor==&gt;</span></span><br><span class="line">                <span class="comment">// StandardHost[1实例,Tomcat Container]==异步startStopExecutor==&gt;</span></span><br><span class="line">                <span class="comment">// TomcatEmbeddedContext[1实例,Springboot实现的Tomcat Container]==&gt;</span></span><br><span class="line">                <span class="comment">// StandardWrapper[1实例,Tomcat Container]。</span></span><br><span class="line">                <span class="comment">// 这里StandardWrapper对应的Servlet是Spring MVC的DispatchServlet。</span></span><br><span class="line">                <span class="comment">// 上面Tomcat Container父容器启动子容器都是通过线程池异步方式启动的。</span></span><br><span class="line">                <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We can re-throw failure exception directly in the main thread</span></span><br><span class="line">                rethrowDeferredStartupExceptions();</span><br><span class="line"></span><br><span class="line">                Context context = findContext();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ContextBindings.bindClassLoader(context, getNamingToken(context),</span><br><span class="line">                            getClass().getClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">                    <span class="comment">// Naming is not enabled. Continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class="line">                <span class="comment">// blocking non-daemon to stop immediate shutdown</span></span><br><span class="line">                <span class="comment">// tomcat 自身所有的线程都是daemon线程。这里spring创建了一个非daemon线程用来</span></span><br><span class="line">                <span class="comment">// 阻塞整个应用，避免刚启动就马上结束的情况。</span></span><br><span class="line">                startDaemonAwaitThread();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                containerCounter.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmbeddedServletContainerException(</span><br><span class="line">                    <span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tomcat-StandardContxt启动过程中SCI的应用"><a href="#Tomcat-StandardContxt启动过程中SCI的应用" class="headerlink" title="Tomcat StandardContxt启动过程中SCI的应用"></a>Tomcat StandardContxt启动过程中SCI的应用</h2><p>上面过程创建的StandardContext实例，也就是所对应的webapp，已经关联但是尚未应用spring提供的SCI。这些SCI的应用是在StandardContext.startInternal()中应用SCI阶段进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 ServletContainerInitializer(备注 : 缩写为SCI)</span></span><br><span class="line"><span class="comment">// 这里的SCI接口是Servlet API标准SCI接口,而不是Spring定义的SCI接口。上面的流程分析中已经讲到，</span></span><br><span class="line"><span class="comment">// prepareContext()过程中已经将Spring准备的多个Spring SCI封装成一个Servlet API规范SCI</span></span><br><span class="line"><span class="comment">// 实现TomcatStarter关联到了tomcat容器,这里的initializers 就是这些封装后的Servlet API</span></span><br><span class="line"><span class="comment">//  SCI实例。在使用缺省配置的Springboot Web应用中,以下for循环中的initializers其实只有一个,</span></span><br><span class="line"><span class="comment">// 就是前面提到的Spring提供的实现了Servlet API标准SCI接口TomcatStarter。</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry : </span><br><span class="line">    initializers.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用SCI的onStartup()方法，getServletContext()是基于当前StandardContext创建</span></span><br><span class="line">        <span class="comment">// 的ServletContext的facade</span></span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                getServletContext());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.sciFail"</span>), e);</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<p>这里对Tomcat标准SCI TomcatStarter 的调用，最终还是调用了Spring提供的3个SCI ：<br>\1. EmbeddedWebApplicationContext匿名内部类，封装的逻辑来自方法 selfInitialize()<br>\2. ServerProperties$SessionConfiguringInitializer<br>\3. InitParameterConfiguringServletContextInitializer</p>
<h3 id="EmbeddedWebApplicationContext的selfInitialize"><a href="#EmbeddedWebApplicationContext的selfInitialize" class="headerlink" title="EmbeddedWebApplicationContext的selfInitialize"></a>EmbeddedWebApplicationContext的selfInitialize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * servletContext是一个Java Servlet规范里面的概念，这里其实现由Tomcat提供</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selfInitialize</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.将当前spring application context作为属性设置到servletContext :</span></span><br><span class="line">        <span class="comment">// WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span></span><br><span class="line">        <span class="comment">// 随后应用启动完在提供Web服务的时候,Spring MVC dispatchServlet的应用上下文</span></span><br><span class="line">        <span class="comment">// 的双亲就会使用这个根Web应用上下文       </span></span><br><span class="line">        <span class="comment">// 2.将servletContext记录到当前web application context，也就是当前</span></span><br><span class="line">        <span class="comment">// EmbeddedWebApplicationContext对象的属性servletContext中</span></span><br><span class="line">        prepareEmbeddedWebApplicationContext(servletContext);</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="comment">// 获取用户自定义webapp作用域</span></span><br><span class="line">        ExistingWebApplicationScopes existingScopes = <span class="keyword">new</span> ExistingWebApplicationScopes(</span><br><span class="line">                beanFactory);</span><br><span class="line">        <span class="comment">//注册标准webapp作用域             </span></span><br><span class="line">        WebApplicationContextUtils.registerWebApplicationScopes(beanFactory,</span><br><span class="line">                getServletContext());</span><br><span class="line">        <span class="comment">// 重新注册用户自定义webapp作用域               </span></span><br><span class="line">        existingScopes.restore();</span><br><span class="line">        <span class="comment">// 注册webapp相关环境参数bean : contextParameters,contextAttributes</span></span><br><span class="line">        <span class="comment">// WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME</span></span><br><span class="line">        <span class="comment">// WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME</span></span><br><span class="line">        <span class="comment">// WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME</span></span><br><span class="line">        WebApplicationContextUtils.registerEnvironmentBeans(beanFactory,</span><br><span class="line">                getServletContext());</span><br><span class="line">        <span class="comment">// !!! 到目前为止，尚未初始化webapp中的Servlet，Filter 和 EventListener                </span></span><br><span class="line">        <span class="comment">// 从Bean容器中找到所有的SCI bean,并调用其 onStartup()回调方法</span></span><br><span class="line">        <span class="comment">// getServletContextInitializerBeans()会从bean容器中找到所有的SCI bean，</span></span><br><span class="line">        <span class="comment">// 将bean容器中所有Servlet, Filter 和EventListener bean转换成SCI 然后返回</span></span><br><span class="line">        <span class="comment">// 给该for循环然后逐一调用其 onStartup() 回调。</span></span><br><span class="line">        <span class="comment">// !!! 这里是真正的Servlet, Filter 和EventListener注入到ServletContext的触发点</span></span><br><span class="line">        <span class="keyword">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;</span><br><span class="line">            beans.onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到此为止，一个完整的符合开发者设计目的的WebApp才算是被启动和被完整设置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns ServletContextInitializers that should be used with the embedded</span></span><br><span class="line"><span class="comment">     * Servlet context. By default this method will first attempt to find</span></span><br><span class="line"><span class="comment">     * ServletContextInitializer, Servlet, Filter and certain</span></span><br><span class="line"><span class="comment">     * EventListener beans.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 返回所有需要被应用到Servlet context上的ServletContextInitializer。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 缺省情况下:</span></span><br><span class="line"><span class="comment">     * 1.该方法会首先尝试bean容器中注册的 ServletContextInitializer bean,</span></span><br><span class="line"><span class="comment">     * 2.然后是各种适配bean,比如 Servlet, Filter 和EventListener bean，</span></span><br><span class="line"><span class="comment">     * 将它们封装成实现了接口 ServletContextInitializer 的 RegistrationBean 。</span></span><br><span class="line"><span class="comment">     * 3.最后将上面所有找到的 ServletContextInitializer bean 和封装的 RegistrationBean </span></span><br><span class="line"><span class="comment">     * 返回给调用者。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the servlet initializer beans</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;ServletContextInitializer&gt; <span class="title">getServletContextInitializerBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletContextInitializerBeans(getBeanFactory());</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prepare the WebApplicationContext with the given fully loaded</span></span><br><span class="line"><span class="comment">     * ServletContext. This method is usually called from</span></span><br><span class="line"><span class="comment">     * ServletContextInitializer#onStartup(ServletContext) and is similar to the</span></span><br><span class="line"><span class="comment">     * functionality usually provided by a ContextLoaderListener.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext the operational servlet context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareEmbeddedWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从Servlet Context上面读取属性ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，根Web应用上下文</span></span><br><span class="line">        Object rootContext = servletContext.getAttribute(</span><br><span class="line">                WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (rootContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果在 Servlet Context上面已经设置了属性ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span></span><br><span class="line">        <span class="comment">// 这块逻辑表明根Web应用上下文只能初始化一次并绑定到Servlet Context的这个属性上              </span></span><br><span class="line">            <span class="keyword">if</span> (rootContext == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Cannot initialize context because there is already a root application context present - "</span></span><br><span class="line">                                + <span class="string">"check whether you have multiple ServletContextInitializers!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">        servletContext.log(<span class="string">"Initializing Spring embedded WebApplicationContext"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将this对象,也就是当前EmbeddedWebApplicationContext Web应用上下文对象设置为</span></span><br><span class="line">            <span class="comment">// 当前ServletContext上下文的属性ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,</span></span><br><span class="line">            <span class="comment">// 随后应用启动完在提供Web服务的时候,Spring MVC dispatchServlet的应用上下文</span></span><br><span class="line">            <span class="comment">// 的双亲就会使用这个根Web应用上下文</span></span><br><span class="line">            servletContext.setAttribute(</span><br><span class="line">                    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(</span><br><span class="line">                        <span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span></span><br><span class="line">                                + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span><br><span class="line">                                + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setServletContext(servletContext);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - getStartupDate();</span><br><span class="line">                logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span></span><br><span class="line">                        + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">            servletContext.setAttribute(</span><br><span class="line">                    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error ex) &#123;</span><br><span class="line">            logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">            servletContext.setAttribute(</span><br><span class="line">                    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116</span></span><br></pre></td></tr></table></figure>
<p>缺省spring boot web应用中ServletContextInitializerBeans 从 beanFactory所获得的SCI :</p>
<table>
<thead>
<tr>
<th>Bean</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>dispatcherServlet</td>
<td>ServletRegistrationBean</td>
</tr>
<tr>
<td>characterEncodingFilter</td>
<td>FilterRegistrationBean</td>
</tr>
<tr>
<td>hiddenHttpMethodFilter</td>
<td>FilterRegistrationBean</td>
</tr>
<tr>
<td>httpPutFormContentFilter</td>
<td>FilterRegistrationBean</td>
</tr>
<tr>
<td>requestContextFilter</td>
<td>FilterRegistrationBean</td>
</tr>
</tbody>
</table>
<p>想了解以上各个Bean都是什么用途，请参考 :<br><a href="http://blog.csdn.net/andy_zhang2007/article/details/78543671" target="_blank" rel="noopener">缺省配置Springboot Web应用启动过程中Bean定义的登记</a></p>
<h3 id="ServerProperties内部类SessionConfiguringInitializer"><a href="#ServerProperties内部类SessionConfiguringInitializer" class="headerlink" title="ServerProperties内部类SessionConfiguringInitializer"></a>ServerProperties内部类SessionConfiguringInitializer</h3><p>设置SessionCookieConfig</p>
<h3 id="InitParameterConfiguringServletContextInitializer"><a href="#InitParameterConfiguringServletContextInitializer" class="headerlink" title="InitParameterConfiguringServletContextInitializer"></a>InitParameterConfiguringServletContextInitializer</h3><p>将init参数设置到ServletContext上的一个SCI</p>
<h1 id="内置Tomcat-servlet容器的启动"><a href="#内置Tomcat-servlet容器的启动" class="headerlink" title="内置Tomcat servlet容器的启动"></a>内置Tomcat servlet容器的启动</h1><p>在整个上面的启动过程中，虽然调用 Tomcat 实例的启动方法，但是整个容器tomcatEmbeddedServletContainer只能算是启动了一部分，也就是其中除了Tomcat Connector 之外的其他部分。</p>
<p>此时tomcatEmbeddedServletContainer实例的属性 started仍然为false，表示整个容器处于尚未启动的状态。所以上的逻辑更像是容器创建和初始化的过程。</p>
<p>Tomcat Connector是用来接收来自网络的请求的关键组件。这一部分组件启动之后，整个容器tomcatEmbeddedServletContainer才能接受和处理来自网络的请求从而为用户提供服务，所以所有这些的启动都结束，才能算是整个容器的启动完成，此时started属性才能设置为true。</p>
<p>该小节容器的启动，主要就是讲容器中Tomcat Connector的启动。</p>
<h2 id="启动入口点"><a href="#启动入口点" class="headerlink" title="启动入口点"></a>启动入口点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run()</span><br><span class="line">=&gt;refresh(ApplicationContext applicationContext)</span><br><span class="line">    =&gt;EmbeddedWebApplicationContext.refresh()</span><br><span class="line">    =&gt;EmbeddedWebApplicationContext.finishRefresh()</span><br><span class="line">    =&gt;startEmbeddedServletContainer()</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h2 id="启动入口点代码分析"><a href="#启动入口点代码分析" class="headerlink" title="启动入口点代码分析"></a>启动入口点代码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类EmbeddedWebApplicationContext的方法finishRefresh()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先调用父类AbstractApplicationContext的finishRefresh()</span></span><br><span class="line">        <span class="keyword">super</span>.finishRefresh();</span><br><span class="line">        <span class="comment">// 启动内置Servlet容器</span></span><br><span class="line">        EmbeddedServletContainer localContainer = startEmbeddedServletContainer();</span><br><span class="line">        <span class="keyword">if</span> (localContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 容器已经启动，可以接受来自外部的HTTP请求了，发布事件 :</span></span><br><span class="line">            <span class="comment">// EmbeddedServletContainerInitializedEvent</span></span><br><span class="line">            publishEvent(</span><br><span class="line">                    <span class="keyword">new</span> EmbeddedServletContainerInitializedEvent(<span class="keyword">this</span>, localContainer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类EmbeddedWebApplicationContext的方法startEmbeddedServletContainer()</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> EmbeddedServletContainer <span class="title">startEmbeddedServletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EmbeddedServletContainer localContainer = <span class="keyword">this</span>.embeddedServletContainer;</span><br><span class="line">        <span class="keyword">if</span> (localContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用内置servlet容器TomcatEmbeddedServletContainer实例上的start()方法</span></span><br><span class="line">            localContainer.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> localContainer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>
<h2 id="内置servlet容器的启动过程"><a href="#内置servlet容器的启动过程" class="headerlink" title="内置servlet容器的启动过程"></a>内置servlet容器的启动过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TomcatEmbeddedServletContainer 的start方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> EmbeddedServletContainerException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将内置容器创建和初始化阶段删除的Connector再添加到容器，</span></span><br><span class="line">            <span class="comment">// 将Connector添加回容器(实际上是添加到容器的Service)，</span></span><br><span class="line">            <span class="comment">// 因为相应的Service已经处于启动状态，所以Connector在</span></span><br><span class="line">            <span class="comment">// 添加回来之后马上会被启动</span></span><br><span class="line">            addPreviouslyRemovedConnectors();</span><br><span class="line">            <span class="comment">// 获得tomcat的Connector，如果不为空并且设置为自动启动，</span></span><br><span class="line">            <span class="comment">// 则启动之。缺省配置下，这里 autoStart 为 true</span></span><br><span class="line">            Connector connector = <span class="keyword">this</span>.tomcat.getConnector();</span><br><span class="line">            <span class="keyword">if</span> (connector != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.autoStart) &#123;</span><br><span class="line">                startConnector(connector);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查确保Connector已经启动，如果没启动，抛出异常</span></span><br><span class="line">            checkThatConnectorsHaveStarted();</span><br><span class="line">            <span class="keyword">this</span>.started = <span class="keyword">true</span>;</span><br><span class="line">            TomcatEmbeddedServletContainer.logger</span><br><span class="line">                    .info(<span class="string">"Tomcat started on port(s): "</span> + getPortsDescription(<span class="keyword">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ConnectorStartFailedException ex) &#123;</span><br><span class="line">            stopSilently();</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmbeddedServletContainerException(</span><br><span class="line">                    <span class="string">"Unable to start embedded Tomcat servlet container"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            Context context = findContext();</span><br><span class="line">            ContextBindings.unbindClassLoader(context, getNamingToken(context),</span><br><span class="line">                    getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TomcatEmbeddedServletContainer 的 addPreviouslyRemovedConnectors 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPreviouslyRemovedConnectors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Service[] services = <span class="keyword">this</span>.tomcat.getServer().findServices();</span><br><span class="line">    <span class="keyword">for</span> (Service service : services) &#123;</span><br><span class="line">        Connector[] connectors = <span class="keyword">this</span>.serviceConnectors.get(service);</span><br><span class="line">        <span class="keyword">if</span> (connectors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">                <span class="comment">// 此时service已经处于启动状态，因此重新添加进来的connector</span></span><br><span class="line">                <span class="comment">// 也没马上被执行启动动作</span></span><br><span class="line">                service.addConnector(connector);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.autoStart) &#123;</span><br><span class="line">                    stopProtocolHandler(connector);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.serviceConnectors.remove(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</span></span><br></pre></td></tr></table></figure>
<h2 id="Tomcat-Connector的启动"><a href="#Tomcat-Connector的启动" class="headerlink" title="Tomcat Connector的启动"></a>Tomcat Connector的启动</h2><h3 id="启动入口点-1"><a href="#启动入口点-1" class="headerlink" title="启动入口点"></a>启动入口点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Service.addConnector()</span><br><span class="line">  =&gt; Connector.start()<span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="启动入口点逻辑分析"><a href="#启动入口点逻辑分析" class="headerlink" title="启动入口点逻辑分析"></a>启动入口点逻辑分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StandardService 的方法 addConnector</span></span><br><span class="line"><span class="comment">//StandardService 是tomcat提供的类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnector</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="comment">// 将connector关联到当前 service</span></span><br><span class="line">        connector.setService(<span class="keyword">this</span>);</span><br><span class="line">        Connector results[] = <span class="keyword">new</span> Connector[connectors.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(connectors, <span class="number">0</span>, results, <span class="number">0</span>, connectors.length);</span><br><span class="line">        results[connectors.length] = connector;</span><br><span class="line">        connectors = results;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前服务的状态是 available，则在将 connector 增加到service时</span></span><br><span class="line">        <span class="comment">// 直接启动 connector</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 启动新增进来的 connector</span></span><br><span class="line">                connector.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(</span><br><span class="line">                        <span class="string">"standardService.connector.startFailed"</span>,</span><br><span class="line">                        connector), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Report this property change to interested listeners</span></span><br><span class="line">        support.firePropertyChange(<span class="string">"connector"</span>, <span class="keyword">null</span>, connector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<h3 id="Connector启动过程分析"><a href="#Connector启动过程分析" class="headerlink" title="Connector启动过程分析"></a>Connector启动过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector是tomcat提供的类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate settings before starting</span></span><br><span class="line">    <span class="keyword">if</span> (getPort() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.invalidPort"</span>, Integer.valueOf(getPort())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Connector启动的核心动作是协议处理器的启动</span></span><br><span class="line">        <span class="comment">// 对于缺省配置的springboot web应用，这里是一个处理http协议请求的</span></span><br><span class="line">        <span class="comment">// Http11NioProtocol 实例，使用 nio 方式处理 http 协议 (http 或者 https)</span></span><br><span class="line">        protocolHandler.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        String errPrefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            errPrefix += <span class="string">"service.getName(): \""</span> + <span class="keyword">this</span>.service.getName() + <span class="string">"\"; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</span><br><span class="line">            (errPrefix + <span class="string">" "</span> + sm.getString</span><br><span class="line">             (<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>
<h3 id="Http11NioProtocol启动过程分析"><a href="#Http11NioProtocol启动过程分析" class="headerlink" title="Http11NioProtocol启动过程分析"></a>Http11NioProtocol启动过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用链 :</span></span><br><span class="line"><span class="comment">// Connector.start()</span></span><br><span class="line"><span class="comment">//  =&gt; startInternal()</span></span><br><span class="line"><span class="comment">//    =&gt; Http11NioProtocol protocolHandler.start();</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Http11NioProtocol 的 start方法，由基类 AbstractProtocol 提供实现</span></span><br><span class="line"><span class="comment">// Http11NioProtocol ,AbstractProtocol 都是tomcat提供的类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled())</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.start"</span>,</span><br><span class="line">                getName()));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动了成员变量endpoint,一个 NioEndpoint 实例</span></span><br><span class="line">        endpoint.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        getLog().error(sm.getString(<span class="string">"abstractProtocolHandler.startError"</span>,</span><br><span class="line">                getName()), ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start async timeout thread</span></span><br><span class="line">    asyncTimeout = <span class="keyword">new</span> AsyncTimeout();</span><br><span class="line">    Thread timeoutThread = <span class="keyword">new</span> Thread(asyncTimeout, getNameInternal() + <span class="string">"-AsyncTimeout"</span>);</span><br><span class="line">    <span class="keyword">int</span> priority = endpoint.getThreadPriority();</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">        priority = Thread.NORM_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutThread.setPriority(priority);</span><br><span class="line">    timeoutThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    timeoutThread.start();</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br><span class="line"><span class="comment">// 调用链 :</span></span><br><span class="line"><span class="comment">// Connector.start()</span></span><br><span class="line"><span class="comment">//  =&gt; startInternal()</span></span><br><span class="line"><span class="comment">//    =&gt; Http11NioProtocol protocolHandler.start();</span></span><br><span class="line"><span class="comment">//       =&gt; NioEndpoint endpoint.start()</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// NioEndpoint的start()方法，在其基类AbstractEndpoint中实现</span></span><br><span class="line"><span class="comment">// NioEndpoint,AbstractEndpoint都是tomcat提供的类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">        <span class="comment">// 如果端口绑定状态为未绑定，这里执行端口绑定逻辑</span></span><br><span class="line">        bind();</span><br><span class="line">        bindState = BindState.BOUND_ON_START;</span><br><span class="line">    &#125;</span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractEndpoint的bind()方法实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 建立服务套接字，并绑定到指定的端口,</span></span><br><span class="line">    <span class="comment">// 缺省配置的spring-boot web应用，这里的端口是 8080</span></span><br><span class="line">    serverSock = ServerSocketChannel.open();</span><br><span class="line">    socketProperties.setProperties(serverSock.socket());</span><br><span class="line">    InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">    serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Doesn't seem to work that well with multiple accept threads</span></span><br><span class="line">        acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minimum one poller thread</span></span><br><span class="line">        pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;   </span><br><span class="line"> <span class="comment">//AbstractEndpoint的startInternal()方法实现 </span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start the NIO endpoint, creating acceptor, poller threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        <span class="comment">// 设置运行状态</span></span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        <span class="comment">// NioChannel 实现了 NIO ByteChannel 接口</span></span><br><span class="line">        nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create worker collection</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// 如果尚未指定 executor, 则创建内部的任务执行线程</span></span><br><span class="line">            <span class="comment">// 缺省配置的 spring boot web 应用没有外部指定的 executor</span></span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个LimitLatch,用于控制最大连接数，缺省值10000</span></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建和启动 Poller 线程</span></span><br><span class="line">        <span class="comment">// 1. Poller类是一个Runnable.每个Poller对象会保持一个Java NIO Selector</span></span><br><span class="line">        <span class="comment">//    和一个PollerEvent队列SynchronizedQueue.每个PollerEvent携带一个</span></span><br><span class="line">        <span class="comment">//    </span></span><br><span class="line">        <span class="comment">// 2. Poller 线程数量会使用当前计算机CPU processor数量和2的最小值</span></span><br><span class="line">        <span class="comment">// 3. 每个Poller线程都是　daemon 线程            </span></span><br><span class="line">        <span class="comment">// 4. Poller线程名称前缀 : http-nio-8080-ClientPoller-</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建和启动请求接收线程</span></span><br><span class="line">        <span class="comment">// 1. 接收线程缺省只有1个</span></span><br><span class="line">        <span class="comment">// 2. 接收线程名称前缀 : http-nio-8080-Acceptor-</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractEndpoint的createExecutor()方法实现 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 创建基于ThreadPoolExecutor的任务执行队列</span></span><br><span class="line">    TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">"-exec-"</span>, daemon, getThreadPriority());</span><br><span class="line">    <span class="comment">// 创建的线程名称前缀为 http-nio-8080-exec-</span></span><br><span class="line">    executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// NioEndpoint 类的重写实现，创建一个AbstractEndpoint.Acceptor，实现了 Runnable接口</span></span><br><span class="line"><span class="comment">// 这里的类 Acceptor 是一个 NioEndpoint 内部类,用于接收套接字并交给合适的处理器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AbstractEndpoint.<span class="function">Acceptor <span class="title">createAcceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Acceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2018-09-10T12:54:11.000Z" itemprop="dateUpdated">2018-09-10 20:54:11</time>
</span><br>


        
        <a href="/2018/08/19/Java/spring/boot/embeddedTomcat/" target="_blank" rel="external">http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/</a>
        
    </div>
    
    <footer>
        <a href="http://io.stelawliet.top">
            <img src="/img/avatar.jpg" alt="Stelawliet">
            Stelawliet
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/&title=《缺省配置Springboot Web应用中tomcat的启动过程@csdn》 — stelawliet&pic=http://io.stelawliet.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/&title=《缺省配置Springboot Web应用中tomcat的启动过程@csdn》 — stelawliet&source=sky" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《缺省配置Springboot Web应用中tomcat的启动过程@csdn》 — stelawliet&url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/&via=http://io.stelawliet.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/08/21/Linux/oh-my-zsh/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">oh-my-zsh install</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/08/18/Java/spring/ioc/@Value${}解析器/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">[no title]</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "yg0YOBlsgCru0mqR8zfr7Xsm-gzGzoHsz",
            appKey: "QDgspYKufF8K1YCR46v7udft",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>このブログの内容物は<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Stelawliet &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/&title=《缺省配置Springboot Web应用中tomcat的启动过程@csdn》 — stelawliet&pic=http://io.stelawliet.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/&title=《缺省配置Springboot Web应用中tomcat的启动过程@csdn》 — stelawliet&source=sky" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《缺省配置Springboot Web应用中tomcat的启动过程@csdn》 — stelawliet&url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/&via=http://io.stelawliet.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://io.stelawliet.top/2018/08/19/Java/spring/boot/embeddedTomcat/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtUlEQVR42u3aQU4kMQwFUO5/6RlptlDN/3bSMNKrFeqiQ14WsbH98RE/f/49nz95ep5+J1k538OxBw8PD2+09Xajn98+/fx0NE+fbPbzxRHg4eHhXeO9vojby/017Ok48tWKMIOHh4f3o7xZypuEk3wFPDw8vP+RN6O+Di1tMQIPDw/vN/DackP+JJtr0+grtRY8PDy8mLe5lH/q54v9PTw8PLxFVz2/cJO3bbG4HVb44rt4eHh4F3htmXUTPNr2f5soF/8x4OHh4a15ecsqKSUk20rAOSNvpOHh4eHteRtAexA3Rri+WRkPDw/vAq9d+vVC+yryLGAUcQ8PDw9vzcuLs205YHbptyWJOgzg4eHhHeLlxYVTLa59Iy0KYHh4eHgXeLO6b35B5+2uBJnvEw8PD+89vHxDbRusHVNoV466eXh4eHiHeMWgUgzOP2kDQNuow8PDw7vHa3tls8JEkv7ORrUeQx0eHh7eBd4MsBkpaFc+UOTFw8PDu8DbLLppU7VFirxthoeHh3ePt7ncN6WH9lvDsgUeHh7eZV7b4J8l0PnbPOF+3AMeHh7eBV4yOpCksLMGWFuGGBYy8PDw8I7y2nbXqUGrZM38UI719/Dw8PBi3mYoalZuaAu+eYj6ZqYMDw8Pb83Ly7JtSNikzknAKN7i4eHhHeUll+9mKmE2ELA5Sjw8PLz382bJcf52lhbPAg8eHh7eDd5+c7ORrHacqw1OH6fOHg8PD68syM4KqQm+PaY2QY/iHh4eHt6INys65Pg2LU7CxqzIi4eHh3eWl5ck8j+csNsVhoEKDw8P7xqv/fPJd08Nda1Sdjw8PLwf5c2KF/lVnrS+2uYZHh4e3m/gzZpS+4u+PW48PDy827z3FCNef962vqLwgIeHh3eBt7no82GCTVp8uJuHh4eHN+f9BUFAXpNZqy1+AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'sky';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
