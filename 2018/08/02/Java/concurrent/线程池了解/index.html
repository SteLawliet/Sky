<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>tcp握手挥手分析@github | stelawliet | 迁移整理中...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="摘抄,掘金,tcp">
    <meta name="description" content="如何优雅的使用和理解线程池前言平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：  可见线程池的重要性。 简单来说使用线程池有以下几个目的：  线程是稀缺资源，不能频繁的创建。 解耦作用；线程的创建于执行完全分开，方便维护。 应当将其放入一个池子中，可以给其他任务进行复用。  线程池原理谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资">
<meta name="keywords" content="摘抄,掘金,tcp">
<meta property="og:type" content="article">
<meta property="og:title" content="tcp握手挥手分析@github">
<meta property="og:url" content="http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/index.html">
<meta property="og:site_name" content="stelawliet">
<meta property="og:description" content="如何优雅的使用和理解线程池前言平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：  可见线程池的重要性。 简单来说使用线程池有以下几个目的：  线程是稀缺资源，不能频繁的创建。 解耦作用；线程的创建于执行完全分开，方便维护。 应当将其放入一个池子中，可以给其他任务进行复用。  线程池原理谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/30/164e8a5a8813116f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/30/164e8a5a93d4f1f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2018-08-02T10:29:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tcp握手挥手分析@github">
<meta name="twitter:description" content="如何优雅的使用和理解线程池前言平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：  可见线程池的重要性。 简单来说使用线程池有以下几个目的：  线程是稀缺资源，不能频繁的创建。 解耦作用；线程的创建于执行完全分开，方便维护。 应当将其放入一个池子中，可以给其他任务进行复用。  线程池原理谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资">
<meta name="twitter:image" content="data:image/svg+xml;utf8,<?xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Stelawliet</h5>
          <a href="mailto:Stelawliet@gmail.com" title="Stelawliet@gmail.com" class="mail">Stelawliet@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Stelawliet" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Stelawliet" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                twitter
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Stelawliet"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">tcp握手挥手分析@github</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">tcp握手挥手分析@github</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-08-02T10:19:14.000Z" itemprop="datePublished" class="page-time">
  2018-08-02
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/server/">server</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#如何优雅的使用和理解线程池"><span class="post-toc-number">1.</span> <span class="post-toc-text">如何优雅的使用和理解线程池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程池原理"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">线程池原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何配置线程"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">如何配置线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#优雅的关闭线程池"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">优雅的关闭线程池</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SpringBoot-使用线程池"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">SpringBoot 使用线程池</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#监控线程池"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">监控线程池</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程池隔离"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">线程池隔离</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hystrix-隔离"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">hystrix 隔离</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">总结</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Java/concurrent/线程池了解"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">tcp握手挥手分析@github</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-08-02 18:19:14" datetime="2018-08-02T10:19:14.000Z"  itemprop="datePublished">2018-08-02</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/server/">server</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="如何优雅的使用和理解线程池"><a href="#如何优雅的使用和理解线程池" class="headerlink" title="如何优雅的使用和理解线程池"></a>如何优雅的使用和理解线程池</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><img src="" alt=""></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<ul>
<li>线程是稀缺资源，不能频繁的创建。</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>应当将其放入一个池子中，可以给其他任务进行复用。</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
<li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
<li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>
<p>其实看这三种方式创建的源码就会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>
<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(new Job());</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p>用图表示为：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
<p>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<h3 id="如何配置线程"><a href="#如何配置线程" class="headerlink" title="如何配置线程"></a>如何配置线程</h3><p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2</li>
<li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>
<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<blockquote>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt;= 5; i++) &#123;</span><br><span class="line">            pool.execute(new Job());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            LOGGER.info(&quot;线程还在执行。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<h2 id="SpringBoot-使用线程池"><a href="#SpringBoot-使用线程池" class="headerlink" title="SpringBoot 使用线程池"></a>SpringBoot 使用线程池</h2><p>2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。</p>
<p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TreadPoolConfig &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费队列线程</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(value = &quot;consumerQueueThreadPool&quot;)</span><br><span class="line">    public ExecutorService buildConsumerQueueThreadPool()&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        return pool ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    @Resource(name = &quot;consumerQueueThreadPool&quot;)</span><br><span class="line">    private ExecutorService consumerQueueThreadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line"></span><br><span class="line">        //消费队列</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            consumerQueueThreadPool.execute(new ConsumerQueueThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>
<h2 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h2><p>谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。</p>
<p>线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。</p>
<p>关于 actuator 就不再细说了，感兴趣的可以看看<a href="https://link.juejin.im/?target=http%3A%2F%2Ft.cn%2FReimM0o" target="_blank" rel="noopener">这篇</a>，有详细整理过如何暴露监控端点。</p>
<p>其实 ThreadPool 本身已经提供了不少 api 可以获取线程状态：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<p>很多方法看名字就知道其含义，只需要将这些信息暴露到 SpringBoot 的监控端点中，我们就可以在可视化页面查看当前的线程池状态了。</p>
<p>甚至我们可以继承线程池扩展其中的几个函数来自定义监控逻辑：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="data:image/svg+xml;utf8,<?xml" alt="img" title="version=1.0?><svg">
                </div>
                <div class="image-caption">version=1.0?><svg< div="">
            </svg<></div></figure>
<p>看这些名称和定义都知道，这是让子类来实现的。</p>
<p>可以在线程执行前、后、终止状态执行自定义逻辑。</p>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><blockquote>
<p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>
<p>如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>
<p>通常的做法是按照业务进行划分：</p>
<blockquote>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h3><p>这样的需求 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FNetflix%2FHystrix" target="_blank" rel="noopener">Hystrix</a> 已经帮我们实现了。</p>
<blockquote>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>
<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Function:订单服务</span><br><span class="line"> *</span><br><span class="line"> * @author crossoverJie</span><br><span class="line"> *         Date: 2018/7/28 16:43</span><br><span class="line"> * @since JDK 1.8</span><br><span class="line"> */</span><br><span class="line">public class CommandOrder extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);</span><br><span class="line"></span><br><span class="line">    private String orderName;</span><br><span class="line"></span><br><span class="line">    public CommandOrder(String orderName) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                //服务分组</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;))</span><br><span class="line">                //线程分组</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;))</span><br><span class="line"></span><br><span class="line">                //线程池配置</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(10)</span><br><span class="line">                        .withKeepAliveTimeMinutes(5)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(10000))</span><br><span class="line"></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;orderName=[&#123;&#125;]&quot;, orderName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        return &quot;OrderName=&quot; + orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Function:用户服务</span><br><span class="line"> *</span><br><span class="line"> * @author crossoverJie</span><br><span class="line"> *         Date: 2018/7/28 16:43</span><br><span class="line"> * @since JDK 1.8</span><br><span class="line"> */</span><br><span class="line">public class CommandUser extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public CommandUser(String userName) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                //服务分组</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;))</span><br><span class="line">                //线程分组</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;))</span><br><span class="line"></span><br><span class="line">                //线程池配置</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(10)</span><br><span class="line">                        .withKeepAliveTimeMinutes(5)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(10000))</span><br><span class="line"></span><br><span class="line">                //线程池隔离</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;userName=[&#123;&#125;]&quot;, userName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        return &quot;userName=&quot; + userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CommandOrder commandPhone = new CommandOrder(&quot;手机&quot;);</span><br><span class="line">        CommandOrder command = new CommandOrder(&quot;电视&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //阻塞方式执行</span><br><span class="line">        String execute = commandPhone.execute();</span><br><span class="line">        LOGGER.info(&quot;execute=[&#123;&#125;]&quot;, execute);</span><br><span class="line"></span><br><span class="line">        //异步非阻塞方式</span><br><span class="line">        Future&lt;String&gt; queue = command.queue();</span><br><span class="line">        String value = queue.get(200, TimeUnit.MILLISECONDS);</span><br><span class="line">        LOGGER.info(&quot;value=[&#123;&#125;]&quot;, value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CommandUser commandUser = new CommandUser(&quot;张三&quot;);</span><br><span class="line">        String name = commandUser.execute();</span><br><span class="line">        LOGGER.info(&quot;name=[&#123;&#125;]&quot;, name);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/7/30/164e8a5a8813116f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<blockquote>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>
<p>通过刚才的构造函数也能证明：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/7/30/164e8a5a93d4f1f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>还要注意的一点是：</p>
<blockquote>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 <code>This instance can only be executed once. Please instantiate a new instance.</code> 异常。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>
<p>文末的 hystrix 源码：</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FcrossoverJie%2FJava-Interview%2Ftree%2Fmaster%2Fsrc%2Fmain%2Fjava%2Fcom%2Fcrossoverjie%2Fhystrix" target="_blank" rel="noopener">github.com/crossoverJi…</a></p>
<p>最后插播个小广告：</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FcrossoverJie%2FJava-Interview" target="_blank" rel="noopener">Java-Interview</a> 截止目前将近 8K star</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2018-08-02T10:29:09.000Z" itemprop="dateUpdated">2018-08-02 18:29:09</time>
</span><br>


        
        <a href="/2018/08/02/Java/concurrent/线程池了解/" target="_blank" rel="external">http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/</a>
        
    </div>
    
    <footer>
        <a href="http://io.stelawliet.top">
            <img src="/img/avatar.jpg" alt="Stelawliet">
            Stelawliet
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/">tcp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/掘金/">掘金</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/摘抄/">摘抄</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/&title=《tcp握手挥手分析@github》 — stelawliet&pic=http://io.stelawliet.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/&title=《tcp握手挥手分析@github》 — stelawliet&source=sky" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《tcp握手挥手分析@github》 — stelawliet&url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/&via=http://io.stelawliet.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/08/02/Java/spring/annotation/bean生命周期测试/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">bean生命周期测试</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/08/02/Linux/net/计算机网络面试/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">tcp握手挥手分析@github</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "yg0YOBlsgCru0mqR8zfr7Xsm-gzGzoHsz",
            appKey: "QDgspYKufF8K1YCR46v7udft",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>このブログの内容物は<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Stelawliet &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/&title=《tcp握手挥手分析@github》 — stelawliet&pic=http://io.stelawliet.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/&title=《tcp握手挥手分析@github》 — stelawliet&source=sky" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《tcp握手挥手分析@github》 — stelawliet&url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/&via=http://io.stelawliet.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://io.stelawliet.top/2018/08/02/Java/concurrent/线程池了解/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACrElEQVR42u3aS24cMQwFQN//0snGu6Bn3iOlzCyqV4bRH5YMSDTJn5/4+vPy+vfO/Nnk/qc3H7vw8PDwLoT+FMoTLAkxeX9y/+vFwsPDw7vHS8Jtt/6csVmmNxY8PDy8L+AlyE3osyXGw8PD+37ePpl+/d08HcfDw8P7FK9Ni/MD44nUlmiv11rw8PDwYl7eRfqen6/09/Dw8PDWXfW8GTYrTCSljVmcv8/i4eHhXeC16Ww7UJUn0zmvjhMPDw/vKG+26beF11nx4kC5BA8PD+8CLwlxU7Y4tRxJev0z+yQeHh7eiPf61s0HTo1hJel40d/Dw8PDW/D2g01JEWGWIs/AB6YV8PDw8IIsN9/6kzvzJciLwrM48fDw8O7x8gLrbGvOl2OWUhfHAx4eHt6al6e8edCzkanNEMPjO/Hw8PCu8ZLkdbZ9b9pp+RI8/gYPDw/vAq/FtGXcWbjtoNWbd+Lh4eEd5bVFhDaI/LA5NcpQzH/h4eHhjXj7EsOqWFB+pT3A8PDw8G7w8iDyY2B/VLTNucd34uHh4V3g7QcI2rGqWYLewvDw8PDu8fal27zx36bUbdssqrXg4eHhrXmbBtXsAGiLs+2h8uYviYeHh3eN1z7cHgntMZAPe+Hh4eH9T177on359WO1Fjw8PLw1r219zUq3s2NmcyDh4eHh3ea1bfhkU24Lsm26nPxh8PDw8O7x8k3/NaPd1vME+kDrCw8PD2/NOzVmuoG1peT8Hjw8PLwbvPxqi6ot++yAV33h4eHhlbz8MNg8O8PnHbzHaPHw8PCu8WadoysJ7uJke1OlxsPDw/sQr2XMih2vIywKGXh4eHhfzMtbZXnobWJdnDB4eHh4a95sOCAfRGjBs6LGm6ErPDw8vEO89p/8fdE2L2ScKm3g4eHhHeL9BW+gAycffR18AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'sky';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
