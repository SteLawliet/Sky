<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>No title | stelawliet | 迁移整理中...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="附录：配置纲要Properties   名称 默认 描述     encrypt.fail-on-error true 标记说，如果存在加密或解密错误，进程将失败。   encrypt.key  对称密钥。作为一个更强大的替代方案，考虑使用密钥库。   encrypt.key-store.alias  商店中的钥匙别名   encrypt.key-store.location  密钥存储文件的位置">
<meta name="keywords" content="blog">
<meta property="og:type" content="article">
<meta property="og:title" content="No title">
<meta property="og:url" content="http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/index.html">
<meta property="og:site_name" content="stelawliet">
<meta property="og:description" content="附录：配置纲要Properties   名称 默认 描述     encrypt.fail-on-error true 标记说，如果存在加密或解密错误，进程将失败。   encrypt.key  对称密钥。作为一个更强大的替代方案，考虑使用密钥库。   encrypt.key-store.alias  商店中的钥匙别名   encrypt.key-store.location  密钥存储文件的位置">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-12T01:27:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="No title">
<meta name="twitter:description" content="附录：配置纲要Properties   名称 默认 描述     encrypt.fail-on-error true 标记说，如果存在加密或解密错误，进程将失败。   encrypt.key  对称密钥。作为一个更强大的替代方案，考虑使用密钥库。   encrypt.key-store.alias  商店中的钥匙别名   encrypt.key-store.location  密钥存储文件的位置">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Stelawliet</h5>
          <a href="mailto:Stelawliet@gmail.com" title="Stelawliet@gmail.com" class="mail">Stelawliet@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Stelawliet" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Stelawliet" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                twitter
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Stelawliet"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis"></div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title"></h1>
        <h5 class="subtitle">
            
                <time datetime="2018-09-12T01:26:35.000Z" itemprop="datePublished" class="page-time">
  2018-09-12
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#附录：配置纲要Properties"><span class="post-toc-number">1.</span> <span class="post-toc-text">附录：配置纲要Properties</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Java/spring/cloud/properties"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title"></h1>
        <div class="post-meta">
            <time class="post-time" title="2018-09-12 09:26:35" datetime="2018-09-12T01:26:35.000Z"  itemprop="datePublished">2018-09-12</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="附录：配置纲要Properties"><a href="#附录：配置纲要Properties" class="headerlink" title="附录：配置纲要Properties"></a>附录：配置纲要Properties</h1><table>
<thead>
<tr>
<th>名称</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>encrypt.fail-on-error</td>
<td>true</td>
<td>标记说，如果存在加密或解密错误，进程将失败。</td>
</tr>
<tr>
<td>encrypt.key</td>
<td></td>
<td>对称密钥。作为一个更强大的替代方案，考虑使用密钥库。</td>
</tr>
<tr>
<td>encrypt.key-store.alias</td>
<td></td>
<td>商店中的钥匙别名</td>
</tr>
<tr>
<td>encrypt.key-store.location</td>
<td></td>
<td>密钥存储文件的位置，例如classpath：/keystore.jks。</td>
</tr>
<tr>
<td>encrypt.key-store.password</td>
<td></td>
<td>锁定密钥库的密码。</td>
</tr>
<tr>
<td>encrypt.key-store.secret</td>
<td></td>
<td>秘密保护密钥（默认为密码相同）。</td>
</tr>
<tr>
<td>encrypt.rsa.algorithm</td>
<td></td>
<td>使用RSA算法（DEFAULT或OEAP）。一旦设置不改变它（或现有的密码将不可解密）。</td>
</tr>
<tr>
<td>encrypt.rsa.salt</td>
<td>deadbeef</td>
<td>Salt用于加密密文的随机秘密。一旦设置不改变它（或现有的密码将不可解密）。</td>
</tr>
<tr>
<td>encrypt.rsa.strong</td>
<td>false</td>
<td>标志表示应该在内部使用“强”AES加密。如果为真，则将GCM算法应用于AES加密字节。默认值为false（在这种情况下使用“标准”CBC代替）。一旦设置不改变它（或现有的密码将不可解密）。</td>
</tr>
<tr>
<td>endpoints.bus.enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.bus.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.bus.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.consul.enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.consul.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.consul.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.env.post.enabled</td>
<td>true</td>
<td>通过POST将环境更改为/ env。</td>
</tr>
<tr>
<td>endpoints.features.enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.features.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.features.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.pause.enabled</td>
<td>true</td>
<td>启用/暂停端点（发送Lifecycle.stop（））。</td>
</tr>
<tr>
<td>endpoints.pause.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.pause.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.refresh.enabled</td>
<td>true</td>
<td>启用/ refresh端点刷新配置并重新初始化刷新作用域bean。</td>
</tr>
<tr>
<td>endpoints.refresh.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.refresh.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.enabled</td>
<td>true</td>
<td>启用/ restart端点重新启动应用程序上下文。</td>
</tr>
<tr>
<td>endpoints.restart.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.pause-endpoint.enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.pause-endpoint.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.pause-endpoint.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.resume-endpoint.enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.resume-endpoint.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.resume-endpoint.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.restart.timeout</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>endpoints.resume.enabled</td>
<td>true</td>
<td>启用/ resume端点（发送Lifecycle.start（））。</td>
</tr>
<tr>
<td>endpoints.resume.id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.resume.sensitive</td>
<td></td>
<td></td>
</tr>
<tr>
<td>endpoints.zookeeper.enabled</td>
<td>true</td>
<td>启用/ zookeeper端点来检查zookeeper的状态。</td>
</tr>
<tr>
<td>eureka.client.allow-redirects</td>
<td>false</td>
<td>指示服务器是否可以将客户端请求重定向到备份服务器/集群。如果设置为false，服务器将直接处理请求，如果设置为true，则可能会向客户端发送HTTP重定向，并具有新的服务器位置。</td>
</tr>
<tr>
<td>eureka.client.availability-zones</td>
<td></td>
<td>获取此实例所在区域的可用性区域列表（用于AWS数据中心）。更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效。</td>
</tr>
<tr>
<td>eureka.client.backup-registry-impl</td>
<td></td>
<td>获取执行BackupRegistry的实现的名称，以便仅在eureka客户端启动时首次将注册表信息作为回退选项提取。对于需要额外的弹性的注册表信息的应用程序可能需要这一点，而无法运行它们。</td>
</tr>
<tr>
<td>eureka.client.cache-refresh-executor-exponential-back-off-bound</td>
<td>10</td>
<td>缓存刷新执行者指数退出相关属性。在发生超时序列的情况下，它是重试延迟的最大乘数值。</td>
</tr>
<tr>
<td>eureka.client.cache-refresh-executor-thread-pool-size</td>
<td>2</td>
<td>cacheRefreshExecutor初始化的线程池大小</td>
</tr>
<tr>
<td>eureka.client.client-data-accept</td>
<td></td>
<td>EurekaAccept客户端数据接受名称</td>
</tr>
<tr>
<td>eureka.client.decoder-name</td>
<td></td>
<td>这是一个瞬态配置，一旦最新的编解码器稳定，可以删除（因为只有一个）</td>
</tr>
<tr>
<td>eureka.client.disable-delta</td>
<td>false</td>
<td>指示eureka客户端是否应该禁用提取delta，而应该诉诸于获取完整的注册表信息。请注意，增量获取可以极大地减少流量，因为尤利卡服务器的更改速率通常远低于提取速率。更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效</td>
</tr>
<tr>
<td>eureka.client.dollar-replacement</td>
<td>_-</td>
<td>在eureka服务器的序列化/反序列化信息期间，获取Dollar符号<code> $ &lt;/ code&gt;的替换字符串。</code></td>
</tr>
<tr>
<td>eureka.client.enabled</td>
<td>true</td>
<td>标记以指示启用Eureka客户端。</td>
</tr>
<tr>
<td>eureka.client.encoder-name</td>
<td></td>
<td>这是一个瞬态配置，一旦最新的编解码器稳定，可以删除（因为只有一个）</td>
</tr>
<tr>
<td>eureka.client.escape-char-replacement</td>
<td>__</td>
<td>在eureka服务器的序列化/反序列化信息期间获取下划线符号<code> _ &lt;/ code&gt;的替换字符串。</code></td>
</tr>
<tr>
<td>eureka.client.eureka-connection-idle-timeout-seconds</td>
<td>30</td>
<td>表示到eureka服务器的HTTP连接可以在关闭之前保持空闲状态的时间（以秒为单位）。在AWS环境中，建议值为30秒或更短，因为防火墙在几分钟内清除连接信息，将连接挂在空中</td>
</tr>
<tr>
<td>eureka.client.eureka-server-connect-timeout-seconds</td>
<td>5</td>
<td>指示在连接到eureka服务器需要超时之前等待（以秒为单位）的时间。请注意，客户端中的连接由org.apache.http.client.HttpClient汇集，此设置会影响实际的连接创建以及从池中获取连接的等待时间。</td>
</tr>
<tr>
<td>eureka.client.eureka-server-d-n-s-name</td>
<td></td>
<td>获取要查询的DNS名称以获取eureka服务器的列表。如果合同通过实现serviceUrls返回服务URL，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。更改在运行时有效。</td>
</tr>
<tr>
<td>eureka.client.eureka-server-port</td>
<td></td>
<td>获取用于构建服务url的端口，以在eureka服务器列表来自DNS时联系eureka服务器。如果合同返回服务url eurekaServerServiceUrls（String），则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。更改在运行时有效。</td>
</tr>
<tr>
<td>eureka.client.eureka-server-read-timeout-seconds</td>
<td>8</td>
<td>指示从eureka服务器读取之前需要等待（秒）多久才能超时。</td>
</tr>
<tr>
<td>eureka.client.eureka-server-total-connections</td>
<td>200</td>
<td>获取从eureka客户端到所有eureka服务器允许的总连接数。</td>
</tr>
<tr>
<td>eureka.client.eureka-server-total-connections-per-host</td>
<td>50</td>
<td>获取从eureka客户端到eureka服务器主机允许的总连接数。</td>
</tr>
<tr>
<td>eureka.client.eureka-server-u-r-l-context</td>
<td></td>
<td>获取用于构建服务网址的URL上下文，以便在eureka服务器列表来自DNS时联系eureka服务器。如果合同从eurekaServerServiceUrls返回服务网址，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。更改在运行时有效。</td>
</tr>
<tr>
<td>eureka.client.eureka-service-url-poll-interval-seconds</td>
<td>0</td>
<td>表示轮询对eureka服务器信息进行更改的频率（以秒为单位）。可以添加或删除Eureka服务器，此设置控制eureka客户端应该知道的时间。</td>
</tr>
<tr>
<td>eureka.client.fetch-registry</td>
<td>true</td>
<td>指示该客户端是否应从eureka服务器获取eureka注册表信息。</td>
</tr>
<tr>
<td>eureka.client.fetch-remote-regions-registry</td>
<td></td>
<td>逗号分隔将获取eureka注册表信息的区域列表。必须为availabilityZones返回的每个区域定义可用性区域。否则，将导致发现客户端启动失败。</td>
</tr>
<tr>
<td>eureka.client.filter-only-up-instances</td>
<td>true</td>
<td>指示是否在仅具有InstanceStatus UP状态的实例的过滤应用程序之后获取应用程序。</td>
</tr>
<tr>
<td>eureka.client.g-zip-content</td>
<td>true</td>
<td>指示从服务器支持时，是否必须压缩从eureka服务器提取的内容。来自eureka服务器的注册表信息被压缩以获得最佳的网络流量。</td>
</tr>
<tr>
<td>eureka.client.heartbeat-executor-exponential-back-off-bound</td>
<td>10</td>
<td>心跳执行者指数回撤相关财产。在发生超时序列的情况下，它是重试延迟的最大乘数值。</td>
</tr>
<tr>
<td>eureka.client.heartbeat-executor-thread-pool-size</td>
<td>2</td>
<td>heartbeat执行器初始化的线程池大小</td>
</tr>
<tr>
<td>eureka.client.initial-instance-info-replication-interval-seconds</td>
<td>40</td>
<td>指示将实例信息复制到eureka服务器的开始时间（以秒为单位）</td>
</tr>
<tr>
<td>eureka.client.instance-info-replication-interval-seconds</td>
<td>30</td>
<td>指示复制要复制到eureka服务器的实例更改的频率（以秒为单位）。</td>
</tr>
<tr>
<td>eureka.client.log-delta-diff</td>
<td>false</td>
<td>指示在注册表信息方面是否记录eureka服务器和eureka客户端之间的差异。Eureka客户端尝试仅从欧莱雅服务器检索增量更改以最小化网络流量。收到三角形后，eureka客户端将从服务器的信息进行协调，以验证它是否已经没有漏掉一些信息。当客户端发生网络问题与服务器通信时，可能会发生调解失败。如果对帐失败，eureka客户端将获得完整的注册表信息。在获取完整的注册表信息的同时，eureka客户端可以记录客户端和服务器之间的差异，并且此设置控制它。更改在运行时在registryFetchIntervalSecondsr指定的下一个注册表提取周期中有效</td>
</tr>
<tr>
<td>eureka.client.on-demand-update-status-change</td>
<td>true</td>
<td>如果设置为true，则通过ApplicationInfoManager进行的本地状态更新将触发对远程eureka服务器的按需（但限速）注册/更新</td>
</tr>
<tr>
<td>eureka.client.prefer-same-zone-eureka</td>
<td>true</td>
<td>指示此实例是否应尝试在同一区域中使用尤里卡服务器延迟和/或其他原因。理想情况下，eureka客户端配置为与同一区域中的服务器通信更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效</td>
</tr>
<tr>
<td>eureka.client.property-resolver</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.client.proxy-host</td>
<td></td>
<td>获取代理主机到eureka服务器（如果有的话）。</td>
</tr>
<tr>
<td>eureka.client.proxy-password</td>
<td></td>
<td>获取代理密码（如果有）。</td>
</tr>
<tr>
<td>eureka.client.proxy-port</td>
<td></td>
<td>获取代理端口到eureka服务器（如果有的话）。</td>
</tr>
<tr>
<td>eureka.client.proxy-user-name</td>
<td></td>
<td>获取代理用户名（如果有）。</td>
</tr>
<tr>
<td>eureka.client.region</td>
<td>us-east-1</td>
<td>获取此实例所在的区域（用于AWS数据中心）。</td>
</tr>
<tr>
<td>eureka.client.register-with-eureka</td>
<td>true</td>
<td>指示此实例是否应将其信息注册到eureka服务器以供其他人发现。在某些情况下，您不希望发现实例，而您只想发现其他实例。</td>
</tr>
<tr>
<td>eureka.client.registry-fetch-interval-seconds</td>
<td>30</td>
<td>指示从eureka服务器获取注册表信息的频率（以秒为单位）。</td>
</tr>
<tr>
<td>eureka.client.registry-refresh-single-vip-address</td>
<td></td>
<td>指示客户端是否只对单个VIP的注册表信息感兴趣。</td>
</tr>
<tr>
<td>eureka.client.service-url</td>
<td></td>
<td>可用性区域映射到与eureka服务器通信的完全限定URL的列表。每个值可以是单个URL或逗号分隔的替代位置列表。通常，尤里卡服务器URL携带协议，主机，端口，上下文和版本信息（如果有的话）。示例：<a href="http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/" target="_blank" rel="noopener">http</a> : <a href="http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/" target="_blank" rel="noopener">//ec2-256-156-243-129.compute-1.amazonaws.com</a> : <a href="http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/" target="_blank" rel="noopener">7001/eureka/</a>更改在运行时在eurekaServiceUrlPollIntervalSeconds指定的下一个服务网址刷新周期中有效。</td>
</tr>
<tr>
<td>eureka.client.transport</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.client.use-dns-for-fetching-service-urls</td>
<td>false</td>
<td>指示eureka客户端是否应该使用DNS机制来获取要与之通信的eureka服务器列表。当DNS名称更新为具有其他服务器时，该信息将在eureka客户端轮询该eurkaServiceUrlPollIntervalSeconds中指定的信息之后立即使用。或者，服务urls可以返回serviceUrls，但用户应该实现自己的机制来返回更新的列表，以防发生更改。更改在运行时有效。</td>
</tr>
<tr>
<td>eureka.dashboard.enabled</td>
<td>true</td>
<td>标志以启用Eureka仪表板。默认值为true。</td>
</tr>
<tr>
<td>eureka.dashboard.path</td>
<td>/</td>
<td>到Eureka仪表板（相对于servlet路径）的路径。默认为“/”。</td>
</tr>
<tr>
<td>eureka.instance.a-s-g-name</td>
<td></td>
<td>获取与此实例关联的AWS自动缩放组名称。该信息在AWS环境中专门用于在实例启动后自动将实例停止运行，并且已将其禁用。</td>
</tr>
<tr>
<td>eureka.instance.app-group-name</td>
<td></td>
<td>获取要在eureka中注册的应用程序组的名称。</td>
</tr>
<tr>
<td>eureka.instance.appname</td>
<td>unknown</td>
<td>获取要在eureka注册的应用程序的名称。</td>
</tr>
<tr>
<td>eureka.instance.data-center-info</td>
<td></td>
<td>返回此实例部署的数据中心。如果实例部署在AWS中，则此信息用于获取一些AWS特定实例信息。</td>
</tr>
<tr>
<td>eureka.instance.default-address-resolution-order</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>eureka.instance.environment</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.instance.health-check-url</td>
<td></td>
<td>获取此实例的绝对运行状况检查页面URL。如果运行状况检查页面驻留在与eureka通话的同一个实例中，用户可以提供healthCheckUrlPath，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。如果提供完整的URL，则优先。<p>它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。完整的URL应遵循格式<a href="http://%24%7Beureka.hostname%7D:7001/" target="_blank" rel="noopener">http：// $ {eureka.hostname}：7001 /</a>其中值$ {eureka.hostname}在运行时被替换。</p></td>
</tr>
<tr>
<td>eureka.instance.health-check-url-path</td>
<td>/health</td>
<td>获取此实例的相对运行状况检查URL路径。然后，健康检查页面URL由主机名和通信类型构建，如securePort和nonSecurePort中指定的安全或不安全。它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。</td>
</tr>
<tr>
<td>eureka.instance.home-page-url</td>
<td></td>
<td>获取此实例的绝对主页URL。如果主页位于与eureka通话的同一个实例中，用户可以提供homePageUrlPath，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。如果提供完整的URL，则优先。它通常用于其他服务的信息目的，以将其用作着陆页。完整的URL应遵循格式<a href="http://%24%7Beureka.hostname%7D:7001/" target="_blank" rel="noopener">http：// $ {eureka.hostname}：7001 /</a> 其中值$ {eureka.hostname}在运行时被替换。</td>
</tr>
<tr>
<td>eureka.instance.home-page-url-path</td>
<td>/</td>
<td>获取此实例的相对主页URL路径。然后，主页URL由hostName和通信类型构建 - 安全或不安全。它通常用于其他服务的信息目的，以将其用作着陆页。</td>
</tr>
<tr>
<td>eureka.instance.host-info</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.instance.hostname</td>
<td></td>
<td>如果可以在配置时确定主机名（否则将从操作系统原语中猜出）。</td>
</tr>
<tr>
<td>eureka.instance.inet-utils</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.instance.initial-status</td>
<td></td>
<td>使用rmeote Eureka服务器注册的初始状态。</td>
</tr>
<tr>
<td>eureka.instance.instance-enabled-onit</td>
<td>false</td>
<td>指示在eureka注册后，实例是否应该启用流量。有时候，应用程序可能需要做一些预处理，才能准备好交通。</td>
</tr>
<tr>
<td>eureka.instance.instance-id</td>
<td></td>
<td>获取要在eureka注册的此实例的唯一ID（在appName的范围内）。</td>
</tr>
<tr>
<td>eureka.instance.ip-address</td>
<td></td>
<td>获取实例的IPAdress。此信息仅用于学术目的，因为来自其他实例的通信主要发生在使用{@link #getHostName（boolean）}中提供的信息。</td>
</tr>
<tr>
<td>eureka.instance.lease-expiration-duration-in-seconds</td>
<td>90</td>
<td>指示eureka服务器在接收到最后一个心跳之后等待的时间（秒），然后才能从此视图中删除此实例，并禁止此实例的流量。将此值设置得太长可能意味着流量可以路由到实例，即使实例不存在。设置此值太小可能意味着，由于临时网络故障，实例可能会被取消流量。此值将设置为至少高于leaseRenewalIntervalInSeconds中指定的值。</td>
</tr>
<tr>
<td>eureka.instance.lease-renewal-interval-in-seconds</td>
<td>30</td>
<td>指示eureka客户端需要向eureka服务器发送心跳以指示它仍然存在的频率（以秒为单位）。如果在leaseExpirationDurationInSeconds中指定的时间段内未收到心跳线，则eureka服务器将从其视图中删除该实例，因此不允许此实例的流量。请注意，如果该实例实现HealthCheckCallback，然后决定使其本身不可用，则该实例仍然可能无法访问流量。</td>
</tr>
<tr>
<td>eureka.instance.metadata-map</td>
<td></td>
<td>获取与此实例关联的元数据名称/值对。该信息发送到eureka服务器，可以被其他实例使用。</td>
</tr>
<tr>
<td>eureka.instance.namespace</td>
<td>eureka</td>
<td>获取用于查找属性的命名空间。忽略Spring Cloud。</td>
</tr>
<tr>
<td>eureka.instance.non-secure-port</td>
<td>80</td>
<td>获取实例应该接收流量的非安全端口。</td>
</tr>
<tr>
<td>eureka.instance.non-secure-port-enabled</td>
<td>true</td>
<td>指示是否应启用非安全端口的流量。</td>
</tr>
<tr>
<td>eureka.instance.prefer-ip-address</td>
<td>false</td>
<td>标示说，当猜测主机名时，服务器的IP地址应该在操作系统报告的主机名中使用。</td>
</tr>
<tr>
<td>eureka.instance.registry.default-open-for-traffic-count</td>
<td>1</td>
<td>用于确定租赁期间取消的价值，独立时默认为1。应该为对等复制的eurekas设置为0</td>
</tr>
<tr>
<td>eureka.instance.registry.expected-number-of-renews-per-min</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>eureka.instance.secure-health-check-url</td>
<td></td>
<td>获取此实例的绝对安全运行状况检查页面URL。如果健康检查页面驻留在与eureka通话的同一个实例中，用户可以提供secureHealthCheckUrl，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。如果提供完整的URL，则优先。<p>它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。完整的URL应遵循格式<a href="http://%24%7Beureka.hostname%7D:7001/" target="_blank" rel="noopener">http：// $ {eureka.hostname}：7001 /</a>其中值$ {eureka.hostname}在运行时被替换。</p></td>
</tr>
<tr>
<td>eureka.instance.secure-port</td>
<td>443</td>
<td>获取实例应该接收流量的安全端口。</td>
</tr>
<tr>
<td>eureka.instance.secure-port-enabled</td>
<td>false</td>
<td>指示安全端口是否应启用流量。</td>
</tr>
<tr>
<td>eureka.instance.secure-virtual-host-name</td>
<td>unknown</td>
<td>获取为此实例定义的安全虚拟主机名。这通常是其他实例通过使用安全虚拟主机名找到此实例的方式。这与完全限定域名相似，您的服务的用户将需要找到此实例。</td>
</tr>
<tr>
<td>eureka.instance.status-page-url</td>
<td></td>
<td>获取此实例的绝对状态页面URL路径。如果状态页面驻留在与eureka通话的同一个实例中，用户可以提供statusPageUrlPath，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。如果提供完整的URL，则优先。它通常用于其他服务的信息目的，以查找此实例的状态。用户可以提供一个简单的HTML来指示实例的当前状态。</td>
</tr>
<tr>
<td>eureka.instance.status-page-url-path</td>
<td>/info</td>
<td>获取此实例的相对状态页面URL路径。然后，状态页面URL由安全端口和非安全端口中指定的hostName和通信类型构建 - 安全或不安全。它通常用于其他服务的信息目的，以查找此实例的状态。用户可以提供一个简单的HTML来指示实例的当前状态。</td>
</tr>
<tr>
<td>eureka.instance.virtual-host-name</td>
<td>unknown</td>
<td>获取为此实例定义的虚拟主机名。这通常是其他实例通过使用虚拟主机名找到此实例的方式。这与完全限定域名相似，您的服务的用户将需要找到此实例。</td>
</tr>
<tr>
<td>eureka.server.a-s-g-cache-expiry-timeout-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.a-s-g-query-timeout-ms</td>
<td>300</td>
<td></td>
</tr>
<tr>
<td>eureka.server.a-s-g-update-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.a-w-s-access-id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.a-w-s-secret-key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.batch-replication</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.binding-strategy</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.delta-retention-timer-interval-in-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.disable-delta</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.disable-delta-for-remote-regions</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.disable-transparent-fallback-to-other-region</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.e-i-p-bind-rebind-retries</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>eureka.server.e-i-p-binding-retry-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.e-i-p-binding-retry-interval-ms-when-unbound</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.enable-replicated-request-compression</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.enable-self-preservation</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>eureka.server.eviction-interval-timer-in-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.g-zip-content-from-remote-region</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>eureka.server.json-codec-name</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.list-auto-scaling-groups-role-name</td>
<td>ListAutoScalingGroups</td>
<td></td>
</tr>
<tr>
<td>eureka.server.log-identity-headers</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-elements-in-peer-replication-pool</td>
<td>10000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-elements-in-status-replication-pool</td>
<td>10000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-idle-thread-age-in-minutes-for-peer-replication</td>
<td>15</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-idle-thread-in-minutes-age-for-status-replication</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-threads-for-peer-replication</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-threads-for-status-replication</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>eureka.server.max-time-for-replication</td>
<td>30000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.min-threads-for-peer-replication</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>eureka.server.min-threads-for-status-replication</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>eureka.server.number-of-replication-retries</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-eureka-nodes-update-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-eureka-status-refresh-time-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-node-connect-timeout-ms</td>
<td>200</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-node-connection-idle-timeout-seconds</td>
<td>30</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-node-read-timeout-ms</td>
<td>200</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-node-total-connections</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.peer-node-total-connections-per-host</td>
<td>500</td>
<td></td>
</tr>
<tr>
<td>eureka.server.prime-aws-replica-connections</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>eureka.server.property-resolver</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.rate-limiter-burst-size</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>eureka.server.rate-limiter-enabled</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.rate-limiter-full-fetch-average-rate</td>
<td>100</td>
<td></td>
</tr>
<tr>
<td>eureka.server.rate-limiter-privileged-clients</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.rate-limiter-registry-fetch-average-rate</td>
<td>500</td>
<td></td>
</tr>
<tr>
<td>eureka.server.rate-limiter-throttle-standard-clients</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>eureka.server.registry-sync-retries</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.registry-sync-retry-wait-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-app-whitelist</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-connect-timeout-ms</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-connection-idle-timeout-seconds</td>
<td>30</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-fetch-thread-pool-size</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-read-timeout-ms</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-registry-fetch-interval</td>
<td>30</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-total-connections</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-total-connections-per-host</td>
<td>500</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-trust-store</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-trust-store-password</td>
<td>changeit</td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-urls</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.remote-region-urls-with-name</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eureka.server.renewal-percent-threshold</td>
<td>0.85</td>
<td></td>
</tr>
<tr>
<td>eureka.server.renewal-threshold-update-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.response-cache-auto-expiration-in-seconds</td>
<td>180</td>
<td></td>
</tr>
<tr>
<td>eureka.server.response-cache-update-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.retention-time-in-m-s-in-delta-queue</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.route53-bind-rebind-retries</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>eureka.server.route53-binding-retry-interval-ms</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.route53-domain-t-t-l</td>
<td>30</td>
<td></td>
</tr>
<tr>
<td>eureka.server.sync-when-timestamp-differs</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>eureka.server.use-read-only-response-cache</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>eureka.server.wait-time-in-ms-when-sync-empty</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>eureka.server.xml-codec-name</td>
<td></td>
<td></td>
</tr>
<tr>
<td>feign.compression.request.mime-types</td>
<td>[text/xml, application/xml, application/json]</td>
<td>支持的MIME类型列表。</td>
</tr>
<tr>
<td>feign.compression.request.min-request-size</td>
<td>2048</td>
<td>最小阈值内容大小。</td>
</tr>
<tr>
<td>health.config.enabled</td>
<td>false</td>
<td>标记以指示应安装配置服务器运行状况指示器。</td>
</tr>
<tr>
<td>health.config.time-to-live</td>
<td>0</td>
<td>生成缓存结果的时间，以毫秒为单位。默认300000（5分钟）。</td>
</tr>
<tr>
<td>hystrix.metrics.enabled</td>
<td>true</td>
<td>启用Hystrix指标轮询。默认为true。</td>
</tr>
<tr>
<td>hystrix.metrics.polling-interval-ms</td>
<td>2000</td>
<td>后续轮询度量之间的间隔。默认为2000 ms。</td>
</tr>
<tr>
<td>management.health.refresh.enabled</td>
<td>true</td>
<td>启用刷新范围的运行状况端点。</td>
</tr>
<tr>
<td>management.health.zookeeper.enabled</td>
<td>true</td>
<td>启用zookeeper的健康端点。</td>
</tr>
<tr>
<td>netflix.atlas.batch-size</td>
<td>10000</td>
<td></td>
</tr>
<tr>
<td>netflix.atlas.enabled</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>netflix.atlas.uri</td>
<td></td>
<td></td>
</tr>
<tr>
<td>netflix.metrics.servo.cache-warning-threshold</td>
<td>1000</td>
<td>当<code>ServoMonitorCache</code>达到这个大小时，会记录一个警告。如果您在RestTemplate url中使用字符串连接，这将非常有用。</td>
</tr>
<tr>
<td>netflix.metrics.servo.registry-class</td>
<td>com.netflix.servo.BasicMonitorRegistry</td>
<td>Servo使用的监视器注册表的完全限定类名。</td>
</tr>
<tr>
<td>proxy.auth.load-balanced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>proxy.auth.routes</td>
<td></td>
<td>每个路由的认证策略。</td>
</tr>
<tr>
<td>spring.cloud.bus.ack.destination-service</td>
<td></td>
<td>想要听ack的服务。默认为null（表示所有服务）。</td>
</tr>
<tr>
<td>spring.cloud.bus.ack.enabled</td>
<td>true</td>
<td>标志关闭acks（默认打开）。</td>
</tr>
<tr>
<td>spring.cloud.bus.destination</td>
<td>springCloudBus</td>
<td>名称Spring Cloud消息的流目的地。</td>
</tr>
<tr>
<td>spring.cloud.bus.enabled</td>
<td>true</td>
<td>标志表示总线已启用。</td>
</tr>
<tr>
<td>spring.cloud.bus.env.enabled</td>
<td>true</td>
<td>标志关闭环境变化事件（默认为开）。</td>
</tr>
<tr>
<td>spring.cloud.bus.refresh.enabled</td>
<td>true</td>
<td>关闭刷新事件的标志（默认为开）。</td>
</tr>
<tr>
<td>spring.cloud.bus.trace.enabled</td>
<td>false</td>
<td>打开acks跟踪的标志（默认关闭）。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.enabled</td>
<td>true</td>
<td>标记以指示启用发现。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.heartbeat-frequency</td>
<td>5000</td>
<td>心跳次数以毫秒为单位的频率。客户端将轮询该频率并广播服务ID列表。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.org</td>
<td></td>
<td>要进行身份验证的组织名称（默认为用户默认值）。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.password</td>
<td></td>
<td>用户验证和获取令牌的密码。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.space</td>
<td></td>
<td>要进行身份验证的空间名称（默认为用户默认值）。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.url</td>
<td><a href="https://api.run.pivotal.io/" target="_blank" rel="noopener">https://api.run.pivotal.io</a></td>
<td>Cloud Foundry API（云控制器）的URL。</td>
</tr>
<tr>
<td>spring.cloud.cloudfoundry.discovery.username</td>
<td></td>
<td>验证用户名（通常是电子邮件地址）。</td>
</tr>
<tr>
<td>spring.cloud.config.allow-override</td>
<td>true</td>
<td>标记以指示可以使用{@link #isSystemPropertiesOverride（）systemPropertiesOverride}。设置为false以防止用户意外更改默认值。默认值为true。</td>
</tr>
<tr>
<td>spring.cloud.config.authorization</td>
<td></td>
<td>客户端使用的授权令牌连接到服务器。</td>
</tr>
<tr>
<td>spring.cloud.config.discovery.enabled</td>
<td>false</td>
<td>标记以指示启用配置服务器发现（配置服务器URL将通过发现查找）。</td>
</tr>
<tr>
<td>spring.cloud.config.discovery.service-id</td>
<td>configserver</td>
<td>服务ID来定位配置服务器。</td>
</tr>
<tr>
<td>spring.cloud.config.enabled</td>
<td>true</td>
<td>标记说远程配置启用。默认为true;</td>
</tr>
<tr>
<td>spring.cloud.config.fail-fast</td>
<td>false</td>
<td>标记表示无法连接到服务器是致命的（默认为false）。</td>
</tr>
<tr>
<td>spring.cloud.config.label</td>
<td></td>
<td>用于拉取远程配置属性的标签名称。默认设置在服务器上（通常是基于git的服务器的“主”）。</td>
</tr>
<tr>
<td>spring.cloud.config.name</td>
<td></td>
<td>用于获取远程属性的应用程序名称。</td>
</tr>
<tr>
<td>spring.cloud.config.override-none</td>
<td>false</td>
<td>标志表示当{@link #setAllowOverride（boolean）allowOverride}为true时，外部属性应该采用最低优先级，并且不覆盖任何现有的属性源（包括本地配置文件）。默认为false。</td>
</tr>
<tr>
<td>spring.cloud.config.override-system-properties</td>
<td>true</td>
<td>标记以指示外部属性应覆盖系统属性。默认值为true。</td>
</tr>
<tr>
<td>spring.cloud.config.password</td>
<td></td>
<td>联系远程服务器时使用的密码（HTTP Basic）。</td>
</tr>
<tr>
<td>spring.cloud.config.profile</td>
<td>default</td>
<td>获取远程配置时使用的默认配置文件（逗号分隔）。默认为“默认”。</td>
</tr>
<tr>
<td>spring.cloud.config.retry.initial-interval</td>
<td>1000</td>
<td>初始重试间隔（以毫秒为单位）。</td>
</tr>
<tr>
<td>spring.cloud.config.retry.max-attempts</td>
<td>6</td>
<td>最大尝试次数。</td>
</tr>
<tr>
<td>spring.cloud.config.retry.max-interval</td>
<td>2000</td>
<td>退避的最大间隔</td>
</tr>
<tr>
<td>spring.cloud.config.retry.multiplier</td>
<td>1.1</td>
<td>下一个间隔的乘数。</td>
</tr>
<tr>
<td>spring.cloud.config.server.bootstrap</td>
<td>false</td>
<td>表示配置服务器应使用远程存储库中的属性初始化其自己的环境。默认情况下关闭，因为它会延迟启动，但在将服务器嵌入到另一个应用程序中时很有用。</td>
</tr>
<tr>
<td>spring.cloud.config.server.default-application-name</td>
<td>application</td>
<td>传入请求没有特定的默认应用程序名称。</td>
</tr>
<tr>
<td>spring.cloud.config.server.default-label</td>
<td></td>
<td>传入请求没有特定标签时的默认存储库标签。</td>
</tr>
<tr>
<td>spring.cloud.config.server.default-profile</td>
<td>default</td>
<td>传入请求没有特定的默认应用程序配置文件时。</td>
</tr>
<tr>
<td>spring.cloud.config.server.encrypt.enabled</td>
<td>true</td>
<td>在发送给客户端之前启用对环境属性的解密。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.basedir</td>
<td></td>
<td>库的本地工作副本的基本目录。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.clone-on-start</td>
<td></td>
<td>标记以表明应该在启动时克隆存储库（不是按需）。通常会导致启动速度较慢，但第一次查询更快。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.default-label</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.config.server.git.environment</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.config.server.git.force-pull</td>
<td></td>
<td>标记表示存储库应该强制拉。如果真的丢弃任何本地更改并从远程存储库获取。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.git-factory</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.config.server.git.password</td>
<td></td>
<td>使用远程存储库验证密码。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.repos</td>
<td></td>
<td>存储库标识符映射到位置和其他属性。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.search-paths</td>
<td></td>
<td>在本地工作副本中使用的搜索路径。默认情况下只搜索根。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.timeout</td>
<td></td>
<td>用于获取HTTP或SSH连接的超时（以秒为单位）（如果适用）。默认5秒。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.uri</td>
<td></td>
<td>远程存储库的URI。</td>
</tr>
<tr>
<td>spring.cloud.config.server.git.username</td>
<td></td>
<td>用于远程存储库的身份验证用户名。</td>
</tr>
<tr>
<td>spring.cloud.config.server.health.repositories</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.config.server.native.fail-on-error</td>
<td>false</td>
<td>标识以确定在解密期间如何处理异常（默认为false）。</td>
</tr>
<tr>
<td>spring.cloud.config.server.native.search-locations</td>
<td>[]</td>
<td>搜索配置文件的位置。默认与Spring Boot应用程序相同，因此[classpath：/，classpath：/ config /，file：./，file：./ config /]。</td>
</tr>
<tr>
<td>spring.cloud.config.server.native.version</td>
<td></td>
<td>为本地存储库报告的版本字符串</td>
</tr>
<tr>
<td>spring.cloud.config.server.overrides</td>
<td></td>
<td>无条件发送给所有客户的资源的额外地图。</td>
</tr>
<tr>
<td>spring.cloud.config.server.prefix</td>
<td></td>
<td>配置资源路径的前缀（默认为空）。当您不想更改上下文路径或servlet路径时嵌入其他应用程序时很有用。</td>
</tr>
<tr>
<td>spring.cloud.config.server.strip-document-from-yaml</td>
<td>true</td>
<td>标记为指示作为文本或集合（而不是映射）的YAML文档应以“本机”形式返回。</td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.basedir</td>
<td></td>
<td>库的本地工作副本的基本目录。</td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.default-label</td>
<td>trunk</td>
<td>用于环境属性请求的默认标签。</td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.environment</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.password</td>
<td></td>
<td>使用远程存储库验证密码。</td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.search-paths</td>
<td></td>
<td>在本地工作副本中使用的搜索路径。默认情况下只搜索根。</td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.uri</td>
<td></td>
<td>远程存储库的URI。</td>
</tr>
<tr>
<td>spring.cloud.config.server.svn.username</td>
<td></td>
<td>用于远程存储库的身份验证用户名。</td>
</tr>
<tr>
<td>spring.cloud.config.token</td>
<td></td>
<td>安全令牌通过到底层环境库。</td>
</tr>
<tr>
<td>spring.cloud.config.uri</td>
<td><a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888</a></td>
<td>远程服务器的URI（默认<a href="http://localhost:8888/" target="_blank" rel="noopener">http：// localhost：8888</a>）。</td>
</tr>
<tr>
<td>spring.cloud.config.username</td>
<td></td>
<td>联系远程服务器时使用的用户名（HTTP Basic）。</td>
</tr>
<tr>
<td>spring.cloud.consul.config.acl-token</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.config.data-key</td>
<td>data</td>
<td>如果格式为Format.PROPERTIES或Format.YAML，则使用以下字段来查找协调配置。</td>
</tr>
<tr>
<td>spring.cloud.consul.config.default-context</td>
<td>application</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.config.enabled</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.config.fail-fast</td>
<td>true</td>
<td>在配置查找期间抛出异常，如果为true，否则为日志警告。</td>
</tr>
<tr>
<td>spring.cloud.consul.config.format</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.config.prefix</td>
<td>config</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.config.profile-separator</td>
<td>,</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.config.watch.delay</td>
<td>1000</td>
<td>手表的固定延迟的价值在毫秒。默认为1000。</td>
</tr>
<tr>
<td>spring.cloud.consul.config.watch.enabled</td>
<td>true</td>
<td>如果手表启用 默认为true。</td>
</tr>
<tr>
<td>spring.cloud.consul.config.watch.wait-time</td>
<td>55</td>
<td>等待（或阻止）观看查询的秒数，默认为55.需要小于默认的ConsulClient（默认为60）。要增加ConsulClient超时，使用自定义的HttpClient创建一个带有自定义ConsulRawClient的ConsulClient bean。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.acl-token</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.catalog-services-watch-delay</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.catalog-services-watch-timeout</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.default-query-tag</td>
<td></td>
<td>如果没有在serverListQueryTags中列出，请在服务列表中查询标签。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.default-zone-metadata-name</td>
<td>zone</td>
<td>服务实例区域来自元数据。这允许更改元数据标签名称。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.enabled</td>
<td>true</td>
<td>是否启用服务发现？</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.fail-fast</td>
<td>true</td>
<td>在服务注册期间抛出异常，如果为true，否则，记录警告（默认为true）。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.health-check-interval</td>
<td>10s</td>
<td>执行健康检查的频率（例如10s）</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.health-check-path</td>
<td>/health</td>
<td>调用健康检查的备用服务器路径</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.health-check-timeout</td>
<td></td>
<td>健康检查超时（例如10s）</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.health-check-url</td>
<td></td>
<td>自定义健康检查网址覆盖默认值</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.heartbeat.enabled</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.heartbeat.heartbeat-interval</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.heartbeat.interval-ratio</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.heartbeat.ttl-unit</td>
<td>s</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.heartbeat.ttl-value</td>
<td>30</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.host-info</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.hostname</td>
<td></td>
<td>访问服务器时使用的主机名</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.instance-id</td>
<td></td>
<td>唯一的服务实例ID</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.instance-zone</td>
<td></td>
<td>服务实例区</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.ip-address</td>
<td></td>
<td>访问服务时使用的IP地址（还必须设置preferIpAddress才能使用）</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.lifecycle.enabled</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.management-port</td>
<td></td>
<td>端口注册管理服务（默认为管理端口）</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.management-suffix</td>
<td>management</td>
<td>注册管理服务时使用后缀</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.management-tags</td>
<td></td>
<td>注册管理服务时使用的标签</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.port</td>
<td></td>
<td>端口注册服务（默认为侦听端口）</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.prefer-agent-address</td>
<td>false</td>
<td>我们将如何确定使用地址的来源</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.prefer-ip-address</td>
<td>false</td>
<td>在注册时使用ip地址而不是主机名</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.query-passing</td>
<td>false</td>
<td>将“pass”参数添加到/ v1 / health / service / serviceName。这会将健康检查推送到服务器。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.register</td>
<td>true</td>
<td>注册为领事服务。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.register-health-check</td>
<td>true</td>
<td>注册领事健康检查。在开发服务期间有用。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.scheme</td>
<td>http</td>
<td>是否注册http或https服务</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.server-list-query-tags</td>
<td></td>
<td>服务器列表中要查询的serviceId的→标签的映射。这允许通过单个标签过滤服务。</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.service-name</td>
<td></td>
<td>服务名称</td>
</tr>
<tr>
<td>spring.cloud.consul.discovery.tags</td>
<td></td>
<td>注册服务时使用的标签</td>
</tr>
<tr>
<td>spring.cloud.consul.enabled</td>
<td>true</td>
<td>启用了spring cloud consul</td>
</tr>
<tr>
<td>spring.cloud.consul.host</td>
<td>localhost</td>
<td>Consul代理主机名。默认为“localhost”。</td>
</tr>
<tr>
<td>spring.cloud.consul.port</td>
<td>8500</td>
<td>Consul代理端口。默认为’8500’。</td>
</tr>
<tr>
<td>spring.cloud.consul.retry.initial-interval</td>
<td>1000</td>
<td>初始重试间隔（以毫秒为单位）。</td>
</tr>
<tr>
<td>spring.cloud.consul.retry.max-attempts</td>
<td>6</td>
<td>最大尝试次数。</td>
</tr>
<tr>
<td>spring.cloud.consul.retry.max-interval</td>
<td>2000</td>
<td>退避的最大间隔</td>
</tr>
<tr>
<td>spring.cloud.consul.retry.multiplier</td>
<td>1.1</td>
<td>下一个间隔的乘数。</td>
</tr>
<tr>
<td>spring.cloud.hypermedia.refresh.fixed-delay</td>
<td>5000</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.hypermedia.refresh.initial-delay</td>
<td>10000</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.inetutils.default-hostname</td>
<td>localhost</td>
<td>默认主机名。用于发生错误的情况。</td>
</tr>
<tr>
<td>spring.cloud.inetutils.default-ip-address</td>
<td>127.0.0.1</td>
<td>默认ipaddress。用于发生错误的情况。</td>
</tr>
<tr>
<td>spring.cloud.inetutils.ignored-interfaces</td>
<td></td>
<td>将被忽略的网络接口的Java正则表达式列表。</td>
</tr>
<tr>
<td>spring.cloud.inetutils.preferred-networks</td>
<td></td>
<td>将被忽略的网络地址的Java正则表达式列表。</td>
</tr>
<tr>
<td>spring.cloud.inetutils.timeout-seconds</td>
<td>1</td>
<td>计算主机名的超时秒数。</td>
</tr>
<tr>
<td>spring.cloud.inetutils.use-only-site-local-interfaces</td>
<td>false</td>
<td>仅使用与站点本地地址的接口。有关详细信息，请参阅{@link InetAddress＃isSiteLocalAddress（）}。</td>
</tr>
<tr>
<td>spring.cloud.loadbalancer.retry.enabled</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.binders</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.bindings</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.consul.binder.event-timeout</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.consumer-defaults</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.default-binder</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.dynamic-destinations</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.ignore-unknown-properties</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.instance-count</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.instance-index</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.producer-defaults</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.rabbit.binder.admin-adresses</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.rabbit.binder.compression-level</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.rabbit.binder.nodes</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.stream.rabbit.bindings</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.zookeeper.base-sleep-time-ms</td>
<td>50</td>
<td>重试之间等待的初始时间</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.block-until-connected-unit</td>
<td></td>
<td>与Zookeeper连接时阻止的时间单位</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.block-until-connected-wait</td>
<td>10</td>
<td>等待时间阻止连接到Zookeeper</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.connect-string</td>
<td>localhost:2181</td>
<td>连接字符串到Zookeeper集群</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.default-health-endpoint</td>
<td></td>
<td>将检查以验证依赖关系是否存在的默认运行状况端点</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.dependencies</td>
<td></td>
<td>将别名映射到ZookeeperDependency。从Ribbon的角度看，别名实际上是serviceID，因为Ribbon不能接受serviceID中的嵌套结构</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.dependency-configurations</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.zookeeper.dependency-names</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.enabled</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.instance-host</td>
<td></td>
<td>预定义的主机可以在Zookeeper中注册自己的服务。对应于URI规范中的{code address}。</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.instance-port</td>
<td></td>
<td>端口注册服务（默认为侦听端口）</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.metadata</td>
<td></td>
<td>获取与此实例关联的元数据名称/值对。该信息被发送到动物管理员，可以被其他实例使用。</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.register</td>
<td>true</td>
<td>在动物园管理员中注册为服务。</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.root</td>
<td>/services</td>
<td>所有实例都被注册的根Zookeeper文件夹</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.discovery.uri-spec</td>
<td>{scheme}://{address}:{port}</td>
<td>在Zookeeper服务注册期间解决的URI规范</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.enabled</td>
<td>true</td>
<td>启用了Zookeeper</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.max-retries</td>
<td>10</td>
<td>最多重试次数</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.max-sleep-ms</td>
<td>500</td>
<td>每次重试最多可以以ms为单位睡眠</td>
</tr>
<tr>
<td>spring.cloud.zookeeper.prefix</td>
<td></td>
<td>将应用于所有Zookeeper依赖关系的路径的公共前缀</td>
</tr>
<tr>
<td>spring.integration.poller.fixed-delay</td>
<td>1000</td>
<td>修复默认轮询器的延迟。</td>
</tr>
<tr>
<td>spring.integration.poller.max-messages-per-poll</td>
<td>1</td>
<td>默认轮询器每轮询的最大消息。</td>
</tr>
<tr>
<td>spring.sleuth.integration.enabled</td>
<td>true</td>
<td>启用Spring Integration侦察器。</td>
</tr>
<tr>
<td>spring.sleuth.integration.patterns</td>
<td>*</td>
<td>一组简单的模式，通道名称将与之匹配。默认值为*（所有通道）。请参阅org.springframework.util.PatternMatchUtils.simpleMatch（String，String）。</td>
</tr>
<tr>
<td>spring.sleuth.keys.async.class-name-key</td>
<td>class</td>
<td>具有使用{@code @Async} 注释的方法的类的简单名称，从异步进程开始@see org.springframework.scheduling.annotation.Async</td>
</tr>
<tr>
<td>spring.sleuth.keys.async.method-name-key</td>
<td>method</td>
<td>使用{@code @Async} 注释的方法的名称@see org.springframework.scheduling.annotation.Async</td>
</tr>
<tr>
<td>spring.sleuth.keys.async.prefix</td>
<td></td>
<td>如果标题名称被添加为标签，则使用前缀。</td>
</tr>
<tr>
<td>spring.sleuth.keys.async.thread-name-key</td>
<td>thread</td>
<td>执行异步方法的线程的名称@see org.springframework.scheduling.annotation.Async</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.headers</td>
<td></td>
<td>额外的标题应该作为标签添加，如果它们存在。如果头值是多值的，则标签值将是逗号分隔的单引号列表。</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.host</td>
<td>http.host</td>
<td>URL或主机头的域部分。示例：“mybucket.s3.amazonaws.com”。用于过滤主机而不是ip地址。</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.method</td>
<td>http.method</td>
<td>HTTP方法或动词，如“GET”或“POST”。用于过滤http路由。</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.path</td>
<td>http.path</td>
<td>绝对的http路径，没有任何查询参数。示例：“/ objects / abcd-ff”。用于过滤http路由，可以与zipkin v1一起移植。在zipkin v1中，只支持等于过滤器。删除查询参数使不同URI的数量减少。例如，无论查询行中编码的签名参数如何，都可以查询相同的资源。这不会降低HTTP单路由的基数。例如，通常将路由表示为http URI模板，如“/ resource / {resource_id}”。在只有等量查询可用的系统中，如果实际请求是“/ resource / abcd-ff” ，则搜索 {@code http.uri = / resource}将不匹配。历史记录：这通常在拉链中被表示为“http.uri”，但最常见的只是一条路。</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.prefix</td>
<td>http.</td>
<td>如果标题名称被添加为标签，则使用前缀。</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.request-size</td>
<td>http.request.size</td>
<td>非空HTTP请求体的大小（以字节为单位）。防爆。”16384”<p>大上传可能会超出限制或直接影响延迟。</p></td>
</tr>
<tr>
<td>spring.sleuth.keys.http.response-size</td>
<td>http.response.size</td>
<td>非空HTTP响应体的大小（以字节为单位）。防爆。”16384”<p>大量下载可能会超出限制或直接影响延迟。</p></td>
</tr>
<tr>
<td>spring.sleuth.keys.http.status-code</td>
<td>http.status_code</td>
<td>当HTTP响应代码不在2xx范围内。防爆。“503”用于过滤错误状态。2xx范围不会被记录，因为成功代码对延迟故障排除不那么有趣。省略节省每个跨度至少20个字节。</td>
</tr>
<tr>
<td>spring.sleuth.keys.http.url</td>
<td>http.url</td>
<td>整个URL，包括方案，主机和查询参数（如果可用）。防爆。“<a href="https://mybucket.s3.amazonaws.com/objects/abcd-ff?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256...”结合{@link" target="_blank" rel="noopener">https://mybucket.s3.amazonaws.com/objects/abcd-ff?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256...”结合{@link</a> #method }，您可以了解完全限定的请求行。这是可选的，因为它可能包括私人数据或相当长的长度。</td>
</tr>
<tr>
<td>spring.sleuth.keys.hystrix.command-group</td>
<td>commandGroup</td>
<td>命令组的名称 Hystrix使用命令组密钥将诸如报告，警报，仪表板或团队/库所有权的命令分组在一起。@see com.netflix.hystrix.HystrixCommandGroupKey</td>
</tr>
<tr>
<td>spring.sleuth.keys.hystrix.command-key</td>
<td>commandKey</td>
<td>命令键的名称 描述给定命令的名称。代表用于监视，断路器，指标发布，缓存和其他此类用途的{@link com.netflix.hystrix.HystrixCommand}的关键。@see com.netflix.hystrix.HystrixCommandKey</td>
</tr>
<tr>
<td>spring.sleuth.keys.hystrix.prefix</td>
<td></td>
<td>如果标题名称被添加为标签，则使用前缀。</td>
</tr>
<tr>
<td>spring.sleuth.keys.hystrix.thread-pool-key</td>
<td>threadPoolKey</td>
<td>线程池密钥的名称。线程池密钥表示用于监视，指标发布，缓存和其他此类用途的{@link com.netflix.hystrix.HystrixThreadPool}。甲{@link com.netflix.hystrix.HystrixCommand}与单个相关的{@link com.netflix.hystrix.HystrixThreadPool}如由检索{@link com.netflix.hystrix.HystrixThreadPoolKey}注入它，或者它的默认值使用{@link com.netflix.hystrix.HystrixCommandGroupKey}创建的创建它。@see com.netflix.hystrix.HystrixThreadPoolKey</td>
</tr>
<tr>
<td>spring.sleuth.keys.message.headers</td>
<td></td>
<td>额外的标题应该作为标签添加，如果它们存在。如果头值不是String，它将使用其toString（）方法转换为String。</td>
</tr>
<tr>
<td>spring.sleuth.keys.message.payload.size</td>
<td>message/payload-size</td>
<td>估计有效载荷的大小（如果有的话）。</td>
</tr>
<tr>
<td>spring.sleuth.keys.message.payload.type</td>
<td>message/payload-type</td>
<td>有效载荷的类型。</td>
</tr>
<tr>
<td>spring.sleuth.keys.message.prefix</td>
<td>message/</td>
<td>如果标题名称被添加为标签，则使用前缀。</td>
</tr>
<tr>
<td>spring.sleuth.keys.mvc.controller-class</td>
<td>mvc.controller.class</td>
<td>小写，连字符分隔处理请求的类的名称。防爆。名为“BookController”的类将导致“book-controller”标签值。</td>
</tr>
<tr>
<td>spring.sleuth.keys.mvc.controller-method</td>
<td>mvc.controller.method</td>
<td>小写，连字符分隔处理请求的类的名称。防爆。名为“listOfBooks”的方法将导致“list-of-books”标签值。</td>
</tr>
<tr>
<td>spring.sleuth.metric.span.accepted-name</td>
<td>counter.span.accepted</td>
<td></td>
</tr>
<tr>
<td>spring.sleuth.metric.span.dropped-name</td>
<td>counter.span.dropped</td>
<td></td>
</tr>
<tr>
<td>spring.sleuth.sampler.percentage</td>
<td>0.1</td>
<td>应采样的请求百分比。例如1.0 - 100％的请求应该被抽样。精度仅为全数（即不支持0.1％的痕迹）。</td>
</tr>
<tr>
<td>spring.sleuth.trace-id128</td>
<td>false</td>
<td>如果为true，则生成128位跟踪ID，而不是64位跟踪ID。</td>
</tr>
<tr>
<td>zuul.add-host-header</td>
<td>false</td>
<td>标识以确定代理是否转发主机头。</td>
</tr>
<tr>
<td>zuul.add-proxy-headers</td>
<td>true</td>
<td>标识以确定代理是否添加X-Forwarded- *标头。</td>
</tr>
<tr>
<td>zuul.host.max-per-route-connections</td>
<td>20</td>
<td>单个路由可以使用的最大连接数。</td>
</tr>
<tr>
<td>zuul.host.max-total-connections</td>
<td>200</td>
<td>代理可以容纳到后端的总连接数。</td>
</tr>
<tr>
<td>zuul.ignore-local-service</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>zuul.ignore-security-headers</td>
<td>true</td>
<td>标记说，如果spring security在类路径上，则将SECURITY_HEADERS添加到忽略的标头。通过将ignoreSecurityHeaders设置为false，我们可以关闭此默认行为。这应该与禁用默认的spring security标头一起使用，请参见<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers</a></td>
</tr>
<tr>
<td>zuul.ignored-headers</td>
<td></td>
<td>HTTP标头的名称完全忽略（即将其从下游请求中删除，并将其从下游响应中删除）。</td>
</tr>
<tr>
<td>zuul.ignored-patterns</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zuul.ignored-services</td>
<td></td>
<td>一组服务名称不考虑代理自动。默认情况下，发现客户端中的所有服务都将被代理。</td>
</tr>
<tr>
<td>zuul.prefix</td>
<td></td>
<td>所有路由的公共前缀。</td>
</tr>
<tr>
<td>zuul.remove-semicolon-content</td>
<td>true</td>
<td>标记说，可以删除超过第一个分号的路径元素。</td>
</tr>
<tr>
<td>zuul.retryable</td>
<td></td>
<td>默认情况下是否支持重试的标志（假设路由本身支持）。</td>
</tr>
<tr>
<td>zuul.ribbon-isolation-strategy</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zuul.routes</td>
<td></td>
<td>将路线名称映射到属性。</td>
</tr>
<tr>
<td>zuul.s-e-c-u-r-i-t-y-h-e-a-d-e-r-s</td>
<td></td>
<td>一般预期由Spring安全性添加的标头，因此如果代理和后端使用Spring保护，则通常会重复。默认情况下，如果存在Spring安全性，并且ignoreSecurityHeaders = true，它们将被添加到忽略的标头。</td>
</tr>
<tr>
<td>zuul.semaphore.max-semaphores</td>
<td>100</td>
<td>Hystrix的总信号量的最大数量。</td>
</tr>
<tr>
<td>zuul.sensitive-headers</td>
<td></td>
<td>不传递到下游请求的敏感标头列表。默认为通常包含用户凭据的“安全”标题集。如果下游服务是与代理相同的系统的一部分，那么从列表中删除它们是正确的，所以他们正在共享认证数据。如果在您自己的域之外使用物理URL，那么一般来说泄漏用户凭据将是一个坏主意。</td>
</tr>
<tr>
<td>zuul.servlet-path</td>
<td>/zuul</td>
<td>安装Zuul作为servlet的路径（不是Spring MVC的一部分）。对于具有大型机构的请求，例如文件上传，servlet对于更高的内存效率更高。</td>
</tr>
<tr>
<td>zuul.ssl-hostname-validation-enabled</td>
<td>true</td>
<td>标记以说明是否应验证ssl连接的主机名。默认值为true。这只应用于测试设置！</td>
</tr>
<tr>
<td>zuul.strip-prefix</td>
<td>true</td>
<td>在转发之前标记是否从路径中删除前缀。</td>
</tr>
<tr>
<td>zuul.trace-request-body</td>
<td>true</td>
<td>标记说可以跟踪请求机构。</td>
</tr>
</tbody>
</table>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-09-12T01:27:44.000Z" itemprop="dateUpdated">2018-09-12 09:27:44</time>
</span><br>


        
        <a href="/2018/09/12/Java/spring/cloud/properties/" target="_blank" rel="external">http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/</a>
        
    </div>
    
    <footer>
        <a href="http://io.stelawliet.top">
            <img src="/img/avatar.jpg" alt="Stelawliet">
            Stelawliet
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/&title=stelawliet&pic=http://io.stelawliet.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/&title=stelawliet&source=sky" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=stelawliet&url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/&via=http://io.stelawliet.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/09/12/Java/spring/cloud/timeOut/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">cloud-timout-config@</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/09/10/Java/spring/cloud/configuration/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">configuration in cloud</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "yg0YOBlsgCru0mqR8zfr7Xsm-gzGzoHsz",
            appKey: "QDgspYKufF8K1YCR46v7udft",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Stelawliet &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/&title=《No title》 — stelawliet&pic=http://io.stelawliet.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/&title=《No title》 — stelawliet&source=sky" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《No title》 — stelawliet&url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/&via=http://io.stelawliet.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://io.stelawliet.top/2018/09/12/Java/spring/cloud/properties/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3aQW7bQAwFUN//0i3QVYBU8v+kxsniaWU4lTRvCgxpkq9XfP35d33//PWbr9f37++fc3XX/Xsfu/Dw8PBGS7+6kkdfge+/ma0qXzMeHh7eaV4SDHJGsk3J4pJA8saCh4eH96O8dguScHJ5oK/Xg4eHh/cbeElq+1QCjYeHh/f7ee2P/9kWtLCP1lrw8PDwYt6mAfZTnz/U38PDw8Mru+rtoRwluOXQwObCw8PDO8Fr2/yzMsQmLZ6Nc9VzDXh4eHiTbtRrc+i35YYEkGx9G5Dw8PDw9rykLHt/ELchoQ0PyfMvtwkPDw/vAO/+WM9bSm1zK3lyDnuzZjw8PLxjvPq2xeDUU4WMVe8ODw8Pb1HV3BdMc1I7jjAbbsDDw8M7x7tfRF6YaMNDO0DQFpov/yfx8PDwHuXNhgPaw/3c1kT34uHh4T3Ea4/XB+ofZWEiaY9drhwPDw/vUV5bYni2ZZUvelYiwcPDwzvBm/28L378j0oPbZBYxR88PDy8ES85vvdtszaZzksbRQsNDw8Pb82bPahtj7VJ+T41f232CQ8PDy/mzUapNgn6fiygCAx4eHh4B3ib129I+1T78i48PDy8D/L2AwSztLjdyjcJPR4eHt5HeHlIyMsQs2LHrCYd1Vrw8PDwDvDyBHf2L9uhq9lUAB4eHt453rkBglkLbfaWyzIuHh4e3qO8Ni1uv0+eP9uIPFnHw8PDe5aXN6vypDl/TntvvR14eHh4h3n7hlN7oLfJcR6KVpMOeHh4eN0Z+9qkuW2yPkvi84YZHh4e3jleGwzalz1VsGjLInh4eHineU8d66uljALAmzQdDw8P70d5+RLzAJBvSr62YWDAw8PDO8xLlpiUM9ryRN02w8PDwzvGS4oR+UG/+dz+FQ8PD+/zvFkDbFbMjcoHZXp9pL+Hh4eH9//rL+kyIhbqItxlAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'sky';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
