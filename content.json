{"meta":{"title":"stelawliet","subtitle":"迁移整理中...","description":"sky","author":"Stelawliet","url":"http://io.stelawliet.top"},"pages":[{"title":"","date":"2018-06-24T14:14:16.000Z","updated":"2018-06-24T14:14:16.000Z","comments":false,"path":"categories/index.html","permalink":"http://io.stelawliet.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-06-24T13:43:54.000Z","updated":"2018-06-24T13:43:54.000Z","comments":false,"path":"tags/index.html","permalink":"http://io.stelawliet.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"boolean filter","slug":"arithmetic/boolean过滤器","date":"2018-07-05T13:16:23.000Z","updated":"2018-07-05T13:59:30.000Z","comments":true,"path":"2018/07/05/arithmetic/boolean过滤器/","link":"","permalink":"http://io.stelawliet.top/2018/07/05/arithmetic/boolean过滤器/","excerpt":"","text":"布尔过滤器可以实现存储压缩大量数据的集合结构.使用二进制位01来标记记录 哈希函数映射操作 获取的值用k个哈希函数来进行计算得到的为2进制数组的索引 在每个索引上进行1标记 2进制布尔数组操作 创建二进制的数组; int[] int为32位 ,long为64位,以32位的int举例(index为要标记的二进制数组位置 使用当前要标记的index去除以类型大小32得到int数组的位置下标 intIndex 使用当前的index去%类型大小32得到该类型二进制位的位置bitIndex 取得数组下标位置上的值int[intIndex]和(1&lt;&lt;bitIndex)来 或| 运算 1&lt;&lt;bitIndex 先标记单个int的32位中bitindex的位置为1 然后和int[intIndex]来或运算来把这个位置标记到对应int数组的值上 判断存在 contains 拿要判断的值用上面的哈希函数来取得哈希值. 对哈希值取大小为2进制位的模 然后判断取模后的值是否为1; 全为1则存在 2进制数组大小和错误率的关系123456789M = - (n*lnP)/((ln2)^2)n 为样本量p 位要设计的容错率M为二进位数组的大小当 n = 100 * 10^9 (100亿时)p 容错率 0.0001 M的大小为16G","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/categories/algorithm/"}],"tags":[{"name":"boolean过滤器","slug":"boolean过滤器","permalink":"http://io.stelawliet.top/tags/boolean过滤器/"}]},{"title":"","slug":"2018-07-05","date":"2018-07-05T11:09:33.000Z","updated":"2018-07-05T11:09:33.000Z","comments":true,"path":"2018/07/05/2018-07-05/","link":"","permalink":"http://io.stelawliet.top/2018/07/05/2018-07-05/","excerpt":"","text":"#","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/API note/Untitled","date":"2018-07-05T10:51:24.000Z","updated":"2018-07-05T10:51:24.000Z","comments":true,"path":"2018/07/05/Java/JavaSE/API note/Untitled/","link":"","permalink":"http://io.stelawliet.top/2018/07/05/Java/JavaSE/API note/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/API note/集合细节","date":"2018-07-05T09:30:36.000Z","updated":"2018-07-05T09:30:41.000Z","comments":true,"path":"2018/07/05/Java/JavaSE/API note/集合细节/","link":"","permalink":"http://io.stelawliet.top/2018/07/05/Java/JavaSE/API note/集合细节/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"wait&sleep - notify&notifyAll","slug":"Java/JavaSE/API note/线程协同","date":"2018-07-05T08:27:43.000Z","updated":"2018-07-05T13:16:29.000Z","comments":true,"path":"2018/07/05/Java/JavaSE/API note/线程协同/","link":"","permalink":"http://io.stelawliet.top/2018/07/05/Java/JavaSE/API note/线程协同/","excerpt":"","text":"线程的状态 new(新建)刚创建线程对象new Thread(),还没有调用start(); runnable(可运行)可能在运行中,也可能是即将获得cpu blocked(阻塞) 执行同步代码时锁被其他线程占用则进入blocked 执行wait方法时把锁释放了-&gt;等待notify/notifyAll唤醒 被唤醒后得到锁才能进入runnable waiting(无限等待) 执行了wait后无限等待.只有被唤醒才能进入blocked timed waiting(计时等待) 提前唤醒则进入blocked或runnable 12345678910111213141516public class TimeWait &#123; public static void main(String[] args) throws Exception &#123; Object o = new Object(); new Thread(() -&gt; &#123; synchronized (o) &#123; System.out.println(\"start wait\"); try &#123; o.wait(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"wait out\"); &#125; &#125;).start(); &#125;&#125; teminated(终止) run方法执行结束 异常抛出给JVM synchronized (Object){} 同步代码块.所有线程执行到synchronized代码块时先检查是否已经有其他线程持有此对象锁 同一个对象锁.任何时候只有最多一个线程能进入synchronized中执行代码 在成员方法上时锁的对象为this 在静态方法上时锁的对象为此类的class对象 Thread.sleep() 只释放cpu资源.计时结束后继续往下执行. object.wait() 首先Object.wait()必须在synchronized{}中调用.否则会有IllegalMonitorStateException的异常. 当执行到Object.wait()时会释放当前的锁 释放锁后无限等待直到其他线程调用相同对象锁的notify/notifyAll object.notify 唤醒任意一个相同对象锁的wait线程进入runnable状态 object.notifyAll 唤醒所有对象锁的wait线程进入blocked 其中一个抢到锁的线程进入runnable","categories":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/categories/java/"},{"name":"api","slug":"java/api","permalink":"http://io.stelawliet.top/categories/java/api/"}],"tags":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://io.stelawliet.top/tags/多线程/"}]},{"title":"","slug":"Java/JavaSE/BigDataNote","date":"2018-07-05T03:54:11.000Z","updated":"2018-07-05T03:54:24.000Z","comments":true,"path":"2018/07/05/Java/JavaSE/BigDataNote/","link":"","permalink":"http://io.stelawliet.top/2018/07/05/Java/JavaSE/BigDataNote/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BigDataNote","slug":"Java/JavaSE/Thread&Runnable","date":"2018-07-04T12:03:06.000Z","updated":"2018-07-05T04:07:32.000Z","comments":true,"path":"2018/07/04/Java/JavaSE/Thread&Runnable/","link":"","permalink":"http://io.stelawliet.top/2018/07/04/Java/JavaSE/Thread&Runnable/","excerpt":"","text":"lambda函数式接口 多泛型 1234@FunctionalInterfaceinterface Function&lt;R,T&gt;()&#123; R r = getValue(T t);&#125;","categories":[{"name":"note","slug":"note","permalink":"http://io.stelawliet.top/categories/note/"}],"tags":[]},{"title":"非递归遍历树","slug":"arithmetic/tree/栈遍历树","date":"2018-07-04T09:19:12.000Z","updated":"2018-07-04T10:43:01.000Z","comments":true,"path":"2018/07/04/arithmetic/tree/栈遍历树/","link":"","permalink":"http://io.stelawliet.top/2018/07/04/arithmetic/tree/栈遍历树/","excerpt":"","text":"使用栈来遍历preOrder(Node head) 123 1 2 5 -&gt;3 4 6 7 if head是否为空 ，否return 结束 头结点压入栈 while循环直到栈为空 pop出head 打印head if head.right是否为空。否压入栈 然后一样的操作判断head.left inOrder(Node head)123 4 2 6 -&gt;1 3 5 7 判断head是否为空 ，否return 结束 while循环到栈为空或者head为空 if head非空，head压入，然后左移 else推出栈顶为head，然后head右移 inOrder(Node head)12","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/categories/algorithm/"},{"name":"dataStructure","slug":"algorithm/dataStructure","permalink":"http://io.stelawliet.top/categories/algorithm/dataStructure/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://io.stelawliet.top/tags/tree/"},{"name":"stack","slug":"stack","permalink":"http://io.stelawliet.top/tags/stack/"}]},{"title":"牛客算法mem part II","slug":"arithmetic/algorithm-mem","date":"2018-07-03T12:57:40.000Z","updated":"2018-07-04T11:14:20.000Z","comments":true,"path":"2018/07/03/arithmetic/algorithm-mem/","link":"","permalink":"http://io.stelawliet.top/2018/07/03/arithmetic/algorithm-mem/","excerpt":"","text":"牛客算法note7月3 双栈结构实现队列 双队列实现栈 逆序对和小和 二叉树遍历 先序遍历 中序遍历 后序遍历 二叉树非递归遍历 先序遍历 中序遍历 后序遍历 二叉树序列化 反序列化","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/tags/algorithm/"},{"name":"dataStructure","slug":"dataStructure","permalink":"http://io.stelawliet.top/tags/dataStructure/"}]},{"title":"java正则表达式","slug":"Java/JavaSE/java正则表达式","date":"2018-07-02T11:12:46.000Z","updated":"2018-07-04T12:04:36.000Z","comments":true,"path":"2018/07/02/Java/JavaSE/java正则表达式/","link":"","permalink":"http://io.stelawliet.top/2018/07/02/Java/JavaSE/java正则表达式/","excerpt":"Java Pattern的使用12345678910111213141516@Test public void testRegex() &#123; //匹配的字符串对象 String str = \"123 we are the world\"; //创建正则表达式字符串 这里的\\\\b为单词边界 String regex = \"\\\\b[a-z]&#123;3&#125;\\\\b\"; //使用Pattern对象来编译正则表达式 Pattern p = Pattern.compile(regex); //使用正则表达式对象进行字符串匹配得到匹配器对象matcher Matcher matcher = p.matcher(str); //使用匹配器对象进行查找 while (matcher.find())&#123; //获取匹配到的内容 System.out.println(matcher.group()); &#125; &#125; 预定义字符类","text":"Java Pattern的使用12345678910111213141516@Test public void testRegex() &#123; //匹配的字符串对象 String str = \"123 we are the world\"; //创建正则表达式字符串 这里的\\\\b为单词边界 String regex = \"\\\\b[a-z]&#123;3&#125;\\\\b\"; //使用Pattern对象来编译正则表达式 Pattern p = Pattern.compile(regex); //使用正则表达式对象进行字符串匹配得到匹配器对象matcher Matcher matcher = p.matcher(str); //使用匹配器对象进行查找 while (matcher.find())&#123; //获取匹配到的内容 System.out.println(matcher.group()); &#125; &#125; 预定义字符类 1234567. 任何字符（与行结束符可能匹配也可能不匹配）\\d 数字：[0-9]\\D 非数字： [^0-9]\\s 空白字符：[ \\t\\n\\x0B\\f\\r]\\S 非空白字符：[^\\s]\\w 单词字符：[a-zA-Z_0-9]\\W 非单词字符：[^\\w] 语法组合12345字面值转义 \\x单字符分组 [...]范围 a-z并集 [a-e][i-u]交集 [a-z&amp;&amp;[aeiou]] 分组匹配在表达式 ((A)(B(C))) 中，存在四个这样的组： 12341 ((A)(B(C)))2 (A)3 (B(C))4 (C) java 分组用\\n来匹配指代分组中的内容 在字符串中需要转义\\\\n 分组匹配html标签 1String html_h = \"&lt;(\\\\w+)&gt;.*&lt;/\\\\1&gt;\"; \\\\w+ 非空白字符1-x.* 任意字符0-x\\\\1 捕获分组1中的匹配的内容来进行前后一致匹配 分组捕获与分内容获取示例 $n为获取分组中匹配到的内容 如下面的$1就是(.)这个分组中匹配到的内容 12345678910@Test public void test() &#123; String str = \"一一一眼眼眼眼眼万万万万万万万年年年年年年年\"; //(.)分组1号 \"\\\\1\"为匹配1号分组的内容 \"+\"为1个或多个 String regex_group = \"(.)\\\\1+\"; //\"$1\"为获取分组中匹配到的内容 str = str.replaceAll(regex_group,\"$1\"); System.out.println(\"str = \" + str); //输出一眼万年 &#125; 常用正则表达式实例","categories":[{"name":"Regex","slug":"Regex","permalink":"http://io.stelawliet.top/categories/Regex/"},{"name":"java","slug":"Regex/java","permalink":"http://io.stelawliet.top/categories/Regex/java/"},{"name":"Pattern","slug":"Regex/java/Pattern","permalink":"http://io.stelawliet.top/categories/Regex/java/Pattern/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://io.stelawliet.top/tags/正则表达式/"}]},{"title":"java基本类型与运算","slug":"Java/JavaSE/java基本数据与运算","date":"2018-07-02T07:42:23.000Z","updated":"2018-07-04T12:03:01.000Z","comments":true,"path":"2018/07/02/Java/JavaSE/java基本数据与运算/","link":"","permalink":"http://io.stelawliet.top/2018/07/02/Java/JavaSE/java基本数据与运算/","excerpt":"基本数据类型","text":"基本数据类型 数学类型 java类型 字节 位数 整数 byte 1 8 整数 short 2 16 整数 int 4 32 整数 long 8 64 浮点数 float 4 32 浮点数 double 8 64 字符 char 2 16 布尔 boolean 1 8 运算优先级 优先级 描述 运算符 1 括号 ()、[] 2 正负号 +、- 3 自增自减，非 ++、–、! 4 乘除，取余 *、/、% 5 加减 +、- 6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 7 大小关系 &gt;、&gt;=、&lt;、&lt;= 8 相等关系 ==、!= 9 按位与 &amp; 10 按位异或 ^ 11 按位或 \\ 12 逻辑与 &amp;&amp; 13 逻辑或 \\ \\ 14 条件运算 ?: 15 赋值运算 =、+=、-=、*=、/=、%= 16 位赋值运算 &amp;=、\\ =、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 异或^运算异或运算的特点。一个数被相同的数异或俩次后值不变 举例：俩数用异或来交换 12345int a =10;int b =20; //a^b^b 后依然等于aa = a ^ b;b = a ^ b;a = a ^ b; 位运算&gt;&gt; &lt;&lt;左移一位X2 右移一位/2","categories":[{"name":"Java","slug":"Java","permalink":"http://io.stelawliet.top/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/tags/java/"},{"name":"javase","slug":"javase","permalink":"http://io.stelawliet.top/tags/javase/"},{"name":"位运算","slug":"位运算","permalink":"http://io.stelawliet.top/tags/位运算/"}]},{"title":"","slug":"MD/Untitled","date":"2018-07-01T07:41:09.000Z","updated":"2018-07-01T07:42:27.000Z","comments":true,"path":"2018/07/01/MD/Untitled/","link":"","permalink":"http://io.stelawliet.top/2018/07/01/MD/Untitled/","excerpt":"","text":"ThisCrackLicenseId-{ “licenseId”:”ThisCrackLicenseId”, “licenseeName”:”idea”, “assigneeName”:””, “assigneeEmail”:”idea@163.com“, “licenseRestriction”:”For This Crack, Only Test! Please support genuine!!!”, “checkConcurrentUse”:false, “products”:[ {“code”:”II”,”paidUpTo”:”2099-12-31”}, {“code”:”DM”,”paidUpTo”:”2099-12-31”}, {“code”:”AC”,”paidUpTo”:”2099-12-31”}, {“code”:”RS0”,”paidUpTo”:”2099-12-31”}, {“code”:”WS”,”paidUpTo”:”2099-12-31”}, {“code”:”DPN”,”paidUpTo”:”2099-12-31”}, {“code”:”RC”,”paidUpTo”:”2099-12-31”}, {“code”:”PS”,”paidUpTo”:”2099-12-31”}, {“code”:”DC”,”paidUpTo”:”2099-12-31”}, {“code”:”RM”,”paidUpTo”:”2099-12-31”}, {“code”:”CL”,”paidUpTo”:”2099-12-31”}, {“code”:”PC”,”paidUpTo”:”2099-12-31”} ], “hash”:”2911276/0”, “gracePeriodDays”:7, “autoProlongated”:false}","categories":[],"tags":[]},{"title":"","slug":"welcome","date":"2018-06-24T16:15:52.000Z","updated":"2018-06-25T03:52:58.000Z","comments":true,"path":"2018/06/25/welcome/","link":"","permalink":"http://io.stelawliet.top/2018/06/25/welcome/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo配置","slug":"hexo/hexo配置","date":"2018-06-24T15:20:38.000Z","updated":"2018-06-25T03:55:32.000Z","comments":true,"path":"2018/06/24/hexo/hexo配置/","link":"","permalink":"http://io.stelawliet.top/2018/06/24/hexo/hexo配置/","excerpt":"安装主题安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo","text":"安装主题安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题执行 git branch 显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。 12345# 获取远程 card 分支，并切换$ git checkout -b card origin/card# 获取远程 master 分支，并切换$ git checkout -b master origin/master 此命令只需执行一次，之后使用 git checkout [branch] 命令在两个主题之间切换。 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 可选，不安装时会请求 jiathis Api 生成二维码。 1$ npm install hexo-helper-qrcode --save 开启标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 开启分类页仅 card theme 支持。 1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false--- 常见问题以下问题整理自 Issues 及其他渠道的用户反馈。 如果这里没有找到你面临的问题请提 Issues、邮件等任意方式反馈，非增加功能的问题一般 24 小时解决。 样式相关的问题请说明使用环境，能使我更快的定位问题。也欢迎能力者直接发 PR，感激不尽。 如何设置文章摘要在 Markdown 中加 &lt;!-- more --&gt; 文章如何添加多个标签有两种多标签格式 1tags: [a, b, c] 或 1234tags: - a - b - c 修改 brand替换 themes\\indigo\\source\\img\\brand.jpg，保持原文件名不变。 ##如何在文章中使用图标 先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt; ##个别图标无法显示 如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 ##生成站点后没有样式 安装less ##更改样式后网站没有生效 确认非缓存问题后，执行 hexo clean 再进行生成上传。 ##更改站点配色 编辑 themes\\indigo\\source\\css\\_partial\\variable.less，更改对应的颜色变量。 配色参考：Material Design Color Palette Generator 注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。 ##添加404页面 在 hexo/source 目录内新建 404.html。 设置元数据信息，如果不想套用主题布局可设置 layout 为 false。 123layout: false title: &quot;My Blog Name | 404&quot;--- ##在博客中使用 Emoji 参考 Can i use emoji in mypage? ##自行修改样式线上不生效 因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的 cdn: false。这样就不在引用 cdn 资源，使用本地资源了。 自定义页面主题 Card 分支为自定义页面提供了定制化模块支持，特此简单介绍。 创建自定义页面1hexo new page pageName 执行命令后会在你的 Hexo 根目录 source/ 目录下生成一个与你刚才输入的 pageName 一样的文件夹，里面只有一个 index.md。 页面配置123456layout: page # 必须title: pageTitle # 必须，页面名称description: 用户自定义页面功能演示 # 页面二级标题，描述性文字comments: false # 禁用评论，可选，默认开启reward: false # 禁用打赏，可选，默认开启---- 模块和内容输入自定义页面中，image、blockquote、pre 等将被赋予特殊的样式。此外，提供了 @moduleName{ ... } 格式的标记用于包裹内容，赋予样式。 演示页面 | markdown 源码 配置hexo详细文档 站点配置编辑站点配置文件，hexo/_config.yml。 启用主题1theme: indigo 基本配置为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。 1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url feed配置参考 hexo-generator-feed 1234feed: type: atom path: atom.xml limit: 0 jsonContent配置为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 主题配置编辑主题配置文件，themes/indigo/_config.yml。 左侧菜单默认配置如下 1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： 12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到 这个页面 挑选合适的图标。 rss 6.x 后移除该配置项，使用站点配置中的 feed 作为统一配置。 1rss: /atom.xml favicon站点 logo，显示在浏览器当前标签页左上角。 1favicon: /favicon.ico 头像位于左侧菜单上方 1avatar: /img/logo.jpg email头像下方 1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。 1color: &apos;#3F51B5&apos; 页面标题 (card theme)自定义归档、标签、分类页的大标题。 123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 &lt;!--more--&gt;以分割摘要与文章正文。未设置时，按 excerpt_length 设置截取。 123456# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文... mathjax开启后，使你的站点支持公式渲染，by mathjax。 请按需开启，因为此项需要加载额外的 js 文件。 1mathjax: false 分享文章分享开关，by jiathis-api。 1share: true 文章打赏默认开启 1234reward: title: 谢谢大爷~ #显示的文字 wechat: /img/wechat.jpg #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false 此外在 crad theme 中，可以通过在 markdown 头部添加 reward: false 来控制某些不想开启打赏的页面。 关闭 1reward: false 二维码请自行从微信、支付宝中下载。当两个二维码同时存在时，为保持显示效果的一致性，注意截图时的边框留白保持一致。必要时可借助PS等图片处理工具进行图片大小裁剪、压缩等。 站内搜索是否开启搜索 1search: true 布局开启后，文章页在大屏下会隐藏左侧菜单，专注阅读。 1hideMenu: true Toc开启文章内容导航。 123#toc: false #关闭toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul。 copyright (card theme)文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io。 1copyright: 这里写留言或版权声明：&lt;a href=&quot;&lt;%- url_for(page.path) %&gt;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;%- url %&gt;&lt;/a&gt; less设置 less 编译时的入口文件路径，hexo-renderer-less。 1234less: compress: true # 是否压缩css paths: - source/css/style.less 评论集成了 disqus、友言、gitment 和 valine，开启其一即可。 数据统计集成的有谷歌、腾讯、百度和 CNZZ，请填写你的站点标识。 1234google_analytics: keytajs: 站点idbaidu_tongji: 站点idcnzz: 站点id 谷歌站点验证 (card theme)1google_site_verification: false 规范网址 (card theme)让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径。使用规范网址 1canonical: http://imys.net 版权起始年份1since_year: 2006 自定义页面关于用户页面中作者相关的描述性文字，如不需要设为 false 1about: 用户页面中作者相关的描述性文字，如不需要设为 false cdn开启后将使用 unpkg cdn 最新的主题样式，如果想让你的自定义样式生效，把此项设为 false。 1cdn: true lightbox文章图片灯箱效果。 1lightbox: true ICP 备案号1ICP_license: 京ICP备1234556号-1","categories":[{"name":"blog","slug":"blog","permalink":"http://io.stelawliet.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://io.stelawliet.top/tags/hexo/"},{"name":"themes","slug":"themes","permalink":"http://io.stelawliet.top/tags/themes/"},{"name":"indigo","slug":"indigo","permalink":"http://io.stelawliet.top/tags/indigo/"}]},{"title":"hexo写作","slug":"hexo/hexo写作","date":"2018-06-24T15:20:38.000Z","updated":"2018-07-03T13:00:42.000Z","comments":true,"path":"2018/06/24/hexo/hexo写作/","link":"","permalink":"http://io.stelawliet.top/2018/06/24/hexo/hexo写作/","excerpt":"","text":"写作你可以执行下列命令来创建一篇新文章。 1$ hexo new [layout] &lt;title&gt; &lt;more!&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局. 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 草稿刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; 草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期","categories":[{"name":"blog","slug":"blog","permalink":"http://io.stelawliet.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://io.stelawliet.top/tags/hexo/"},{"name":"themes","slug":"themes","permalink":"http://io.stelawliet.top/tags/themes/"},{"name":"indigo","slug":"indigo","permalink":"http://io.stelawliet.top/tags/indigo/"}]},{"title":"hexo博客坑与技巧","slug":"hexo/hexo博客搭建","date":"2018-06-24T13:59:25.000Z","updated":"2018-07-04T11:51:50.000Z","comments":true,"path":"2018/06/24/hexo/hexo博客搭建/","link":"","permalink":"http://io.stelawliet.top/2018/06/24/hexo/hexo博客搭建/","excerpt":"","text":"文章图片预览1234&lt;img src=&quot;https://your_picture_url.jpg&quot; width=&quot;auto&quot;&gt;&lt;!--more--&gt;第1行正文内容第2行正文内容 &lt;!--more--&gt; 放的位置你自己调整就行了如果没开首页的 html 渲染的话 要把主题 config_yml 的 excerpt_render 改为 true 文件生成与部署12$ hexo generate --deploy$ hexo deploy --generate 简写 上面两个命令可以简写为$ hexo g -d$ hexo d -g","categories":[{"name":"blog","slug":"blog","permalink":"http://io.stelawliet.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://io.stelawliet.top/tags/hexo/"},{"name":"study","slug":"study","permalink":"http://io.stelawliet.top/tags/study/"}]},{"title":"Hello World","slug":"hexo/hello-world","date":"2018-06-24T13:59:25.000Z","updated":"2018-06-24T15:23:27.000Z","comments":true,"path":"2018/06/24/hexo/hello-world/","link":"","permalink":"http://io.stelawliet.top/2018/06/24/hexo/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"blog","slug":"blog","permalink":"http://io.stelawliet.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://io.stelawliet.top/tags/hexo/"},{"name":"study","slug":"study","permalink":"http://io.stelawliet.top/tags/study/"}]},{"title":"","slug":"Snake","date":"2018-06-23T04:00:48.000Z","updated":"2018-06-23T04:02:37.000Z","comments":true,"path":"2018/06/23/Snake/","link":"","permalink":"http://io.stelawliet.top/2018/06/23/Snake/","excerpt":"","text":"java swing贪吃蛇身体定位方格对象X 1234567891011121314151617181920class Point &#123; public int x; public int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public Point() &#123; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(\"&#123;\"); sb.append(\"x=\").append(x); sb.append(\", y=\").append(y); sb.append('&#125;'); return sb.toString(); &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/类加载0","date":"2018-06-22T00:58:59.000Z","updated":"2018-06-22T12:35:15.000Z","comments":true,"path":"2018/06/22/Java/JVM/类加载0/","link":"","permalink":"http://io.stelawliet.top/2018/06/22/Java/JVM/类加载0/","excerpt":"","text":"类的加载7个阶段加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载 加载加载需要完成以下工作 根据类的全限定名来读取对应的class文件的二进制字节流 在方法区中根据字节流的静态结构生成相关的运行时数据结构 在堆中生成类的java.lang.class对象，通过这个对象访问方法区中的数据 验证准备解析初始化1.","categories":[],"tags":[]},{"title":"","slug":"MD/other/报道证","date":"2018-06-21T09:49:33.000Z","updated":"2018-06-21T15:53:44.000Z","comments":true,"path":"2018/06/21/MD/other/报道证/","link":"","permalink":"http://io.stelawliet.top/2018/06/21/MD/other/报道证/","excerpt":"","text":"各位高校毕业生：为进一步做好高校毕业生实名报到登记工作，确保高校毕业生信息真实、准确、有效。根据大人社办〔2015〕8号文件要求，本着“统一领导、整合资源、方便学生、信息共享”的原则，自2015年起，应届高校毕业生统一全部回生源地公共就业人才服务机构进行实名登记和报到，由相关部门统一提供就业创业指导和服务。州级人才服务机构不办理应届高校毕业生报到登记手续。大理州人力资源和社会保障局 1.0000pt”&gt;2018年6月1日大理州人才服务和就业机构名称、地址、电话大理州人才服务中心(大理市下关镇幸福路10号)，电话：0872-2128643。大理州就业局(大理市下关镇人民南路23号)，电话：0872-2125396，2121207。大理市人才服务中心(大理市下关镇万花路下段大理政务中心一楼)，电话：0872-2251670。大理市就业局(大理市下关镇万花路下段大理政务中心三楼)，电话：0872-2121480。 |","categories":[],"tags":[]},{"title":"","slug":"MD/mem/学号","date":"2018-06-20T12:27:22.000Z","updated":"2018-06-20T12:55:19.000Z","comments":true,"path":"2018/06/20/MD/mem/学号/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/MD/mem/学号/","excerpt":"","text":"B180600698","categories":[],"tags":[]},{"title":"1【Object类、常用API】","slug":"Java/JavaSE/课件/1【Object类、常用API】","date":"2018-06-20T07:44:02.000Z","updated":"2018-07-05T07:43:17.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/1【Object类、常用API】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/1【Object类、常用API】/","excerpt":"","text":"1【Object类、常用API】主要内容 Object类 Date类 DateFormat类 Calendar类 System类 StringBuilder类 包装类 教学目标 能够说出Object类的特点 能够重写Object类的toString方法 能够重写Object类的equals方法 能够使用日期类输出当前日期 能够使用将日期格式化为字符串的方法 能够使用将字符串转换成日期的方法 能够使用System类的数组复制方法 能够使用System类获取当前毫秒时刻值 能够说出使用StringBuilder类可以解决的问题 能够使用StringBuilder进行字符串拼接操作 能够说出8种基本类型对应的包装类名称 能够说出自动装箱、自动拆箱的概念 能够将字符串转换为对应的基本类型 能够将基本类型转换为对应的字符串 第一章 Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： toString方法的自动重写 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 第二章 日期时间类2.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println(\"请输入出生日期 格式 YYYY-MM-dd\"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println(\"还没出生呢\"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 2.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(\"共耗时毫秒：\" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = \"Hello\"; s += \"World\"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWorld 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 06-StringBuilder的原理 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类5.1 概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day02【Collection、泛型】","date":"2018-06-20T07:44:02.000Z","updated":"2018-07-05T07:44:00.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day02【Collection、泛型】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day02【Collection、泛型】/","excerpt":"","text":"day02【Collection、泛型】主要内容 Collection集合 迭代器 增强for 泛型 教学目标 能够说出集合与数组的区别 说出Collection集合的常用功能 能够使用迭代器对集合进行取元素 能够说出集合的使用细节 能够使用集合存储自定义类型 能够使用foreach循环遍历集合 能够使用泛型定义集合对象 能够理解泛型上下限 能够阐述泛型通配符的作用 第一章 Collection集合1.1 集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(\"小李广\"); coll.add(\"扫地僧\"); coll.add(\"石破天\"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(\"判断 扫地僧 是否在集合中\"+coll.contains(\"扫地僧\")); //boolean remove(E e) 删除在集合中的o元素 System.out.println(\"删除石破天：\"+coll.remove(\"石破天\")); System.out.println(\"操作之后集合中元素:\"+coll); // size() 集合中有几个元素 System.out.println(\"集合中有\"+coll.size()+\"个元素\"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println(\"集合中内容为：\"+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789101112131415161718public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); for(String s :coll)&#123; System.out.println(s); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(\"abc\"); coll.add(\"itcast\"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"itcast\"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"大胡子登登\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.ArrayList;import java.util.Collections;public class Poker &#123; public static void main(String[] args) &#123; /* * 1: 准备牌操作 */ //1.1 创建牌盒 将来存储牌面的 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;(); //1.2 创建花色集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); //1.3 创建数字集合 ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); //1.4 分别给花色 以及 数字集合添加元素 colors.add(\"♥\"); colors.add(\"♦\"); colors.add(\"♠\"); colors.add(\"♣\"); for(int i = 2;i&lt;=10;i++)&#123; numbers.add(i+\"\"); &#125; numbers.add(\"J\"); numbers.add(\"Q\"); numbers.add(\"K\"); numbers.add(\"A\"); //1.5 创造牌 拼接牌操作 // 拿出每一个花色 然后跟每一个数字 进行结合 存储到牌盒中 for (String color : colors) &#123; //color每一个花色 //遍历数字集合 for(String number : numbers)&#123; //结合 String card = color+number; //存储到牌盒中 pokerBox.add(card); &#125; &#125; //1.6大王小王 pokerBox.add(\"小☺\"); pokerBox.add(\"大☠\"); // System.out.println(pokerBox); //洗牌 是不是就是将 牌盒中 牌的索引打乱 // Collections类 工具类 都是 静态方法 // shuffer方法 /* * static void shuffle(List&lt;?&gt; list) * 使用默认随机源对指定列表进行置换。 */ //2:洗牌 Collections.shuffle(pokerBox); //3 发牌 //3.1 创建 三个 玩家集合 创建一个底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); //遍历 牌盒 必须知道索引 for(int i = 0;i&lt;pokerBox.size();i++)&#123; //获取 牌面 String card = pokerBox.get(i); //留出三张底牌 存到 底牌集合中 if(i&gt;=51)&#123;//存到底牌集合中 dipai.add(card); &#125; else &#123; //玩家1 %3 ==0 if(i%3==0)&#123; player1.add(card); &#125;else if(i%3==1)&#123;//玩家2 player2.add(card); &#125;else&#123;//玩家3 player3.add(card); &#125; &#125; &#125; //看看 System.out.println(\"令狐冲：\"+player1); System.out.println(\"田伯光：\"+player2); System.out.println(\"绿竹翁：\"+player3); System.out.println(\"底牌：\"+dipai); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day06 【线程、同步】","date":"2018-06-20T07:44:02.000Z","updated":"2018-06-20T07:44:02.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day06 【线程、同步】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day06 【线程、同步】/","excerpt":"","text":"day06 【线程、同步】主要内容 线程 同步 线程状态 教学目标 能够描述Java中多线程运行原理 能够使用继承类的方式创建多线程 能够使用实现接口的方式创建多线程 能够说出实现接口方式的好处 能够解释安全问题的出现的原因 能够使用同步代码块解决线程安全问题 能够使用同步方法解决线程安全问题 能够说出线程6个状态的名称 第一章 线程1.1 多线程原理昨天的时候我们已经写过一版多线程的代码，很多同学对原理不是很清楚，那么我们今天先画个多线程执行时序图来体现一下多线程程序的执行流程。 代码如下： 自定义线程类： 12345678910111213141516171819public class MyThread extends Thread&#123; /* * 利用继承中的特点 * 将线程名称传递 进行设置 */ public MyThread(String name)&#123; super(name); &#125; /* * 重写run方法 * 定义线程要执行的代码 */ public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; //getName()方法 来自父亲 System.out.println(getName()+i); &#125; &#125;&#125; 测试类： 12345678910public class Demo &#123; public static void main(String[] args) &#123; System.out.println(\"这里是main线程\"); MyThread mt = new MyThread(\"小强\"); mt.start();//开启了一个新的线程 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"旺财:\"+i); &#125; &#125;&#125; 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 1.2 Thread类在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread类，API中该类中定义了有关线程的一些方法，具体如下： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。 1.3 创建线程方式二采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： 12345678public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+\" \"+i); &#125; &#125;&#125; 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, \"小强\"); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"旺财 \" + i); &#125; &#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 1.4 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 总结： 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法： 1234567891011121314151617181920212223public class NoNameInnerClassThread &#123; public static void main(String[] args) &#123; // new Runnable()&#123;// public void run()&#123;// for (int i = 0; i &lt; 20; i++) &#123;// System.out.println(\"张宇:\"+i);// &#125;// &#125; // &#125;; //---这个整体 相当于new MyRunnable() Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"张宇:\"+i); &#125; &#125; &#125;; new Thread(r).start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"费玉清:\"+i); &#125; &#125;&#125; 第二章 线程安全2.1 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 我们通过一个案例，演示线程的安全问题： 电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟 模拟票： 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while (true) &#123; if (ticket &gt; 0) &#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name + \"正在卖:\" + ticket--); &#125; &#125; &#125;&#125; 测试类： 123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; //创建线程任务对象 Ticket ticket = new Ticket(); //创建三个窗口对象 Thread t1 = new Thread(ticket, \"窗口1\"); Thread t2 = new Thread(ticket, \"窗口2\"); Thread t3 = new Thread(ticket, \"窗口3\"); //同时卖票 t1.start(); t2.start(); t3.start(); &#125;&#125; 结果中有一部分这样现象： 发现程序出现了两个问题： 相同的票数,比如5这张票被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 2.2 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。 根据案例简述： 1窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作： 同步代码块。 同步方法。 锁机制。 2.3 同步代码块 同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码： 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123; private int ticket = 100; Object lock = new Object(); /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; synchronized (lock) &#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket--); &#125; &#125; &#125; &#125;&#125; 当使用了同步代码块后，上述的线程的安全问题，解决了。 2.4 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 同步锁是谁? ​ 对于非static方法,同步锁就是this。 ​ 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 使用同步方法代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Ticket implements Runnable&#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; sellTicket(); &#125; &#125; /* * 锁对象 是 谁调用这个方法 就是谁 * 隐含 锁对象 就是 this * */ public synchronized void sellTicket()&#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket--); &#125; &#125;&#125; 2.5 Lock锁java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock():加同步锁。 public void unlock():释放同步锁。 使用如下： 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123; private int ticket = 100; Lock lock = new ReentrantLock(); /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; lock.lock(); if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket--); &#125; lock.unlock(); &#125; &#125;&#125; 第三章 线程状态3.1 线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。 3.2 Timed Waiting（计时等待）Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 代码： 12345678910111213141516171819public class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if ((i) % 10 == 0) &#123; System.out.println(\"-------\" + i); &#125; System.out.print(i); try &#123; Thread.sleep(1000); System.out.print(\" 线程睡眠1秒！\\n\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; new MyThread().start(); &#125;&#125; 通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠 sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。 小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。 Timed Waiting 线程状态图： 3.3 BLOCKED（锁阻塞）Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。 Blocked 线程状态图 3.4 Waiting（无限等待）Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来学习一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WaitingTest &#123; public static Object obj = new Object(); public static void main(String[] args) &#123; // 演示waiting new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; try &#123; System.out.println( Thread.currentThread().getName() +\"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象\"); obj.wait(); //无限等待 //obj.wait(5000); //计时等待, 5秒 时间到，自动醒来 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println( Thread.currentThread().getName() + \"=== 从waiting状态醒来，获取到锁对象，继续执行了\"); &#125; &#125; &#125; &#125;,\"等待线程\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123;// while (true)&#123; //每隔3秒 唤醒一次 try &#123; System.out.println( Thread.currentThread().getName() +\"----- 等待3秒钟\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj)&#123; System.out.println( Thread.currentThread().getName() +\"----- 获取到锁对象,调用notify方法，释放锁对象\"); obj.notify(); &#125; &#125;// &#125; &#125;,\"唤醒线程\").start(); &#125;&#125; 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify()方法 或 Object.notifyAll()方法。 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 Waiting 线程状态图 3.5 补充知识点到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图： 一条有意思的tips: 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。","categories":[],"tags":[]},{"title":"day02【继承、super、this、抽象类】","slug":"Java/JavaSE/课件/day02【继承、super、this、抽象类】","date":"2018-06-20T07:44:02.000Z","updated":"2018-07-05T07:43:32.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day02【继承、super、this、抽象类】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day02【继承、super、this、抽象类】/","excerpt":"","text":"day02【继承、super、this、抽象类】今日内容 三大特性——继承 方法重写 super关键字 this关键字 抽象类 教学目标 能够解释类名作为参数和返回值类型 能够写出类的继承格式 能够说出继承的特点 能够说出子类调用父类的成员特点 能够说出方法重写的概念 能够说出super可以解决的问题 描述抽象方法的概念 写出抽象类的格式 写出抽象方法的格式 能够说出父类抽象方法的存在意义 能够完成发红包案例的代码逻辑 第一章 继承1.1 概述由来多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示： 其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。 继承描述的是事物之间的所属关系，这种关系是：is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 定义 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 好处 提高代码的复用性。 类与类之间产生了关系，是多态的前提。 1.2 继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 1234567class 父类 &#123; ...&#125;class 子类 extends 父类 &#123; ...&#125; 继承演示，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/* * 定义员工类Employee，做为父类 */class Employee &#123; String name; // 定义name属性 // 定义员工的工作方法 public void work() &#123; System.out.println(\"尽心尽力地工作\"); &#125;&#125;/* * 定义讲师类Teacher 继承 员工类Employee */class Teacher extends Employee &#123; // 定义一个打印name的方法 public void printName() &#123; System.out.println(\"name=\" + name); &#125;&#125;/* * 定义测试类 */public class ExtendDemo01 &#123; public static void main(String[] args) &#123; // 创建一个讲师类对象 Teacher t = new Teacher(); // 为该员工类的name属性进行赋值 t.name = \"小明\"; // 调用该员工的printName()方法 t.printName(); // name = 小明 // 调用Teacher类继承来的work()方法 t.work(); // 尽心尽力地工作 &#125;&#125; 1.3 继承后的特点——成员变量当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？ 成员变量不重名如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。代码如下： 123456789101112131415161718192021222324252627class Fu &#123; // Fu中的成员变量。 int num = 5;&#125;class Zi extends Fu &#123; // Zi中的成员变量 int num2 = 6; // Zi中的成员方法 public void show() &#123; // 访问父类中的num， System.out.println(\"Fu num=\"+num); // 继承而来，所以直接访问。 // 访问子类中的num2 System.out.println(\"Zi num2=\"+num2); &#125;&#125;class ExtendDemo02 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125;&#125;演示结果：Fu num = 5Zi num2 = 6 成员变量重名如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下： 12345678910111213141516171819202122232425class Fu &#123; // Fu中的成员变量。 int num = 5;&#125;class Zi extends Fu &#123; // Zi中的成员变量 int num = 6; public void show() &#123; // 访问父类中的num System.out.println(\"Fu num=\" + num); // 访问子类中的num System.out.println(\"Zi num=\" + num); &#125;&#125;class ExtendsDemo03 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125;&#125;演示结果：Fu num = 6Zi num = 6 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用super 关键字，修饰父类成员变量，类似于之前学过的 this 。 使用格式： 1super.父类成员变量名 子类方法需要修改，代码如下： 12345678910111213class Zi extends Fu &#123; // Zi中的成员变量 int num = 6; public void show() &#123; //访问父类中的num System.out.println(\"Fu num=\" + super.num); //访问子类中的num System.out.println(\"Zi num=\" + this.num); &#125;&#125;演示结果：Fu num = 5Zi num = 6 小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。 1.4 继承后的特点——成员方法当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？ 成员方法不重名如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下： 123456789101112131415161718class Fu&#123; public void show()&#123; System.out.println(\"Fu类中的show方法执行\"); &#125;&#125;class Zi extends Fu&#123; public void show2()&#123; System.out.println(\"Zi类中的show2方法执行\"); &#125;&#125;public class ExtendsDemo04&#123; public static void main(String[] args) &#123; Zi z = new Zi(); //子类中没有show方法，但是可以找到父类方法去执行 z.show(); z.show2(); &#125;&#125; 成员方法重名——重写(Override)如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 代码如下： 123456789101112131415161718class Fu &#123; public void show() &#123; System.out.println(\"Fu show\"); &#125;&#125;class Zi extends Fu &#123; //子类重写了父类的show方法 public void show() &#123; System.out.println(\"Zi show\"); &#125;&#125;public class ExtendsDemo05&#123; public static void main(String[] args) &#123; Zi z = new Zi(); // 子类中有show方法，只执行重写后的show方法 z.show(); // Zi show &#125;&#125; 重写的应用子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Phone &#123; public void sendMessage()&#123; System.out.println(\"发短信\"); &#125; public void call()&#123; System.out.println(\"打电话\"); &#125; public void showNum()&#123; System.out.println(\"来电显示号码\"); &#125;&#125;//智能手机类class NewPhone extends Phone &#123; //重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能 public void showNum()&#123; //调用父类已经存在的功能使用super super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println(\"显示来电姓名\"); System.out.println(\"显示头像\"); &#125;&#125;public class ExtendsDemo06 &#123; public static void main(String[] args) &#123; // 创建子类对象 NewPhone np = new NewPhone()； // 调用父类继承而来的方法 np.call(); // 调用子类重写的方法 np.showNum(); &#125;&#125; 小贴士：这里重写时，用到super.父类成员方法，表示调用父类的成员方法。 注意事项 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、方法名和参数列表都要一模一样。 1.5 继承后的特点——构造方法当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？ 首先我们要回忆两个事情，构造方法的定义格式和作用。 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下： 123456789101112131415161718192021class Fu &#123; private int n; Fu()&#123; System.out.println(\"Fu()\"); &#125;&#125;class Zi extends Fu &#123; Zi()&#123; // super（），调用父类构造方法 super(); System.out.println(\"Zi（）\"); &#125; &#125;public class ExtendsDemo07&#123; public static void main (String args[])&#123; Zi zi = new Zi(); &#125;&#125;输出结果：Fu（）Zi（） 1.6 super和this父类空间优先于子类对象产生在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下： super和this的含义 super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。 super和this的用法 访问成员 12345this.成员变量 -- 本类的super.成员变量 -- 父类的this.成员方法名() -- 本类的 super.成员方法名() -- 父类的 用法演示，代码如下： 1234567891011121314151617181920212223242526272829class Animal &#123; public void eat() &#123; System.out.println(\"animal : eat\"); &#125;&#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"cat : eat\"); &#125; public void eatTest() &#123; this.eat(); // this 调用本类的方法 super.eat(); // super 调用父类的方法 &#125;&#125; public class ExtendsDemo08 &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Cat c = new Cat(); c.eatTest(); &#125;&#125;输出结果为：animal : eatcat : eatanimal : eat 访问构造方法 12this(...) -- 本类的构造方法super(...) -- 父类的构造方法 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 1.7 继承的特点 Java只支持单继承，不支持多继承。 123//一个类只能有一个父类，不可以有多个父类。class C extends A&#123;&#125; //okclass C extends A，B... //error Java支持多层继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 顶层父类是Object类。所有的类默认继承Object，作为父类。 子类和父类是一种相对的概念。 第二章 抽象类2.1 概述由来父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 定义 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 2.2 abstract使用格式抽象方法使用abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。 定义格式： 1修饰符 abstract 返回值类型 方法名 (参数列表)； 代码举例： 1public abstract void run()； 抽象类如果一个类包含抽象方法，那么该类必须是抽象类。 定义格式： 123abstract class 类名字 &#123; &#125; 代码举例： 123public abstract class Animal &#123; public abstract void run()；&#125; 抽象的使用继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 代码举例： 1234567891011121314151617public class Cat extends Animal &#123; public void run ()&#123; System.out.println(\"小猫在墙头走~~~\")； &#125;&#125;public class CatTest &#123; public static void main(String[] args) &#123; // 创建子类对象 Cat c = new Cat(); // 调用run方法 c.run(); &#125;&#125;输出结果：小猫在墙头走~~~ 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 2.3 注意事项关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 第三章 继承的综合案例3.1 综合案例：群主发普通红包群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则： 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。 成员领取红包后，保存到成员余额中。 请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。 3.2 案例分析根据描述分析，得出如下继承体系： 3.3 案例实现定义用户类： 123456789101112131415161718192021222324252627282930313233public class User &#123; // 成员变量 private String username; // 用户名 private double leftMoney; // 余额 // 构造方法 public User() &#123; &#125; public User(String username, double leftMoney) &#123; this.username = username; this.leftMoney = leftMoney; &#125; // get/set方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public double getLeftMoney() &#123; return leftMoney; &#125; public void setLeftMoney(double leftMoney) &#123; this.leftMoney = leftMoney; &#125; // 展示信息的方法 public void show() &#123; System.out.println(\"用户名:\"+ username +\" , 余额为:\" + leftMoney + \"元\"); &#125;&#125; 定义群主类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class QunZhu extends User &#123; // 添加构造方法 public QunZhu() &#123; &#125; public QunZhu(String username, double leftMoney) &#123; // 通过super 调用父类构造方法 super(username, leftMoney); &#125; /* 群主发红包，就是把一个整数的金额，分层若干等份。 1.获取群主余额,是否够发红包. 不能则返回null,并提示. 能则继续. 2.修改群主余额. 3.拆分红包. 3.1.如果能整除，那么就平均分。 3.2.如果不能整除，那么就把余数分给最后一份。 */ public ArrayList&lt;Double&gt; send(int money, int count) &#123; // 获取群主余额 double leftMoney = getLeftMoney(); if(money &gt; leftMoney) &#123; return null; &#125; // 修改群主余额的 setLeftMoney(leftMoney - money); // 创建保存各个红包金额的集合 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 定义循环次数,总个数-1次 int time = count - 1; // 一次计算,生成平均金额 double m = (double) money / count; // 循环分配 for (int i = 0; i &lt; time; i++) &#123; // 添加到集合中 list.add(m); // 总金额扣除已分配金额 money -= m; &#125; // 剩余的金额,为最后一个红包 list.add((double) money); System.out.println(\"普通红包金额:\" + list); // 返回集合 return list; &#125;&#125; 定义成员类： 12345678910111213141516171819public class Member extends User &#123; public Member() &#123; &#125; public Member(String username, double leftMoney) &#123; super(username, leftMoney); &#125; // 打开红包,就是从集合中,随机取出一份,保存到自己的余额中 public void openHongBao(ArrayList&lt;Double&gt; list) &#123; // 创建Random对象 Random r = new Random(); // 随机生成一个角标 int index = r.nextInt(list.size()); // 移除一个金额 Double money = list.remove(index); // 直接调用父类方法,设置到余额 setLeftMoney(getLeftMoney() + money ); &#125;&#125; 定义测试类： 1234567891011121314151617181920212223242526272829303132333435363738public class Test &#123; public static void main(String[] args) &#123; // 创建一个群主对象 QunZhu qz = new QunZhu(\"群主\", 200); // 创建一个键盘录入 Scanner sc = new Scanner(System.in); System.out.println(\"请输入金额 : \"); int money = sc.nextInt(); System.out.println(\"请输入个数 : \"); int count = sc.nextInt(); // 发送红包 ArrayList&lt;Double&gt; sendList = qz.send(money, count); // 判断, 如果余额不足 if (sendList == null) &#123; System.out.println(\"余额不足...\"); return; &#125; // 创建三个成员 Member m1 = new Member(); Member m2 = new Member(); Member m3 = new Member(); // 打开红包 m1.openHongBao(sendList); m2.openHongBao(sendList); m3.openHongBao(sendList); // 展示信息 qz.show(); m1.show(); m2.show(); m3.show(); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day04 【Map】","date":"2018-06-20T07:44:02.000Z","updated":"2018-06-20T07:44:02.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day04 【Map】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day04 【Map】/","excerpt":"","text":"day04 【Map】主要内容 Map集合 教学目标 能够说出Map集合特点 使用Map集合添加方法保存数据 使用”键找值”的方式遍历Map集合 使用”键值对”的方式遍历Map集合 能够使用HashMap存储自定义键值对的数据 能够使用HashMap编写斗地主洗牌发牌案例 第一章 Map集合1.1 概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 1.2 Map常用子类通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 1.3 Map接口中的常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map接口的方法演示 1234567891011121314151617181920public class MapDemo &#123; public static void main(String[] args) &#123; //创建 map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素到集合 map.put(\"黄晓明\", \"杨颖\"); map.put(\"文章\", \"马伊琍\"); map.put(\"邓超\", \"孙俪\"); System.out.println(map); //String remove(String key) System.out.println(map.remove(\"邓超\")); System.out.println(map); // 想要查看 黄晓明的媳妇 是谁 System.out.println(map.get(\"黄晓明\")); System.out.println(map.get(\"邓超\")); &#125;&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 1.4 Map集合遍历键找值方式键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： 1234567891011121314151617181920public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //添加元素到集合 map.put(\"胡歌\", \"霍建华\"); map.put(\"郭德纲\", \"于谦\"); map.put(\"薛之谦\", \"大张伟\"); //获取所有的键 获取键集 Set&lt;String&gt; keys = map.keySet(); // 遍历键集 得到 每一个键 for (String key : keys) &#123; //key 就是键 //获取对应值 String value = map.get(key); System.out.println(key+\"的CP是：\"+value); &#125; &#125;&#125; 遍历图解： 1.5 Entry键值对对象我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 1.6 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718192021public class MapDemo02 &#123; public static void main(String[] args) &#123; // 创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); // 添加元素到集合 map.put(\"胡歌\", \"霍建华\"); map.put(\"郭德纲\", \"于谦\"); map.put(\"薛之谦\", \"大张伟\"); // 获取 所有的 entry对象 entrySet Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); // 遍历得到每一个entry对象 for (Entry&lt;String, String&gt; entry : entrySet) &#123; // 解析 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"的CP是:\"+value); &#125; &#125;&#125; 遍历图解： tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 1.7 HashMap存储自定义类型键值练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。 注意，学生姓名相同并且年龄相同视为同一名学生。 编写学生类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 编写测试类： 12345678910111213141516171819public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(newStudent(\"lisi\",28), \"上海\"); map.put(newStudent(\"wangwu\",22), \"北京\"); map.put(newStudent(\"zhaoliu\",24), \"成都\"); map.put(newStudent(\"zhouqi\",25), \"广州\"); map.put(newStudent(\"wangwu\",22), \"南京\"); //3,取出元素。键找值方式 Set&lt;Student&gt;keySet = map.keySet(); for(Student key: keySet)&#123; Stringvalue = map.get(key); System.out.println(key.toString()+\".....\"+value); &#125; &#125;&#125; 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 1.8 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 123456789101112public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put(\"邓超\", \"孙俪\"); map.put(\"李晨\", \"范冰冰\"); map.put(\"刘德华\", \"朱丽倩\"); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + \" \" + entry.getValue()); &#125; &#125;&#125; 结果: 123邓超 孙俪李晨 范冰冰刘德华 朱丽倩 1.9 Map集合练习需求： 计算一个字符串中每个字符出现次数。 分析： 获取一个字符串对象 创建一个Map集合，键代表字符，值代表次数。 遍历字符串得到每个字符。 判断Map中是否有该键。 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。 打印最终结果 代码： 1234567891011121314151617181920212223242526272829public class MapTest &#123;public static void main(String[] args) &#123; //友情提示 System.out.println(\"请录入一个字符串:\"); String line = new Scanner(System.in).nextLine(); // 定义 每个字符出现次数的方法 findChar(line); &#125; private static void findChar(String line) &#123; //1:创建一个集合 存储 字符 以及其出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); //2:遍历字符串 for (int i = 0; i &lt; line.length(); i++) &#123; char c = line.charAt(i); //判断 该字符 是否在键集中 if (!map.containsKey(c)) &#123;//说明这个字符没有出现过 //那就是第一次 map.put(c, 1); &#125; else &#123; //先获取之前的次数 Integer count = map.get(c); //count++; //再次存入 更新 map.put(c, ++count); &#125; &#125; System.out.println(map); &#125;&#125; 第二章 补充知识点2.1 JDK9对集合添加的优化通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。 123456789public class Demo01 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); list.add(\"def\"); list.add(\"ghi\"); System.out.println(list); &#125;&#125; Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。 例子： 1234567891011public class HelloJDK9 &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str1=Set.of(\"a\",\"b\",\"c\"); //str1.add(\"c\");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 System.out.println(str1); Map&lt;String,Integer&gt; str2=Map.of(\"a\",1,\"b\",2); System.out.println(str2); List&lt;String&gt; str3=List.of(\"a\",\"b\"); System.out.println(str3); &#125; &#125; 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待； 2:返回的集合是不可变的； 2.2 Debug追踪使用IDEA的断点调试功能，查看程序的运行过程 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示 第三章 模拟斗地主洗牌发牌3.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 3.2 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 3.3 实现代码步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class Poker &#123; public static void main(String[] args) &#123; /* * 1组装54张扑克牌 */ // 1.1 创建Map集合存储 HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;(); // 1.2 创建 花色集合 与 数字集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); // 1.3 存储 花色 与数字 Collections.addAll(colors, \"♦\", \"♣\", \"♥\", \"♠\"); Collections.addAll(numbers, \"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); // 设置 存储编号变量 int count = 1; pokerMap.put(count++, \"大王\"); pokerMap.put(count++, \"小王\"); // 1.4 创建牌 存储到map集合中 for (String number : numbers) &#123; for (String color : colors) &#123; String card = color + number; pokerMap.put(count++, card); &#125; &#125; /* * 2 将54张牌顺序打乱 */ // 取出编号 集合 Set&lt;Integer&gt; numberSet = pokerMap.keySet(); // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中 ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;(); numberList.addAll(numberSet); // 打乱顺序 Collections.shuffle(numberList); // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌 // 3.1 发牌的编号 // 创建三个玩家编号集合 和一个 底牌编号集合 ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;(); // 3.2发牌的编号 for (int i = 0; i &lt; numberList.size(); i++) &#123; // 获取该编号 Integer no = numberList.get(i); // 发牌 // 留出底牌 if (i &gt;= 51) &#123; dipaiNo.add(no); &#125; else &#123; if (i % 3 == 0) &#123; noP1.add(no); &#125; else if (i % 3 == 1) &#123; noP2.add(no); &#125; else &#123; noP3.add(no); &#125; &#125; &#125; // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌 // 4.1 对手中编号进行排序 Collections.sort(noP1); Collections.sort(noP2); Collections.sort(noP3); Collections.sort(dipaiNo); // 4.2 进行牌面的转换 // 创建三个玩家牌面集合 以及底牌牌面集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); // 4.3转换 for (Integer i : noP1) &#123; // 4.4 根据编号找到 牌面 pokerMap String card = pokerMap.get(i); // 添加到对应的 牌面集合中 player1.add(card); &#125; for (Integer i : noP2) &#123; String card = pokerMap.get(i); player2.add(card); &#125; for (Integer i : noP3) &#123; String card = pokerMap.get(i); player3.add(card); &#125; for (Integer i : dipaiNo) &#123; String card = pokerMap.get(i); dipai.add(card); &#125; //4.5 查看 System.out.println(\"令狐冲：\"+player1); System.out.println(\"石破天：\"+player2); System.out.println(\"鸠摩智：\"+player3); System.out.println(\"底牌：\"+dipai); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day05 【异常、线程】","date":"2018-06-20T07:44:02.000Z","updated":"2018-06-20T07:44:02.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day05 【异常、线程】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day05 【异常、线程】/","excerpt":"","text":"day05 【异常、线程】主要内容 异常、线程 教学目标 能够辨别程序中异常和错误的区别 说出异常的分类 说出虚拟机处理异常的方式 列举出常见的三个运行期异常 能够使用try…catch关键字处理异常 能够使用throws关键字处理异常 能够自定义异常类 能够处理自定义异常类 说出进程的概念 说出线程的概念 能够理解并发与并行的区别 能够开启新线程 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会被编译器检测(不报错)。(如数学异常) ​ 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 在开发中呢也可以在catch将编译期异常转换成运行期异常处理。 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 当多异常处理时，捕获处理，前边的类不能是后边类的父类 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。 如果finally有return语句,永远返回finally中的结果,避免该情况. 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: LoginException。一个登陆异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类LoginException： 12345678910111213141516// 业务逻辑异常public class LoginException extends Exception &#123; /** * 空参构造 */ public LoginException() &#123; &#125; /** * * @param message 表示异常提示 */ public LoginException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(LoginException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new LoginException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125; 第四章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 4.1 并发与并行 并行：指两个或多个事件在同一时刻发生（同时发生）。 并发：指两个或多个事件在同一个时间段内发生。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，可以理解为一个进程便相当于一个单 CPU 操作系统，而线程便是这个系统中运行的多个任务。 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程和线程： 进程 线程 进程与线程的区别 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。 注意： 因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于 CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。 Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个线程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程。 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。 线程调度: 计算机通常只有一个CPU时,在任意时刻只能执行一条计算机指令,每一个进程只有获得CPU的使用权才能执行指令。所谓多进程并发运行,从宏观上看,其实是各个进程轮流获得CPU的使用权,分别执行各自的任务。那么,在可运行池中,会有多个线程处于就绪状态等到CPU,JVM就负责了线程的调度。JVM采用的是抢占式调度,没有采用分时调度,因此可以能造成多线程执行结果的的随机性。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main线程！\"+i); &#125; &#125;&#125; 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+\"：正在执行！\"+i); &#125; &#125;&#125; OK 相信我们都看到多线程的现象了，那么接下来几天我们就进入多线程的世界！ 那么现在有个小问题，请问植物大战僵尸游戏中，是用了多进程设计程序呢，还是多线程？","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day08【File类、递归】","date":"2018-06-20T07:44:02.000Z","updated":"2018-06-20T07:44:02.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day08【File类、递归】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day08【File类、递归】/","excerpt":"","text":"day08【File类、递归】主要内容 File类 递归 教学目标 能够说出File对象的创建方式 能够说出File类获取名称的方法名称 能够说出File类获取绝对路径的方法名称 能够说出File类获取文件大小的方法名称 能够说出File类判断是否是文件的方法名称 能够说出File类判断是否是文件夹的方法名称 能够辨别相对路径和绝对路径 能够遍历文件夹 能够解释递归的含义 能够使用递归的方式计算5的阶乘 能够说出使用递归会内存溢出隐患的原因 第一章 File类1.1 概述java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 1.2 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 1234567891011121314151617// 文件路径名String pathname = \"D:\\\\aaa.txt\";File file1 = new File(pathname); // 文件路径名String pathname2 = \"D:\\\\aaa\\\\bbb.txt\";File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = \"d:\\\\aaa\"; String child = \"bbb.txt\"; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(\"d:\\\\aaa\");String child = \"bbb.txt\";File file4 = new File(parentDir, child); 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 1.3 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： 12345678910111213141516171819202122232425public class FileGet &#123; public static void main(String[] args) &#123; File f = new File(\"d:/aaa/bbb.java\"); System.out.println(\"文件绝对路径:\"+f.getAbsolutePath()); System.out.println(\"文件构造路径:\"+f.getPath()); System.out.println(\"文件名称:\"+f.getName()); System.out.println(\"文件长度:\"+f.length()+\"字节\"); File f2 = new File(\"d:/aaa\"); System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath()); System.out.println(\"目录构造路径:\"+f2.getPath()); System.out.println(\"目录名称:\"+f2.getName()); System.out.println(\"目录长度:\"+f2.length()); &#125;&#125;输出结果：文件绝对路径:d:\\aaa\\bbb.java文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\\aaa目录构造路径:d:\\aaa目录名称:aaa目录长度:4096 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(\"D:\\\\bbb.java\"); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(\"bbb.java\"); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： 1234567891011121314151617public class FileIs &#123; public static void main(String[] args) &#123; File f = new File(\"d:\\\\aaa\\\\bbb.java\"); File f2 = new File(\"d:\\\\aaa\"); // 判断是否存在 System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists()); System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists()); // 判断是文件还是目录 System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile()); System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory()); &#125;&#125;输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 12345678910111213141516171819202122232425262728public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 File f = new File(\"aaa.txt\"); System.out.println(\"是否存在:\"+f.exists()); // false System.out.println(\"是否创建:\"+f.createNewFile()); // true System.out.println(\"是否存在:\"+f.exists()); // true // 目录的创建 File f2= new File(\"newDir\"); System.out.println(\"是否存在:\"+f2.exists());// false System.out.println(\"是否创建:\"+f2.mkdir()); // true System.out.println(\"是否存在:\"+f2.exists());// true // 创建多级目录 File f3= new File(\"newDira\\\\newDirb\"); System.out.println(f3.mkdir());// false File f4= new File(\"newDira\\\\newDirb\"); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false &#125;&#125; API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 1.4 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(\"d:\\\\java_code\"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 第二章 递归2.1 概述 递归：指在当前方法内调用自己的这种现象。 1234public static void main(String[] args) &#123; System.out.println(\"main\"); main(args);&#125; 2.2 递归累和计算1 ~ n的和分析：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。 实现代码： 123456789101112131415161718192021222324252627282930public class DiGuiDemo &#123; public static void main(String[] args) &#123; //计算1~num的和，使用递归完成 int num = 5; // 调用求和的方法 int sum = getSum(num); // 输出结果 System.out.println(sum); &#125; /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public static int getSum(int num) &#123; /* num为1时,方法返回1, 相当于是方法的出口,num总有是1的情况 */ if(num == 1)&#123; return 1; &#125; /* num不为1时,方法返回 num +(num-1)的累和 递归调用getSum方法 */ return num + getSum(num-1); &#125;&#125; 代码执行图解 小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。 2.3 递归求阶乘 阶乘：所有小于及等于该数的正整数的积。 1n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 分析：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。 1推理得出：n! = n * (n-1)! 代码实现： 1234567891011121314151617181920212223242526public class DiGuiDemo &#123; //计算n的阶乘，使用递归完成 public static void main(String[] args) &#123; int n = 3; // 调用求阶乘的方法 int value = getValue(n); // 输出结果 System.out.println(\"阶乘为:\"+ value); &#125; /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public static int getValue(int n) &#123; // 1的阶乘为1 if (n == 1) &#123; return 1; &#125; /* n不为1时,方法返回 n! = n*(n-1)! 递归调用getValue方法 */ return n * getValue(n - 1); &#125;&#125; 2.4 递归打印多级目录分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。 代码实现： 12345678910111213141516171819202122232425262728293031public class DiGuiDemo2 &#123; public static void main(String[] args) &#123; // 创建File对象 File dir = new File(\"D:\\\\aaa\"); // 调用打印目录方法 printDir(dir); &#125; public static void printDir(File dir) &#123; // 获取子文件和目录 File[] files = dir.listFiles(); // 循环打印 /* 判断: 当是文件时,打印绝对路径. 当是目录时,继续调用打印目录的方法,形成递归调用. */ for (File file : files) &#123; // 判断 if (file.isFile()) &#123; // 是文件,输出文件绝对路径 System.out.println(\"文件名:\"+ file.getAbsolutePath()); &#125; else &#123; // 是目录,输出目录绝对路径 System.out.println(\"目录:\"+file.getAbsolutePath()); // 继续遍历,调用printDir,形成递归 printDir(file); &#125; &#125; &#125;&#125; 第三章 综合案例3.1 文件搜索搜索D:\\aaa 目录中的.java 文件。 分析： 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。 代码实现： 1234567891011121314151617181920212223242526public class DiGuiDemo3 &#123; public static void main(String[] args) &#123; // 创建File对象 File dir = new File(\"D:\\\\aaa\"); // 调用打印目录方法 printDir(dir); &#125; public static void printDir(File dir) &#123; // 获取子文件和目录 File[] files = dir.listFiles(); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; // 是文件，判断文件名并输出文件绝对路径 if (file.getName().endsWith(\".java\")) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; &#125; else &#123; // 是目录，继续遍历,形成递归 printDir(file); &#125; &#125; &#125;&#125; 3.2 文件过滤器优化java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： 123456789101112131415161718192021222324public class DiGuiDemo4 &#123; public static void main(String[] args) &#123; File dir = new File(\"D:\\\\aaa\"); printDir2(dir); &#125; public static void printDir2(File dir) &#123; // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(\".java\")||pathname.isDirectory(); &#125; &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir2(file); &#125; &#125; &#125;&#125; 3.3 Lambda优化分析：FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 lambda格式： 1()-&gt;&#123; &#125; 代码实现： 123456789101112131415public static void printDir3(File dir) &#123; // lambda的改写 File[] files = dir.listFiles(f -&gt;&#123; return f.getName().endsWith(\".java\") || f.isDirectory(); &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir3(file); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day03【接口、多态】","date":"2018-06-20T07:44:02.000Z","updated":"2018-06-20T07:44:02.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day03【接口、多态】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day03【接口、多态】/","excerpt":"","text":"day03【接口、多态】今日内容 接口 三大特征——多态 引用类型转换 教学目标 写出定义接口的格式 写出实现接口的格式 说出接口中成员的特点 能够说出使用多态的前提条件 理解多态的向上转型 理解多态的向下转型 能够完成笔记本电脑案例（方法参数为接口） 第一章 接口1.1 概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 接口的使用，它不能创建对象，但是可以被实现（implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 1.2 定义格式123456public interface 接口名称 &#123; // 抽象方法 // 默认方法 // 静态方法 // 私有方法&#125; 含有抽象方法抽象方法：使用abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。 代码如下： 123public interface InterFaceName &#123; public abstract void method();&#125; 含有默认方法和静态方法默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：使用 static 修饰，供接口直接调用。 代码如下： 12345678public interface InterFaceName &#123; public default void method() &#123; // 执行语句 &#125; public static void method2() &#123; // 执行语句 &#125;&#125; 含有私有方法和私有静态方法私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。 代码如下： 12345public interface InterFaceName &#123; private void method() &#123; // 执行语句 &#125;&#125; 1.3 基本的实现实现的概述类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements关键字。 非抽象子类实现接口： 必须重写接口中所有抽象方法。 继承了接口的默认方法，即可以直接调用，也可以重写。 实现格式： 1234class 类名 implements 接口名 &#123; // 重写接口中抽象方法【必须】 // 重写接口中默认方法【可选】&#125; 抽象方法的使用必须全部实现，代码如下： 定义接口： 12345public interface LiveAble &#123; // 定义抽象方法 public abstract void eat(); public abstract void sleep();&#125; 定义实现类： 1234567891011public class Animal implements LiveAble &#123; @Override public void eat() &#123; System.out.println(\"吃东西\"); &#125; @Override public void sleep() &#123; System.out.println(\"晚上睡\"); &#125;&#125; 定义测试类： 123456789101112public class InterfaceDemo &#123; public static void main(String[] args) &#123; // 创建子类对象 Animal a = new Animal(); // 调用实现后的方法 a.eat(); a.sleep(); &#125;&#125;输出结果：吃东西晚上睡 默认方法的使用可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 继承默认方法，代码如下： 定义接口： 12345public interface LiveAble &#123; public default void fly()&#123; System.out.println(\"天上飞\"); &#125;&#125; 定义实现类： 123public class Animal implements LiveAble &#123; // 继承，什么都不用写，直接调用&#125; 定义测试类： 12345678910public class InterfaceDemo &#123; public static void main(String[] args) &#123; // 创建子类对象 Animal a = new Animal(); // 调用默认方法 a.fly(); &#125;&#125;输出结果：天上飞 重写默认方法，代码如下： 定义接口： 12345public interface LiveAble &#123; public default void fly()&#123; System.out.println(\"天上飞\"); &#125;&#125; 定义实现类： 123456public class Animal implements LiveAble &#123; @Override public void fly() &#123; System.out.println(\"自由自在的飞\"); &#125;&#125; 定义测试类： 12345678910public class InterfaceDemo &#123; public static void main(String[] args) &#123; // 创建子类对象 Animal a = new Animal(); // 调用重写方法 a.fly(); &#125;&#125;输出结果：自由自在的飞 静态方法的使用静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下： 定义接口： 12345public interface LiveAble &#123; public static void run()&#123; System.out.println(\"跑起来~~~\"); &#125;&#125; 定义实现类： 123public class Animal implements LiveAble &#123; // 无法重写静态方法&#125; 定义测试类： 12345678public class InterfaceDemo &#123; public static void main(String[] args) &#123; // Animal.run(); // 【错误】无法继承方法,也无法调用 LiveAble.run(); // &#125;&#125;输出结果：跑起来~~~ 私有方法的使用 私有方法：只有默认方法可以调用。 私有静态方法：默认方法和静态方法可以调用。 如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。同学们在已学技术的基础上，可以自行测试。 定义接口： 1234567891011121314public interface LiveAble &#123; default void func()&#123; func1(); func2(); &#125; private void func1()&#123; System.out.println(\"跑起来~~~\"); &#125; private void func2()&#123; System.out.println(\"跑起来~~~\"); &#125;&#125; 1.4 接口的多实现之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 实现格式： 1234class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123; // 重写接口中抽象方法【必须】 // 重写接口中默认方法【不重名时可选】&#125; [ ]： 表示可选操作。 抽象方法接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。代码如下： 定义多个接口： 123456789interface A &#123; public abstract void showA(); public abstract void show();&#125;interface B &#123; public abstract void showB(); public abstract void show();&#125; 定义实现类： 12345678910111213141516public class C implements A,B&#123; @Override public void showA() &#123; System.out.println(\"showA\"); &#125; @Override public void showB() &#123; System.out.println(\"showB\"); &#125; @Override public void show() &#123; System.out.println(\"show\"); &#125;&#125; 默认方法接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。代码如下： 定义多个接口： 123456789interface A &#123; public default void methodA()&#123;&#125; public default void method()&#123;&#125;&#125;interface B &#123; public default void methodB()&#123;&#125; public default void method()&#123;&#125;&#125; 定义实现类： 123456public class C implements A,B&#123; @Override public void method() &#123; System.out.println(\"method\"); &#125;&#125; 静态方法接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。 优先级的问题当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下： 定义接口： 12345interface A &#123; public default void methodA()&#123; System.out.println(\"AAAAAAAAAAAA\"); &#125;&#125; 定义父类： 12345class D &#123; public void methodA()&#123; System.out.println(\"DDDDDDDDDDDD\"); &#125;&#125; 定义子类： 123class C extends D implements A &#123; // 未重写methodA方法&#125; 定义测试类： 12345678public class Test &#123; public static void main(String[] args) &#123; C c = new C(); c.methodA(); &#125;&#125;输出结果:DDDDDDDDDDDD 1.5 接口的多继承【了解】一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下： 定义父接口： 1234567891011interface A &#123; public default void method()&#123; System.out.println(\"AAAAAAAAAAAAAAAAAAA\"); &#125;&#125;interface B &#123; public default void method()&#123; System.out.println(\"BBBBBBBBBBBBBBBBBBB\"); &#125;&#125; 定义子接口： 123456interface D extends A,B&#123; @Override public default void method() &#123; System.out.println(\"DDDDDDDDDDDDDD\"); &#125;&#125; 小贴士： 子接口重写默认方法时，default关键字可以保留。 子类重写默认方法时，default关键字不可以保留。 1.6 其他成员特点 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中，没有构造方法，不能创建对象。 接口中，没有静态代码块。 第二章 多态2.1 概述引入多态是继封装、继承之后，面向对象的第三大特性。 生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。 定义 多态： 是指同一行为，具有多个不同表现形式。 前提【重点】 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 2.2 多态的体现多态体现的格式： 12父类类型 变量名 = new 子类对象；变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 代码如下： 12Fu f = new Zi();f.method(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 代码如下： 定义父类： 123public abstract class Animal &#123; public abstract void eat(); &#125; 定义子类： 1234567891011class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; &#125; 定义测试类： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Animal a1 = new Cat(); // 调用的是 Cat 的 eat a1.eat(); // 多态形式，创建对象 Animal a2 = new Dog(); // 调用的是 Dog 的 eat a2.eat(); &#125; &#125; 2.3 多态的好处实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下： 定义父类： 123public abstract class Animal &#123; public abstract void eat(); &#125; 定义子类： 1234567891011class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; &#125; 定义测试类： 1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Cat c = new Cat(); Dog d = new Dog(); // 调用showCatEat showCatEat(c); // 调用showDogEat showDogEat(d); /* 以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致 */ showAnimalEat(c); showAnimalEat(d); &#125; public static void showCatEat (Cat c)&#123; c.eat(); &#125; public static void showDogEat (Dog d)&#123; d.eat(); &#125; public static void showAnimalEat (Animal a)&#123; a.eat(); &#125;&#125; 由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。 当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。 所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 2.4 引用类型转换多态的转型分为向上转型与向下转型两种： 向上转型 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 使用格式： 12父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 向下转型 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 12子类类型 变量名 = (子类类型) 父类变量名;如:Cat c =(Cat) a; 为什么要转型当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 转型演示，代码如下： 定义类： 123456789101112131415161718192021abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; public void catchMouse() &#123; System.out.println(\"抓老鼠\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; public void watchHouse() &#123; System.out.println(\"看家\"); &#125; &#125; 定义测试类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; &#125; 转型的异常转型的过程中，一不小心就会遇到这样的问题，请看如下代码： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125; &#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。 为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 123变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。如果变量不属于该数据类型，返回false。 所以，转换前，我们最好先做一个判断，代码如下： 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125; &#125; &#125; 第三章 接口多态的综合案例3.1 笔记本电脑笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。 定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 3.2 案例分析进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要实现USB接口，并具备点击的方法 键盘类，要实现USB接口，具备敲击的方法 3.3 案例实现定义USB接口： 1234interface USB &#123; void open();// 开启功能 void close();// 关闭功能&#125; 定义鼠标类： 1234567891011class Mouse implements USB &#123; public void open() &#123; System.out.println(\"鼠标开启，红灯闪一闪\"); &#125; public void close() &#123; System.out.println(\"鼠标关闭，红灯熄灭\"); &#125; public void click()&#123; System.out.println(\"鼠标单击\"); &#125;&#125; 定义键盘类： 1234567891011class KeyBoard implements USB &#123; public void open() &#123; System.out.println(\"键盘开启，绿灯闪一闪\"); &#125; public void close() &#123; System.out.println(\"键盘关闭，绿灯熄灭\"); &#125; public void type()&#123; System.out.println(\"键盘打字\"); &#125;&#125; 定义笔记本类： 123456789101112131415161718192021222324252627class Laptop &#123; // 笔记本开启运行功能 public void run() &#123; System.out.println(\"笔记本运行\"); &#125; // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备 public void useUSB(USB usb) &#123; // 判断是否有USB设备 if (usb != null) &#123; usb.open(); // 类型转换,调用特有方法 if(usb instanceof Mouse)&#123; Mouse m = （Mouse）usb； m.click(); &#125;else if (usb instanceof KeyBoard)&#123; KeyBoard kb = (KeyBoard)usb; kb.type(); &#125; usb.close(); &#125; &#125; public void shutDown() &#123; System.out.println(\"笔记本关闭\"); &#125;&#125; 测试类，代码如下： 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; // 创建笔记本实体对象 Laptop lt = new Laptop(); // 笔记本开启 lt.run(); // 创建鼠标实体对象 Usb u = new Mouse(); // 笔记本使用鼠标 lt.useUSB(u); // 创建键盘实体对象 KeyBoard kb = new KeyBoard(); // 笔记本使用键盘 lt.useUSB(kb); // 笔记本关闭 lt.shutDown(); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day09【字节流、字符流】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-20T07:43:35.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day09【字节流、字符流】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day09【字节流、字符流】/","excerpt":"","text":"day09【字节流、字符流】主要内容 IO流 字节流 字符流 异常处理 Properties 教学目标 能够说出IO流的分类和功能 能够使用字节输出流写出数据到文件 能够使用字节输入流读取数据到程序 能够理解读取数据read(byte[])方法的原理 能够使用字节流完成文件的复制 能够使用FileWirter写数据到文件 能够说出FileWriter中关闭和刷新方法的区别 能够使用FileWriter写数据的5个方法 能够使用FileWriter写数据实现换行和追加写 能够使用FileReader读数据 能够使用FileReader读数据一次一个字符数组 能够使用Properties的load方法加载文件中配置信息 第一章 IO概述1.1 什么是IO生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。 我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 1.2 IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1.3 IO的流向说明图解 1.4 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 第二章 字节流2.1 一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.3 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"b.txt\"); &#125;&#125; 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"黑马程序员\".getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;输出结果：黑马程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是\\r\\n 。把 以指定是否追加续写了，代码使用演示： 123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(\"\\r\\n\".getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 2.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 构造举例，代码如下： 12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(\"b.txt\"); &#125;&#125; 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 2.6 字节流练习：图片复制复制原理图解 案例实现复制图片文件，代码使用演示： 123456789101112131415161718192021222324public class Copy &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\"); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\"); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=-1) &#123; // 2.4 写出数据 fos.write(b, 0 , len); &#125; // 3.关闭资源 fos.close(); fis.close(); &#125;&#125; 小贴士： 流的关闭原则：先开后关，后开先关。 第三章 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 3.1 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 3.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(\"b.txt\"); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员序 获取有效的字符改进，代码使用演示： 123456789101112131415161718192021public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 3.3 字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。 public void write(int c) ：写出一个字符。 public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 public void write(String str) ：写出一个字符串。 3.4 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"b.txt\"); &#125;&#125; 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close ：关闭流，释放系统资源。关闭前会刷新缓冲区。 代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串转换为字节数组 char[] chars = \"黑马程序员\".toCharArray(); // 写出字符数组 fw.write(chars); // 黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串 String msg = \"黑马程序员\"; // 写出字符数组 fw.write(msg); //黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(msg,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(\"fw.txt\"，true); // 写出字符串 fw.write(\"黑马\"); // 写出换行 fw.write(\"\\r\\n\"); // 写出字符串 fw.write(\"程序员\"); // 关闭资源 fw.close(); &#125;&#125;输出结果:黑马程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 第四章 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 12345678910111213141516171819202122public class HandleException1 &#123; public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(\"黑马程序员\"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDK7的处理还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011public class HandleException2 &#123; public static void main(String[] args) &#123; // 创建流对象 try ( FileWriter fw = new FileWriter(\"fw.txt\"); ) &#123; // 写出数据 fw.write(\"黑马程序员\"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK9的改进(了解内容)JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。 改进前格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：创建新的变量保存try (Resource r1 = resource1; Resource r2 = resource2) &#123; // 使用对象&#125; 改进后格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 改进后，代码使用演示： 12345678910111213141516171819public class TryDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 final FileReader fr = new FileReader(\"in.txt\"); FileWriter fw = new FileWriter(\"out.txt\"); // 引入到try中 try (fr; fw) &#123; // 定义变量 int b; // 读取数据 while ((b = fr.read())!=-1) &#123; // 写出数据 fw.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第五章 属性集5.1 概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 5.2 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 12345678910111213141516171819202122232425262728293031public class ProDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(\"filename\", \"a.txt\"); properties.setProperty(\"length\", \"209385038\"); properties.setProperty(\"location\", \"D:\\\\a.txt\"); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty(\"filename\")); System.out.println(properties.getProperty(\"length\")); System.out.println(properties.getProperty(\"location\")); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+\" -- \"+properties.getProperty(key)); &#125; &#125;&#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\\a.txt&#125;a.txt209385038D:\\a.txtfilename -- a.txtlength -- 209385038location -- D:\\a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: 123filename=a.txtlength=209385038location=D:\\a.txt 加载代码演示： 1234567891011121314151617public class ProDemo2 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileInputStream(\"read.txt\")); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) &#123; System.out.println(key+\" -- \"+pro.getProperty(key)); &#125; &#125;&#125;输出结果：filename -- a.txtlength -- 209385038location -- D:\\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day13【Stream流】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-20T07:43:35.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day13【Stream流】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day13【Stream流】/","excerpt":"","text":"day14【Stream流】主要内容 常用函数式接口 Stream流 教学目标 能够使用Function&lt;T, R&gt;函数式接口 能够使用Predicate函数式接口 能够理解流与集合相比的优点 能够理解流的延迟执行特点 能够通过集合、映射或数组获取流 能够掌握常用的流操作 能够使用流进行并发操作 能够将流中的内容收集到集合中 能够将流中的内容收集到数组中 第一章 常用函数式接口1.1 Predicate接口有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用java.util.function.Predicate&lt;T&gt;接口。 抽象方法：testPredicate接口中包含一个抽象方法：boolean test(T t)。用于条件判断的场景： 123456789101112import java.util.function.Predicate;public class Demo15PredicateTest &#123; private static void method(Predicate&lt;String&gt; predicate) &#123; boolean veryLong = predicate.test(\"HelloWorld\"); System.out.println(\"字符串很长吗：\" + veryLong); &#125; public static void main(String[] args) &#123; method(s -&gt; s.length() &gt; 5); &#125;&#125; 条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 默认方法：and既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个Predicate条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用default方法and。其JDK源码为： 1234default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t);&#125; 如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么： 123456789101112import java.util.function.Predicate;public class Demo16PredicateAnd &#123; private static void method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) &#123; boolean isValid = one.and(two).test(\"Helloworld\"); System.out.println(\"字符串符合要求吗：\" + isValid); &#125; public static void main(String[] args) &#123; method(s -&gt; s.contains(\"H\"), s -&gt; s.contains(\"W\")); &#125;&#125; 默认方法：or与and的“与”类似，默认方法or实现逻辑关系中的“或”。JDK源码为： 1234default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t);&#125; 如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变： 123456789101112import java.util.function.Predicate;public class Demo16PredicateAnd &#123; private static void method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) &#123; boolean isValid = one.or(two).test(\"Helloworld\"); System.out.println(\"字符串符合要求吗：\" + isValid); &#125; public static void main(String[] args) &#123; method(s -&gt; s.contains(\"H\"), s -&gt; s.contains(\"W\")); &#125;&#125; 默认方法：negate“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法negate的JDK源代码为： 123default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t);&#125; 从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在test方法调用之前调用negate方法，正如and和or方法一样： 123456789101112import java.util.function.Predicate;public class Demo17PredicateNegate &#123; private static void method(Predicate&lt;String&gt; predicate) &#123; boolean veryLong = predicate.negate().test(\"HelloWorld\"); System.out.println(\"字符串很长吗：\" + veryLong); &#125; public static void main(String[] args) &#123; method(s -&gt; s.length() &lt; 5); &#125;&#125; 1.2 练习：集合信息筛选题目数组当中有多条“姓名+性别”的信息如下，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，需要同时满足两个条件： 必须为女生； 姓名为4个字。 12345public class DemoPredicate &#123; public static void main(String[] args) &#123; String[] array = &#123; \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\", \"赵丽颖,女\" &#125;; &#125;&#125; 解答123456789101112131415161718192021222324import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;public class DemoPredicate &#123; public static void main(String[] args) &#123; String[] array = &#123; \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\", \"赵丽颖,女\" &#125;; List&lt;String&gt; list = filter(array, s -&gt; \"女\".equals(s.split(\",\")[1]), s -&gt; s.split(\",\")[0].length() == 3); System.out.println(list); &#125; private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String info : array) &#123; if (one.and(two).test(info)) &#123; list.add(info); &#125; &#125; return list; &#125;&#125; 1.3 Function接口java.util.function.Function&lt;T,R&gt;接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有进有出，所以称为“函数Function”。 抽象方法：applyFunction接口中最主要的抽象方法为：R apply(T t)，根据类型T的参数获取类型R的结果。使用的场景例如：将String类型转换为Integer类型。 12345678910111213import java.util.function.Function;public class Demo11FunctionApply &#123; private static void method(Function&lt;String, Integer&gt; function) &#123; int num = function.apply(\"10\"); System.out.println(num + 20); &#125; public static void main(String[] args) &#123; method(s -&gt; Integer.parseInt(s)); method(Integer::parseInt); &#125;&#125; 当然，最好是通过方法引用的写法。 默认方法：andThenFunction接口中有一个默认的andThen方法，用来进行组合操作。JDK源代码如： 1234default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t));&#125; 该方法同样用于“先做什么，再做什么”的场景，和Consumer中的andThen差不多： 123456789101112import java.util.function.Function;public class Demo12FunctionAndThen &#123; private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123; int num = one.andThen(two).apply(\"10\"); System.out.println(num + 20); &#125; public static void main(String[] args) &#123; method(Integer::parseInt, i -&gt; i *= 10); &#125;&#125; 第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过andThen按照前后顺序组合到了一起。 请注意，Function的前置条件泛型和后置条件泛型可以相同。 1.4 练习：自定义函数模型拼接题目请使用Function进行函数模型的拼接，按照顺序需要执行的多个函数操作为： 将字符串截取数字年龄部分，得到字符串； 将上一步的字符串转换成为int类型的数字； 将上一步的int数字累加100，得到结果int数字。 解答1234567891011121314151617import java.util.function.Function;public class DemoFunction &#123; public static void main(String[] args) &#123; String str = \"赵丽颖,20\"; int age = getAgeNum(str, s -&gt; s.split(\",\")[1], Integer::parseInt, n -&gt; n += 100); System.out.println(age); &#125; private static int getAgeNum(String str, Function&lt;String, String&gt; one, Function&lt;String, Integer&gt; two, Function&lt;Integer, Integer&gt; three) &#123; return one.andThen(two).andThen(three).apply(str); &#125;&#125; 1.5 总结：延迟方法与终结方法在上述学习到的多个常用函数式接口当中，方法可以分成两种： 延迟方法：只是在拼接Lambda函数模型的方法，并不立即执行得到结果。 终结方法：根据拼好的Lambda函数模型，立即执行得到结果值的方法。 通常情况下，这些常用的函数式接口中唯一的抽象方法为终结方法，而默认方法为延迟方法。但这并不是绝对的。下面的表格中进行了方法分类的整理： 接口名称 方法名称 抽象/默认 延迟/终结 Supplier get 抽象 终结 Consumer accept 抽象 终结 andThen 默认 延迟 Predicate test 抽象 终结 and 默认 延迟 or 默认 延迟 negate 默认 延迟 Function apply 抽象 终结 andThen 默认 延迟 备注：JDK中更多内置的常用函数式接口，请参考java.util.function包的API文档。 第二章 Stream流说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 2.1 引言传统集合的多步遍历代码几乎所有的集合（如Collection接口或Map接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如： 12345678910111213141516import java.util.ArrayList;import java.util.List;public class Demo01ForEach &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张无忌\"); list.add(\"周芷若\"); list.add(\"赵敏\"); list.add(\"张强\"); list.add(\"张三丰\"); for (String name : list) &#123; System.out.println(name); &#125; &#125; &#125; 这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。 循环遍历的弊端Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现： for循环的语法就是“怎么做” for循环的循环体才是“做什么” 为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 试想一下，如果希望对集合中的元素进行筛选过滤： 将集合A根据条件一过滤为子集B； 然后再根据条件二过滤为子集C。 那怎么办？在Java 8之前的做法可能为： 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class Demo02NormalFilter &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张无忌\"); list.add(\"周芷若\"); list.add(\"赵敏\"); list.add(\"张强\"); list.add(\"张三丰\"); List&lt;String&gt; zhangList = new ArrayList&lt;&gt;(); for (String name : list) &#123; if (name.startsWith(\"张\")) &#123; zhangList.add(name); &#125; &#125; List&lt;String&gt; shortList = new ArrayList&lt;&gt;(); for (String name : zhangList) &#123; if (name.length() == 3) &#123; shortList.add(name); &#125; &#125; for (String name : shortList) &#123; System.out.println(name); &#125; &#125;&#125; 这段代码中含有三个循环，每一个作用不同： 首先筛选所有姓张的人； 然后筛选名字有三个字的人； 最后进行对结果进行打印输出。 每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。 那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？ Stream的更优写法下面来看一下借助Java 8的Stream API，什么才叫优雅： 123456789101112131415161718import java.util.ArrayList;import java.util.List;public class Demo03StreamFilter &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张无忌\"); list.add(\"周芷若\"); list.add(\"赵敏\"); list.add(\"张强\"); list.add(\"张三丰\"); list.stream() .filter(s -&gt; s.startsWith(\"张\")) .filter(s -&gt; s.length() == 3) .forEach(System.out::println); &#125;&#125; 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 2.2 流式思想概述注意：请暂时忘记对传统IO流的固有印象！ 整体来看，流式思想类似于工厂车间的“生产流水线”。 当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。 这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。 这里的filter、map、skip都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法count执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 2.3 获取流java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式： 所有的Collection集合都可以通过stream默认方法获取流； Stream接口的静态方法of可以获取数组对应的流。 根据Collection获取流首先，java.util.Collection接口中加入了default方法stream用来获取流，所以其所有实现类均可获取流。 123456789101112131415161718import java.util.*;import java.util.stream.Stream;public class Demo04GetStream &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // ... Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); // ... Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); // ... Stream&lt;String&gt; stream3 = vector.stream(); &#125;&#125; 根据Map获取流java.util.Map接口不是Collection的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 12345678910111213import java.util.HashMap;import java.util.Map;import java.util.stream.Stream;public class Demo05GetStream &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // ... Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;String&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#125;&#125; 根据数组获取流如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以Stream接口中提供了静态方法of，使用很简单： 12345678import java.util.stream.Stream;public class Demo06GetStream &#123; public static void main(String[] args) &#123; String[] array = &#123; \"张无忌\", \"张翠山\", \"张三丰\", \"张一元\" &#125;; Stream&lt;String&gt; stream = Stream.of(array); &#125;&#125; 备注：of方法的参数其实是一个可变参数，所以支持数组。 2.4 常用方法流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： 终结方法：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。 非终结方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。） 备注：本小节之外的更多方法，请自行参考API文档。 过滤：filter可以通过filter方法将一个流转换成另一个子集流。方法签名： 1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个Predicate函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 复习Predicate接口此前我们已经学习过java.util.stream.Predicate函数式接口，其中唯一的抽象方法为： 1boolean test(T t); 该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的filter方法将会留用元素；如果结果为false，那么filter方法将会舍弃元素。 基本使用Stream流中的filter方法基本使用的代码如： 12345678import java.util.stream.Stream;public class Demo07StreamFilter &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(\"张\")); &#125;&#125; 在这里通过Lambda表达式来指定了筛选的条件：必须姓张。 统计个数：count正如旧集合Collection当中的size方法一样，流提供count方法来数一数其中的元素个数： 1long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用： 123456789import java.util.stream.Stream;public class Demo09StreamCount &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(\"张\")); System.out.println(result.count()); // 2 &#125;&#125; 取用前几个：limitlimit方法可以对流进行截取，只取用前n个。方法签名： 1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用： 123456789import java.util.stream.Stream;public class Demo10StreamLimit &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.limit(2); System.out.println(result.count()); // 2 &#125;&#125; 跳过前几个：skip如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流： 1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用： 123456789import java.util.stream.Stream;public class Demo11StreamSkip &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.skip(2); System.out.println(result.count()); // 1 &#125;&#125; 映射：map如果需要将流中的元素映射到另一个流中，可以使用map方法。方法签名： 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 复习Function接口此前我们已经学习过java.util.stream.Function函数式接口，其中唯一的抽象方法为： 1R apply(T t); 这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 基本使用Stream流中的map方法基本使用的代码如： 12345678import java.util.stream.Stream;public class Demo08StreamMap &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"10\", \"12\", \"18\"); Stream&lt;Integer&gt; result = original.map(Integer::parseInt); &#125;&#125; 这段代码中，map方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为Integer类对象）。 组合：concat如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat： 1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 备注：这是一个静态方法，与java.lang.String当中的concat方法是不同的。 该方法的基本使用代码如： 123456789import java.util.stream.Stream;public class Demo12StreamConcat &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; streamA = Stream.of(\"张无忌\"); Stream&lt;String&gt; streamB = Stream.of(\"张翠山\"); Stream&lt;String&gt; result = Stream.concat(streamA, streamB); &#125;&#125; 逐一处理：forEach虽然方法名字叫forEach，但是与for循环中的“for-each”昵称不同，该方法并不保证元素的逐一消费动作在流中是被有序执行的。 1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。例如： 12345678import java.util.stream.Stream;public class Demo12StreamForEach &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); stream.forEach(System.out::println); &#125;&#125; 在这里，方法引用System.out::println就是一个Consumer函数式接口的示例。 2.5 练习：集合元素处理（传统方式）题目现在有两个ArrayList集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以下若干操作步骤： 第一个队伍只要名字为3个字的成员姓名； 第一个队伍筛选之后只要前3个人； 第二个队伍只要姓张的成员姓名； 第二个队伍筛选之后不要前2个人； 将两个队伍合并为一个队伍； 根据姓名创建Person对象； 打印整个队伍的Person对象信息。 两个队伍（集合）的代码如下： 12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.List;public class DemoArrayListNames &#123; public static void main(String[] args) &#123; List&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(\"迪丽热巴\"); one.add(\"宋远桥\"); one.add(\"苏星河\"); one.add(\"老子\"); one.add(\"庄子\"); one.add(\"孙子\"); one.add(\"洪七公\"); List&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(\"古力娜扎\"); two.add(\"张无忌\"); two.add(\"张三丰\"); two.add(\"赵丽颖\"); two.add(\"张二狗\"); two.add(\"张天爱\"); two.add(\"张三\"); // .... &#125;&#125; 而Person类的代码为： 1234567891011121314151617181920212223public class Person &#123; private String name; public Person() &#123;&#125; public Person(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Person&#123;name='\" + name + \"'&#125;\"; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 解答既然使用传统的for循环写法，那么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DemoArrayListNames &#123; public static void main(String[] args) &#123; List&lt;String&gt; one = new ArrayList&lt;&gt;(); // ... List&lt;String&gt; two = new ArrayList&lt;&gt;(); // ... // 第一个队伍只要名字为3个字的成员姓名； List&lt;String&gt; oneA = new ArrayList&lt;&gt;(); for (String name : one) &#123; if (name.length() == 3) &#123; oneA.add(name); &#125; &#125; // 第一个队伍筛选之后只要前3个人； List&lt;String&gt; oneB = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; oneB.add(oneA.get(i)); &#125; // 第二个队伍只要姓张的成员姓名； List&lt;String&gt; twoA = new ArrayList&lt;&gt;(); for (String name : two) &#123; if (name.startsWith(\"张\")) &#123; twoA.add(name); &#125; &#125; // 第二个队伍筛选之后不要前2个人； List&lt;String&gt; twoB = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; twoA.size(); i++) &#123; twoB.add(twoA.get(i)); &#125; // 将两个队伍合并为一个队伍； List&lt;String&gt; totalNames = new ArrayList&lt;&gt;(); totalNames.addAll(oneB); totalNames.addAll(twoB); // 根据姓名创建Person对象； List&lt;Person&gt; totalPersonList = new ArrayList&lt;&gt;(); for (String name : totalNames) &#123; totalPersonList.add(new Person(name)); &#125; // 打印整个队伍的Person对象信息。 for (Person person : totalPersonList) &#123; System.out.println(person); &#125; &#125;&#125; 运行结果为： 123456Person&#123;name=&apos;宋远桥&apos;&#125;Person&#123;name=&apos;苏星河&apos;&#125;Person&#123;name=&apos;洪七公&apos;&#125;Person&#123;name=&apos;张二狗&apos;&#125;Person&#123;name=&apos;张天爱&apos;&#125;Person&#123;name=&apos;张三&apos;&#125; 2.6 练习：集合元素处理（Stream方式）题目将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变，Person类的定义也不变。 解答等效的Stream流式处理代码为： 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;import java.util.stream.Stream;public class DemoStreamNames &#123; public static void main(String[] args) &#123; List&lt;String&gt; one = new ArrayList&lt;&gt;(); // ... List&lt;String&gt; two = new ArrayList&lt;&gt;(); // ... // 第一个队伍只要名字为3个字的成员姓名； // 第一个队伍筛选之后只要前3个人； Stream&lt;String&gt; streamOne = one.stream().filter(s -&gt; s.length() == 3).limit(3); // 第二个队伍只要姓张的成员姓名； // 第二个队伍筛选之后不要前2个人； Stream&lt;String&gt; streamTwo = two.stream().filter(s -&gt; s.startsWith(\"张\")).skip(2); // 将两个队伍合并为一个队伍； // 根据姓名创建Person对象； // 打印整个队伍的Person对象信息。 Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println); &#125;&#125; 运行效果完全一样： 123456Person&#123;name=&apos;宋远桥&apos;&#125;Person&#123;name=&apos;苏星河&apos;&#125;Person&#123;name=&apos;洪七公&apos;&#125;Person&#123;name=&apos;张二狗&apos;&#125;Person&#123;name=&apos;张天爱&apos;&#125;Person&#123;name=&apos;张三&apos;&#125; 2.7 总结：函数拼接与终结方法在上述介绍的各种方法中，凡是返回值仍然为Stream接口的为函数拼接方法，它们支持链式调用；而返回值不再为Stream接口的为终结方法，不再支持链式调用。如下表所示： 方法名 方法作用 方法种类 是否支持链式调用 count 统计个数 终结 否 forEach 逐一处理 终结 否 filter 过滤 函数拼接 是 limit 取用前几个 函数拼接 是 skip 跳过前几个 函数拼接 是 map 映射 函数拼接 是 concat 组合 函数拼接 是 2.8 并发流当需要对存在于集合或数组中的若干元素进行并发操作时，简直就是噩梦！我们需要仔细考虑多线程环境下的原子性、竞争甚至锁问题，即便是java.util.concurrent.ConcurrentMap&lt;K, V&gt;接口也必须谨慎地正确使用。 而对于Stream流来说，这很简单。 转换为并发流Stream的父接口java.util.stream.BaseStream中定义了一个parallel方法： 1S parallel(); 只需要在流上调用一下无参数的parallel方法，那么当前流即可变身成为支持并发操作的流，返回值仍然为Stream类型。例如： 1234567import java.util.stream.Stream;public class Demo13StreamParallel &#123; public static void main(String[] args) &#123; Stream&lt;Integer&gt; stream = Stream.of(10, 20, 30, 40, 50).parallel(); &#125;&#125; 直接获取并发流在通过集合获取流时，也可以直接调用parallelStream方法来直接获取支持并发操作的流。方法定义为： 1default Stream&lt;E&gt; parallelStream() &#123;...&#125; 应用代码为： 12345678910import java.util.ArrayList;import java.util.Collection;import java.util.stream.Stream;public class Demo13StreamParallel &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = coll.parallelStream(); &#125;&#125; 使用并发流多次执行下面这段代码，结果的顺序在很大概率上是不一定的： 123456789import java.util.stream.Stream;public class Demo13StreamParallel &#123; public static void main(String[] args) &#123; Stream.of(10, 20, 30, 40, 50, 60, 70, 80, 90, 100) .parallel() .forEach(System.out::println); &#125;&#125; 2.9 收集Stream结果对流操作完成之后，如果需要将其结果进行收集，例如获取对应的集合、数组等，如何操作？ 收集到集合中Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T,A, R&gt;接口对象来指定收集到哪种集合中。幸运的是，java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例： public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合。 public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()：转换为Set集合。 下面是这两个方法的基本使用代码： 123456789101112import java.util.List;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;public class Demo15StreamCollect &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"10\", \"20\", \"30\", \"40\", \"50\"); List&lt;String&gt; list = stream.collect(Collectors.toList()); Set&lt;String&gt; set = stream.collect(Collectors.toSet()); &#125;&#125; 收集到数组中Stream提供toArray方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是Object[]的： 1Object[] toArray(); 其使用场景如： 12345678import java.util.stream.Stream;public class Demo16StreamArray &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"10\", \"20\", \"30\", \"40\", \"50\"); Object[] objArray = stream.toArray(); &#125;&#125; 扩展：解决泛型数组问题有了Lambda和方法引用之后，可以使用toArray方法的另一种重载形式传递一个IntFunction&lt;A[]&gt;的函数，继而从外面指定泛型参数。方法签名： 1&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator); 有了它，上例代码中不再局限于Object[]结果，而可以得到String[]结果： 12345678import java.util.stream.Stream;public class Demo17StreamArray &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"10\", \"20\", \"30\", \"40\", \"50\"); String[] strArray = stream.toArray(String[]::new); &#125;&#125; 既然数组也是有构造器的，那么传递一个数组的构造器引用即可。 备注：Java仍然没有泛型数组，原因同样是泛型擦除。 2.10 练习：将数组元素加到集合中题目请通过Stream流的方式，将下面数组当中的元素添加（收集）到List集合当中： 12345public class DemoCollect &#123; public static void main(String[] args) &#123; int[] array = &#123; 10, 20, 30, 40, 50 &#125;; &#125;&#125; 解答首先需要将数组转换成为流，然后再通过collect方法收集到List集合中： 12345678910import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class DemoCollect &#123; public static void main(String[] args) &#123; String[] array = &#123; \"Java\", \"Groovy\", \"Scala\", \"Kotlin\" &#125;; List&lt;String&gt; list = Stream.of(array).collect(Collectors.toList()); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day03【List、Set】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-29T02:17:03.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day03【List、Set】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day03【List、Set】/","excerpt":"","text":"day03 【List、Set、数据结构、Collections】主要内容 List集合 Set集合 数据结构 教学目标 能够说出List集合特点 能够说出常见的数据结构 L能够说出数组结构特点 能够说出栈结构特点 能够说出队列结构特点 能够说出单向链表结构特点 能够说出Set集合的特点 能够说出哈希表的特点 使用HashSet集合存储自定义元素 能够说出可变参数的格式 能够使用集合工具类 能够使用Comparator比较器进行排序 第一章 List集合我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？ 接下来，我们一起学习Collection中的常用几个子类（java.util.List集合、java.util.Set集合）。 1.1 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 看完API，我们总结一下： List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。 1.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧： 12345678910111213141516171819202122232425262728293031323334353637383940public class ListDemo &#123; public static void main(String[] args) &#123; // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add(\"图图\"); list.add(\"小美\"); list.add(\"不高兴\"); System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,\"没头脑\"); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println(\"删除索引位置为2的元素\"); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, \"三毛\"); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; tips:我们之前学习Colletion体系的时候，发现List集合下有很多集合，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？在下一章我们来介绍： 第二章 数据结构2.1 数据结构有什么用？当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。 现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。 我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。 2.2 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下： 栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列节点node（链表中每一个元素称为节点）组成，节点可以在运行时i动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 第三章 List的子类3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 3.2 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 方法演示： 12345678910111213141516171819202122public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //添加元素 link.addFirst(\"abc1\"); link.addFirst(\"abc2\"); link.addFirst(\"abc3\"); System.out.println(link); // 获取元素 System.out.println(link.getFirst()); System.out.println(link.getLast()); // 删除元素 System.out.println(link.removeFirst()); System.out.println(link.removeLast()); while (!link.isEmpty()) &#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 &#125; System.out.println(link); &#125;&#125; 第三章 Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips:Set集合取出元素的方式可以采用：迭代器、增强for。 3.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 12345678910111213141516public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(\"cba\")); set.add(\"abc\"); set.add(\"bac\"); set.add(\"cba\"); //遍历 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素： 123cbaabcbac tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。 2.2 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 2.3 HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(\"于谦\", 43); stuSet.add(stu); stuSet.add(new Student(\"郭德纲\", 44)); stuSet.add(new Student(\"于谦\", 43)); stuSet.add(new Student(\"郭麒麟\", 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] 2.3 LinkedHashSet我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 1.9 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。… 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。 代码演示： 1234567891011121314151617181920212223242526272829303132public class ChangeArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; int sum = getSum(arr); System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; /* * 完成数组 所有元素的求和 原始写法 public static int getSum(int[] arr)&#123; int sum = 0; for(int a : arr)&#123; sum += a; &#125; return sum; &#125; */ //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 第二章 Collections2.1 常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 12345678910111213141516171819public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222] 代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？ 我们发现还有个方法没有讲，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 2.2 Comparator比较器我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 123456789101112public class CollectionsDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125; 结果： 1[aba, cba, nba, sba] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 1234567891011121314151617public class CollectionsDemo3 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0) - o1.charAt(0); &#125; &#125;); System.out.println(list); &#125;&#125; 结果如下： 1[sba, nba, cba, aba] 2.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 2.4 练习创建一个学生类，存储到ArrayList集合中完成指定排序操作。 Student 初始类 123456789101112131415161718192021222324252627282930313233343536public class Student&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(\"rose\",18)); list.add(new Student(\"jack\",16)); list.add(new Student(\"abc\",16)); list.add(new Student(\"ace\",17)); list.add(new Student(\"mark\",16)); /* 让学生 按照年龄排序 升序 */// Collections.sort(list);//要求 该list中元素类型 必须实现比较器Comparable接口 for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125; 发现，当我们调用Collections.sort()方法的时候 程序报错了。 原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。 于是我们就完成了Student类的一个实现，如下： 1234567public class Student implements Comparable&lt;Student&gt;&#123; .... @Override public int compareTo(Student o) &#123; return this.age-o.age;//升序 &#125;&#125; 再次测试，代码就OK 了效果如下： 12345Student&#123;name='jack', age=16&#125;Student&#123;name='abc', age=16&#125;Student&#123;name='mark', age=16&#125;Student&#123;name='ace', age=17&#125;Student&#123;name='rose', age=18&#125; 2.5 扩展如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor c)方式，自己定义规则： 123456Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o2.getAge()-o1.getAge();//以学生的年龄降序 &#125;&#125;); 效果： 12345Student&#123;name=&apos;rose&apos;, age=18&#125;Student&#123;name=&apos;ace&apos;, age=17&#125;Student&#123;name=&apos;jack&apos;, age=16&#125;Student&#123;name=&apos;abc&apos;, age=16&#125;Student&#123;name=&apos;mark&apos;, age=16&#125; 如果想要规则更多一些，可以参考下面代码： 12345678910111213Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 年龄降序 int result = o2.getAge()-o1.getAge();//年龄降序 if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序 result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); 效果如下： 12345Student&#123;name=&apos;rose&apos;, age=18&#125;Student&#123;name=&apos;ace&apos;, age=17&#125;Student&#123;name=&apos;abc&apos;, age=16&#125;Student&#123;name=&apos;jack&apos;, age=16&#125;Student&#123;name=&apos;mark&apos;, age=16&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day12【函数式接口、方法引用】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-20T07:43:35.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day12【函数式接口、方法引用】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day12【函数式接口、方法引用】/","excerpt":"","text":"day12【函数式接口、方法引用】主要内容 常用函数式接口 方法引用 教学目标 能够使用@FunctionalInterface注解 能够自定义无参无返回函数式接口 能够自定义有参有返回函数式接口 能够理解Lambda延迟执行的特点 能够使用Lambda作为方法的参数 能够使用Lambda作为方法的返回值 能够使用输出语句的方法引用 能够通过4种方式使用方法引用 能够使用类和数组的构造器引用 能够使用Supplier函数式接口 能够使用Consumer函数式接口 第一章 函数式接口 1.1 概念函数式接口在Java中是指：有且仅有一个抽象方法的接口。 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。 备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。 1.2 格式只要确保接口中有且仅有一个抽象方法即可： 1234修饰符 interface 接口名称 &#123; public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容&#125; 由于接口当中抽象方法的public abstract是可以省略的，所以定义一个函数式接口很简单： 123public interface MyFunctionalInterface &#123; void myMethod();&#125; 1.3 @FunctionalInterface注解 与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上： 1234@FunctionalInterfacepublic interface MyFunctionalInterface &#123; void myMethod();&#125; 一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。 1.4 自定义函数式接口对于刚刚定义好的MyFunctionalInterface函数式接口，典型使用场景就是作为方法的参数： 1234567891011public class Demo09FunctionalInterface &#123; // 使用自定义的函数式接口作为方法参数 private static void doSomething(MyFunctionalInterface inter) &#123; inter.myMethod(); // 调用自定义的函数式接口方法 &#125; public static void main(String[] args) &#123; // 调用使用函数式接口的方法 doSomething(() -&gt; System.out.println(\"Lambda执行啦！\")); &#125;&#125; 1.5 练习：自定义函数式接口（无参无返回）题目请定义一个函数式接口Eatable，内含抽象eat方法，没有参数或返回值。使用该接口作为方法的参数，并进而通过Lambda来使用它。 解答函数式接口的定义： 1234@FunctionalInterfacepublic interface Eatable &#123; void eat();&#125; 应用场景代码： 123456789public class DemoLambdaEatable &#123; private static void keepAlive(Eatable human) &#123; human.eat(); &#125; public static void main(String[] args) &#123; keepAlive(() -&gt; System.out.println(\"吃饭饭！\")); &#125;&#125; 1.6 练习：自定义函数式接口（有参有返回）题目请定义一个函数式接口Sumable，内含抽象sum方法，可以将两个int数字相加返回int结果。使用该接口作为方法的参数，并进而通过Lambda来使用它。 解答函数式接口的定义： 1234@FunctionalInterfacepublic interface Sumable &#123; int sum(int a, int b);&#125; 应用场景代码： 123456789public class DemoLambdaSumable &#123; private static void showSum(int x, int y, Sumable sumCalculator) &#123; System.out.println(sumCalculator.sum(x, y)); &#125; public static void main(String[] args) &#123; showSum(10, 20, (m, n) -&gt; m + n); &#125;&#125; 第二章 函数式编程 在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。下面我们做一个初探。 2.1 Lambda的延迟执行 有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 性能浪费的日志案例一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出： 123456789101112131415public class Demo01Logger &#123; private static void log(int level, String msg) &#123; if (level == 1) &#123; System.out.println(msg); &#125; &#125; public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; log(1, msgA + msgB + msgC); &#125;&#125; 这段代码存在问题：无论级别是否满足要求，作为log方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如：LOGGER.debug(&quot;变量{}的取值为{}。&quot;, &quot;os&quot;, &quot;macOS&quot;)，其中的大括号{}为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。 体验Lambda的更优写法使用Lambda必然需要一个函数式接口： 1234@FunctionalInterfacepublic interface MessageBuilder &#123; String buildMessage();&#125; 然后对log方法进行改造： 123456789101112131415public class Demo02LoggerLambda &#123; private static void log(int level, MessageBuilder builder) &#123; if (level == 1) &#123; System.out.println(builder.buildMessage()); &#125; &#125; public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; log(1, () -&gt; msgA + msgB + msgC ); &#125;&#125; 这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。 证明Lambda的延迟下面的代码可以通过结果进行验证： 123456789101112131415161718public class Demo03LoggerDelay &#123; private static void log(int level, MessageBuilder builder) &#123; if (level == 1) &#123; System.out.println(builder.buildMessage()); &#125; &#125; public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; log(2, () -&gt; &#123; System.out.println(\"Lambda执行！\"); return msgA + msgB + msgC; &#125;); &#125;&#125; 从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。 2.2 使用Lambda作为参数和返回值如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。 例如java.lang.Runnable接口就是一个函数式接口，假设有一个startThread方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和Thread类的构造方法参数为Runnable没有本质区别。 123456789public class Demo04Runnable &#123; private static void startThread(Runnable task) &#123; new Thread(task).start(); &#125; public static void main(String[] args) &#123; startThread(() -&gt; System.out.println(\"线程任务执行！\")); &#125;&#125; 类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个java.util.Comparator接口类型的对象作为排序器时： 123456789101112131415import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator &#123; private static Comparator&lt;String&gt; newComparator() &#123; return (a, b) -&gt; b.length() - a.length(); &#125; public static void main(String[] args) &#123; String[] array = &#123; \"abc\", \"ab\", \"abcd\" &#125;; System.out.println(Arrays.toString(array)); Arrays.sort(array, newComparator()); System.out.println(Arrays.toString(array)); &#125;&#125; 其中直接return一个Lambda表达式即可。 2.3 练习：自定义Lambda参数和返回值题目请自定义一个函数式接口MySupplier，含有无参数的抽象方法get得到Object类型的返回值。并使用该函数式接口分别作为方法的参数和返回值。 解答函数式接口MySupplier如： 1234@FunctionalInterfacepublic interface MySupplier &#123; Object get();&#125; 使用该接口作为方法的参数，并且在传递参数时将实际参数写成Lambda： 123456789public class Demo05MySupplier &#123; private static void printParam(MySupplier supplier) &#123; System.out.println(supplier.get()); &#125; public static void main(String[] args) &#123; printParam(() -&gt; \"Hello\"); &#125;&#125; 使用该接口作为方法的参数，也很简单： 12345678910111213public class Demo07MySupplier &#123; private static MySupplier getData() &#123; return () -&gt; \"Hello\"; &#125; private static void printData(MySupplier supplier) &#123; System.out.println(supplier.get()); &#125; public static void main(String[] args) &#123; printData(getData()); &#125;&#125; 其中main方法不再自己指定Lambda表达式，而是通过调用一个getData方法来获取Lambda的内容。 第三章 方法引用 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 3.1 冗余的Lambda场景来看一个简单的函数式接口以应用Lambda表达式： 1234@FunctionalInterfacepublic interface Printable &#123; void print(String str);&#125; 在Printable接口当中唯一的抽象方法print接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 123456789public class Demo01PrintSimple &#123; private static void printString(Printable data) &#123; data.print(\"Hello, World!\"); &#125; public static void main(String[] args) &#123; printString(s -&gt; System.out.println(s)); &#125;&#125; 其中printString方法只管调用Printable接口的print方法，而并不管print方法的具体实现逻辑会将字符串打印到什么地方去。而main方法通过Lambda表达式指定了函数式接口Printable的具体操作方案为：拿到String（类型可推导，所以可省略）数据后，在控制台中输出它。 3.2 问题分析这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是System.out对象中的println(String)方法。既然Lambda希望做的事情就是调用println(String)方法，那何必自己手动调用呢？ 3.3 用方法引用改进代码能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了： 123456789public class Demo02PrintRef &#123; private static void printString(Printable data) &#123; data.print(\"Hello, World!\"); &#125; public static void main(String[] args) &#123; printString(System.out::println); &#125;&#125; 请注意其中的双冒号::写法，这被称为“方法引用”，而双冒号是一种新的语法。 3.4 方法引用符双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 语义分析例如上例中，System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效： Lambda表达式写法：s -&gt; System.out.println(s); 方法引用写法：System.out::println 第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。 第二种等效写法的语义是指：直接让System.out中的println方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 推导与省略如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 下面这段代码将会调用println方法的不同重载形式，将函数式接口改为int类型的参数： 1234@FunctionalInterfacepublic interface PrintableInteger &#123; void print(int str);&#125; 由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化： 123456789public class Demo03PrintOverload &#123; private static void printInteger(PrintableInteger data) &#123; data.print(1024); &#125; public static void main(String[] args) &#123; printInteger(System.out::println); &#125;&#125; 这次方法引用将会自动匹配到println(int)的重载形式。 3.5 通过对象名引用成员方法这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： 12345public class MethodRefObject &#123; public void printUpperCase(String str) &#123; System.out.println(str.toUpperCase()); &#125;&#125; 函数式接口仍然定义为： 1234@FunctionalInterfacepublic interface Printable &#123; void print(String str);&#125; 那么当需要使用这个printUpperCase成员方法来替代Printable接口的Lambda的时候，已经具有了MethodRefObject类的对象实例，则可以通过对象名引用成员方法，代码为： 12345678910public class Demo04MethodRef &#123; private static void printString(Printable lambda) &#123; lambda.print(\"Hello\"); &#125; public static void main(String[] args) &#123; MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); &#125;&#125; 3.6 练习：对象名引用成员方法题目假设有一个助理类Assistant，其中含有成员方法dealFile如下： 12345public class Assistant &#123; public void dealFile(String file) &#123; System.out.println(\"帮忙处理文件：\" + file); &#125; &#125; 请自定义一个函数式接口WorkHelper，其中的抽象方法help的预期行为与dealFile方法一致，并定义一个方法使用该函数式接口作为参数。通过方法引用的形式，将助理对象中的help方法作为Lambda的实现。 解答函数式接口可以定义为： 1234@FunctionalInterfacepublic interface WorkHelper &#123; void help(String file); &#125; 通过对象名引用成员方法的使用场景代码为： 12345678910public class DemoAssistant &#123; private static void work(WorkHelper helper) &#123; helper.help(\"机密文件\"); &#125; public static void main(String[] args) &#123; Assistant assistant = new Assistant(); work(assistant::dealFile); &#125;&#125; 3.7 通过类名称引用静态方法由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： 1234@FunctionalInterfacepublic interface Calcable &#123; int calc(int num);&#125; 第一种写法是使用Lambda表达式： 123456789public class Demo05Lambda &#123; private static void method(int num, Calcable lambda) &#123; System.out.println(lambda.calc(num)); &#125; public static void main(String[] args) &#123; method(-10, n -&gt; Math.abs(n)); &#125;&#125; 但是使用方法引用的更好写法是： 123456789public class Demo06MethodRef &#123; private static void method(int num, Calcable lambda) &#123; System.out.println(lambda.calc(num)); &#125; public static void main(String[] args) &#123; method(-10, Math::abs); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：n -&gt; Math.abs(n) 方法引用：Math::abs 3.8 练习：类名称引用静态方法题目假设有一个StringUtils字符串工具类，其中含有静态方法isBlank如下： 12345public final class StringUtils &#123; public static boolean isBlank(String str) &#123; return str == null || \"\".equals(str.trim()); &#125;&#125; 请自定义一个函数式接口StringChecker，其中的抽象方法checkBlank的预期行为与isBlank一致，并定义一个方法使用该函数式接口作为参数。通过方法引用的形式，将StringUtils工具类中的isBlank方法作为Lambda的实现。 解答函数式接口的定义可以为： 1234@FunctionalInterfacepublic interface StringChecker &#123; boolean checkString(String str); &#125; 应用场景代码为： 123456789public class DemoStringChecker &#123; private static void methodCheck(StringChecker checker) &#123; System.out.println(checker.checkString(\" \")); &#125; public static void main(String[] args) &#123; methodCheck(StringUtils::isBlank); &#125;&#125; 3.9 通过super引用成员方法如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口： 1234@FunctionalInterfacepublic interface Greetable &#123; void greet();&#125; 然后是父类Human的内容： 12345public class Human &#123; public void sayHello() &#123; System.out.println(\"Hello!\"); &#125;&#125; 最后是子类Man的内容，其中使用了Lambda的写法： 1234567891011public class Man extends Human &#123; @Override public void sayHello() &#123; method(() -&gt; super.sayHello()); &#125; private void method(Greetable lambda) &#123; lambda.greet(); System.out.println(\"I'm a man!\"); &#125;&#125; 但是如果使用方法引用来调用父类中的sayHello方法会更好，例如另一个子类Woman： 1234567891011public class Woman extends Human &#123; @Override public void sayHello() &#123; method(super::sayHello); &#125; private void method(Greetable lambda) &#123; lambda.greet(); System.out.println(\"I'm a woman!\"); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：() -&gt; super.sayHello() 方法引用：super::sayHello 3.10 通过this引用成员方法this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口： 1234@FunctionalInterfacepublic interface Richable &#123; void buy();&#125; 下面是一个丈夫Husband类： 123456789public class Husband &#123; private void marry(Richable lambda) &#123; lambda.buy(); &#125; public void beHappy() &#123; marry(() -&gt; System.out.println(\"买套房子\")); &#125;&#125; 开心方法beHappy调用了结婚方法marry，后者的参数为函数式接口Richable，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对Husband丈夫类进行修改： 12345678910111213public class Husband &#123; private void buyHouse() &#123; System.out.println(\"买套房子\"); &#125; private void marry(Richable lambda) &#123; lambda.buy(); &#125; public void beHappy() &#123; marry(() -&gt; this.buyHouse()); &#125;&#125; 如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为： 12345678910111213public class Husband &#123; private void buyHouse() &#123; System.out.println(\"买套房子\"); &#125; private void marry(Richable lambda) &#123; lambda.buy(); &#125; public void beHappy() &#123; marry(this::buyHouse); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：() -&gt; this.buyHouse() 方法引用：this::buyHouse 3.11 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。首先是一个简单的Person类： 1234567891011public class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 然后是用来创建Person对象的函数式接口： 123public interface PersonBuilder &#123; Person buildPerson(String name);&#125; 要使用这个函数式接口，可以通过Lambda表达式： 123456789public class Demo09Lambda &#123; public static void printName(String name, PersonBuilder builder) &#123; System.out.println(builder.buildPerson(name).getName()); &#125; public static void main(String[] args) &#123; printName(\"赵丽颖\", name -&gt; new Person(name)); &#125;&#125; 但是通过构造器引用，有更好的写法： 123456789public class Demo10ConstructorRef &#123; public static void printName(String name, PersonBuilder builder) &#123; System.out.println(builder.buildPerson(name).getName()); &#125; public static void main(String[] args) &#123; printName(\"赵丽颖\", Person::new); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：name -&gt; new Person(name) 方法引用：Person::new 3.12 数组的构造器引用数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，需要一个函数式接口： 1234@FunctionalInterfacepublic interface ArrayBuilder &#123; int[] buildArray(int length);&#125; 在应用该接口的时候，可以通过Lambda表达式： 123456789public class Demo11ArrayInitRef &#123; private static int[] initArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125; public static void main(String[] args) &#123; int[] array = initArray(10, length -&gt; new int[length]); &#125;&#125; 但是更好的写法是使用数组的构造器引用： 123456789public class Demo12ArrayInitRef &#123; private static int[] initArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125; public static void main(String[] args) &#123; int[] array = initArray(10, int[]::new); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：length -&gt; new int[length] 方法引用：int[]::new 备注：数组的构造器引用，可以和Java 8的Stream API结合，在一定程度上“解决”集合中toArray方法的泛型擦除问题。 第四章 常用函数式接口 JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在java.util.function包中被提供。前文的MySupplier接口就是在模拟一个函数式接口：java.util.function.Supplier&lt;T&gt;。其实还有很多，下面是最简单的几个接口及使用示例。 4.1 Supplier接口java.util.function.Supplier&lt;T&gt;接口仅包含一个无参的方法：T get()。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。 12345678910111213import java.util.function.Supplier;public class Demo08Supplier &#123; private static String getString(Supplier&lt;String&gt; function) &#123; return function.get(); &#125; public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; System.out.println(getString(() -&gt; msgA + msgB)); &#125;&#125; 备注：其实这个接口在前面的练习中已经模拟过了。 4.2 练习：求数组元素最大值题目使用Supplier接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用java.lang.Integer类。 解答123456789101112131415161718192021import java.util.function.Supplier;public class DemoIntArray &#123; public static void main(String[] args) &#123; int[] array = &#123; 10, 20, 100, 30, 40, 50 &#125;; printMax(() -&gt; &#123; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; return max; &#125;); &#125; private static void printMax(Supplier&lt;Integer&gt; supplier) &#123; int max = supplier.get(); System.out.println(max); &#125;&#125; 4.3 Consumer接口java.util.function.Consumer&lt;T&gt;接口则正好相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型参数决定。 抽象方法：acceptConsumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。基本使用如： 123456789101112import java.util.function.Consumer;public class Demo09Consumer &#123; private static void consumeString(Consumer&lt;String&gt; function) &#123; function.accept(\"Hello\"); &#125; public static void main(String[] args) &#123; consumeString(s -&gt; System.out.println(s)); consumeString(System.out::println); &#125;&#125; 当然，更好的写法是使用方法引用。 默认方法：andThen如果一个方法的参数和返回值全都是Consumer类型，那么就可以实现效果：消费一个数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是Consumer接口中的default方法andThen。下面是JDK的源代码： 1234default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;&#125; 备注：java.util.Objects的requireNonNull静态方法将会在参数为null时主动抛出NullPointerException异常。这省去了重复编写if语句和抛出空指针异常的麻烦。 要想实现组合，需要两个或多个Lambda表达式即可，而andThen的语义正是“一步接一步”操作。例如两个步骤组合的情况： 12345678910111213import java.util.function.Consumer;public class Demo10ConsumerAndThen &#123; private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two) &#123; one.andThen(two).accept(\"Hello\"); &#125; public static void main(String[] args) &#123; consumeString( s -&gt; System.out.println(s.toUpperCase()), s -&gt; System.out.println(s.toLowerCase())); &#125;&#125; 运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。 4.4 练习：格式化打印信息题目下面的字符串数组当中存有多条信息，请按照格式“姓名：XX。性别：XX。”的格式将信息打印出来。要求将打印姓名的动作作为第一个Consumer接口的Lambda实例，将打印性别的动作作为第二个Consumer接口的Lambda实例，将两个Consumer接口按照顺序“拼接”到一起。 123public static void main(String[] args) &#123; String[] array = &#123; \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\" &#125;;&#125; 解答12345678910111213141516import java.util.function.Consumer;public class DemoConsumer &#123; public static void main(String[] args) &#123; String[] array = &#123; \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\" &#125;; printInfo(s -&gt; System.out.print(\"姓名：\" + s.split(\",\")[0]), s -&gt; System.out.println(\"。性别：\" + s.split(\",\")[1] + \"。\"), array); &#125; private static void printInfo(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two, String[] array) &#123; for (String info : array) &#123; one.andThen(two).accept(info); // 姓名：迪丽热巴。性别：女。 &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day07【线程池、Lambda表达式】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-20T07:43:35.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day07【线程池、Lambda表达式】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day07【线程池、Lambda表达式】/","excerpt":"","text":"day07【线程池、Lambda表达式】主要内容 线程池 Lambda表达式 教学目标 能够理解线程通信概念 能够理解等待唤醒机制 能够描述Java中线程池运行原理 能够理解函数式编程相对于面向对象的优点 能够掌握Lambda表达式的标准格式 能够使用Lambda标准格式使用Runnable与Comparator接口 能够掌握Lambda表达式的省略格式与规则 能够使用Lambda省略格式使用Runnable与Comparator接口 能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法） 能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法） 能够明确Lambda的两项使用前提 第一章 等待唤醒机制1.1 线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。 为什么要处理线程间通信： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 1.2 等待唤醒机制什么是等待唤醒机制 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 1.3 生产者与消费者问题等待唤醒机制其实就是经典的“生产者与消费者”的问题。 就拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 1包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。 代码演示： 包子资源类： 12345public class BaoZi &#123; String pier ; String xianer ; boolean flag = false ;//包子资源 是否存在 包子资源状态&#125; 吃货线程类： 12345678910111213141516171819202122232425public class ChiHuo extends Thread&#123; private BaoZi bz; public ChiHuo(String name,BaoZi bz)&#123; super(name); this.bz = bz; &#125; @Override public void run() &#123; while(true)&#123; synchronized (bz)&#123; if(bz.flag == false)&#123;//没包子 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"吃货正在吃\"+bz.pier+bz.xianer+\"包子\"); bz.flag = false; bz.notify(); &#125; &#125; &#125;&#125; 包子铺线程类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BaoZiPu extends Thread &#123; private BaoZi bz; public BaoZiPu(String name,BaoZi bz)&#123; super(name); this.bz = bz; &#125; @Override public void run() &#123; int count = 0; //造包子 while(true)&#123; //同步 synchronized (bz)&#123; if(bz.flag == true)&#123;//包子资源 存在 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 没有包子 造包子 System.out.println(\"包子铺开始做包子\"); if(count%2 == 0)&#123; // 冰皮 五仁 bz.pier = \"冰皮\"; bz.xianer = \"五仁\"; &#125;else&#123; // 薄皮 牛肉大葱 bz.pier = \"薄皮\"; bz.xianer = \"牛肉大葱\"; &#125; count++; bz.flag=true; System.out.println(\"包子造好了：\"+bz.pier+bz.xianer); System.out.println(\"吃货来吃吧\"); //唤醒等待线程 （吃货） bz.notify(); &#125; &#125; &#125;&#125; 测试类： 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //等待唤醒案例 BaoZi bz = new BaoZi(); ChiHuo ch = new ChiHuo(\"吃货\",bz); BaoZiPu bzp = new BaoZiPu(\"包子铺\",bz); ch.start(); bzp.start(); &#125;&#125; 执行效果： 123456789101112包子铺开始做包子包子造好了：冰皮五仁吃货来吃吧吃货正在吃冰皮五仁包子包子铺开始做包子包子造好了：薄皮牛肉大葱吃货来吃吧吃货正在吃薄皮牛肉大葱包子包子铺开始做包子包子造好了：冰皮五仁吃货来吃吧吃货正在吃冰皮五仁包子 第二章 线程池2.1 线程池思想概述 我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 2.2 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理： 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 2.3 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： 12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"我要一个教练\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"教练来了： \" + Thread.currentThread().getName()); System.out.println(\"教我游泳,交完后，教练回到了游泳池\"); &#125;&#125; 线程池测试类： 12345678910111213141516171819202122public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125; 第三章 Lambda表达式3.1 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 3.2 冗余的Runnable代码传统写法当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789101112public class Demo01Runnable &#123; public static void main(String[] args) &#123; // 匿名内部类 Runnable task = new Runnable() &#123; @Override public void run() &#123; // 覆盖重写抽象方法 System.out.println(\"多线程任务执行！\"); &#125; &#125;; new Thread(task).start(); // 启动线程 &#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 3.3 编程思想转换做什么，而不是怎么做我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 生活举例 当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。 而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性，为我们打开了新世界的大门。 3.4 体验Lambda的更优写法借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 12345public class Demo02LambdaRunnable &#123; public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println(\"多线程任务执行！\")).start(); // 启动线程 &#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ 3.5 回顾匿名内部类Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容： 1() -&gt; System.out.println(\"多线程任务执行！\") 为了理解Lambda的语义，我们需要从传统的代码起步。 使用实现类要启动一个线程，需要创建一个Thread类的对象并调用start方法。而为了指定线程执行的内容，需要调用Thread类的构造方法： public Thread(Runnable target) 为了获取Runnable接口的实现对象，可以为该接口定义一个实现类RunnableImpl： 123456public class RunnableImpl implements Runnable &#123; @Override public void run() &#123; System.out.println(\"多线程任务执行！\"); &#125;&#125; 然后创建该实现类的对象作为Thread类的构造参数： 123456public class Demo03ThreadInitParam &#123; public static void main(String[] args) &#123; Runnable task = new RunnableImpl(); new Thread(task).start(); &#125;&#125; 使用匿名内部类这个RunnableImpl类只是为了实现Runnable接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类： 12345678910public class Demo04ThreadNameless &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"多线程任务执行！\"); &#125; &#125;).start(); &#125;&#125; 匿名内部类的好处与弊端一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！ 语义分析仔细分析该代码中的语义，Runnable接口只有一个run方法的定义： public abstract void run(); 即制定了一种做事情的方案（其实就是一个函数）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： 1() -&gt; System.out.println(\"多线程任务执行！\") 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 3.6 Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： 1(参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 3.7 练习：使用Lambda标准格式（无参无返回）题目给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。如下： 123public interface Cook &#123; void makeFood();&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样： 123456789public class Demo05InvokeCook &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCook方法 &#125; private static void invokeCook(Cook cook) &#123; cook.makeFood(); &#125;&#125; 解答12345public static void main(String[] args) &#123; invokeCook(() -&gt; &#123; System.out.println(\"吃饭啦！\"); &#125;);&#125; 备注：小括号代表Cook接口makeFood抽象方法的参数为空，大括号代表makeFood的方法体。 3.8 Lambda的参数和返回值下面举例演示java.util.Comparator&lt;T&gt;接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： 123456public class Person &#123; private String name; private int age; // 省略构造器、toString方法与Getter Setter &#125; 传统写法如果使用传统的代码对Person[]数组进行排序，写法如下： 12345678910111213141516171819202122232425import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator &#123; public static void main(String[] args) &#123; // 本来年龄乱序的对象数组 Person[] array = &#123; new Person(\"古力娜扎\", 19), new Person(\"迪丽热巴\", 18), new Person(\"马尔扎哈\", 20) &#125;; // 匿名内部类 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;; Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例 for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 这种做法在面向对象的思想中，似乎也是“理所当然”的。其中Comparator接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。 代码分析下面我们来搞清楚上述代码真正要做什么事情。 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法123456789101112131415161718import java.util.Arrays;public class Demo07ComparatorLambda &#123; public static void main(String[] args) &#123; Person[] array = &#123; new Person(\"古力娜扎\", 19), new Person(\"迪丽热巴\", 18), new Person(\"马尔扎哈\", 20) &#125;; Arrays.sort(array, (Person a, Person b) -&gt; &#123; return a.getAge() - b.getAge(); &#125;); for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 3.9 练习：使用Lambda标准格式（有参有返回）题目给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值： 123public interface Calculator &#123; int calc(int a, int b);&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算： 12345678910public class Demo08InvokeCalc &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß &#125; private static void invokeCalc(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println(\"结果是：\" + result); &#125;&#125; 解答12345public static void main(String[] args) &#123; invokeCalc(120, 130, (int a, int b) -&gt; &#123; return a + b; &#125;);&#125; 备注：小括号代表Calculator接口calc抽象方法的参数，大括号代表calc的方法体。 3.10 Lambda省略格式可推导即可省略Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： 123public static void main(String[] args) &#123; invokeCalc(120, 130, (a, b) -&gt; a + b);&#125; 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。 3.11 练习：使用Lambda省略格式题目仍然使用前文含有唯一makeFood抽象方法的厨子Cook接口，在下面的代码中，请使用Lambda的省略格式调用invokeCook方法，打印输出“吃饭啦！”字样： 123456789public class Demo09InvokeCook &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【省略格式】调用invokeCook方法 &#125; private static void invokeCook(Cook cook) &#123; cook.makeFood(); &#125;&#125; 解答123public static void main(String[] args) &#123; invokeCook(() -&gt; System.out.println(\"吃饭啦！\"));&#125; 3.12 Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day11【网络编程】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-20T07:43:35.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day11【网络编程】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day11【网络编程】/","excerpt":"","text":"day11【网络编程】主要内容 软件架构CS／BS 网络通信三要素 TCP通信 Socket套接字 ServerSocket 教学目标 能够辨别UDP和TCP协议特点 能够说出TCP协议下两个常用类名称 能够编写UDP协议下字符串数据传输程序 能够编写TCP协议下字符串数据传输程序 能够理解TCP协议下文件上传案例 能够理解TCP协议下BS案例 第一章 网络编程入门1.1软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 12345678910111213141516171819202122public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); //5.关闭资源. is.close(); server.close(); &#125;&#125; 客户端实现： 1234567891011121314public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.获取流对象 . 输出流 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // 4. 关闭资源 . os.close(); client.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 12345678910111213141516171819202122232425262728public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); // =================回写数据======================= // 5. 通过 socket 获取输出流 OutputStream out = server.getOutputStream(); // 6. 回写数据 out.write(\"我很好,谢谢你\".getBytes()); // 7.关闭资源. out.close(); is.close(); server.close(); &#125;&#125; 客户端实现： 12345678910111213141516171819202122public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.通过Scoket,获取输出流对象 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // ==============解析回写========================= // 4. 通过Scoket,获取 输入流对象 InputStream in = client.getInputStream(); // 5. 读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6. 关闭资源 . in.close(); os.close(); client.close(); &#125;&#125; 第三章 综合案例3.1 文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 12345678910111213141516171819202122232425public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 建立连接 Socket accept = serverSocket.accept(); // 3. 创建流对象 // 3.1 获取输入流,读取文件数据 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流,保存到本地 . BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.jpg\")); // 4. 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425public class FileUPload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); bos.flush(); &#125; System.out.println(\"文件发送完毕\"); // 3.释放资源 bos.close(); socket.close(); bis.close(); System.out.println(\"文件上传完毕 \"); &#125;&#125; 文件上传优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现12345678910111213141516171819202122232425262728293031323334353637public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis);) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //4. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 信息回写分析图解前四步与基本文件上传一致. 【服务端】获取输出流，回写数据。 【客户端】获取输入流，解析回写数据。 回写实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis); ) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; // 4.=======信息回写=========================== System.out.println(\"back ........\"); OutputStream out = accept.getOutputStream(); out.write(\"上传成功\".getBytes()); out.close(); //================================ //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425262728293031public class FileUpload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); &#125; // 关闭输出流,通知服务端,写出数据完毕 socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); // 3. =====解析回写============ InputStream in = socket.getInputStream(); byte[] back = new byte[20]; in.read(back); System.out.println(new String(back)); in.close(); // ============================ // 4.释放资源 socket.close(); bis.close(); &#125;&#125; 3.2 模拟服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 复制到我们Module中，比如复制到day08中 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 12345678//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(\" \");//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端实现： 1234567891011121314151617181920212223242526272829303132333435public class SerDemo &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端 启动 , 等待连接 .... \"); // 创建ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(\" \"); // 去掉web前面的/ String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); server.close(); &#125;&#125; 访问效果 火狐 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); while(true)&#123; Socket socket = server.accept(); new Thread(new Web(socket)).start(); &#125; &#125; static class Web implements Runnable&#123; private Socket socket; public Web(Socket socket)&#123; this.socket=socket; &#125; public void run() &#123; try&#123; //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(\" \"); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); &#125;catch(Exception ex)&#123; &#125; &#125; &#125;&#125; 访问效果： 图解：","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day10【缓冲流、转换流、序列化流、Files】","date":"2018-06-20T07:43:35.000Z","updated":"2018-06-20T07:43:35.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day10【缓冲流、转换流、序列化流、Files】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day10【缓冲流、转换流、序列化流、Files】/","excerpt":"","text":"day10【缓冲流、转换流、序列化流】主要内容 转换流 缓冲流 序列化流 打印流 教学目标 能够使用字节缓冲流读取数据到程序 能够使用字节缓冲流写出数据到文件 能够明确字符缓冲流的作用和基本用法 能够使用缓冲流的特殊功能 能够阐述编码表的意义 能够使用转换流读取指定编码的文本文件 能够使用转换流写入指定编码的文本文件 能够说出打印流的特点 能够使用序列化流写出对象到文件 能够使用反序列化流读取文件到程序中 第一章 缓冲流昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 1.1 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 1.2 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\")); 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(\"jdk9.exe\"); FileOutputStream fos = new FileOutputStream(\"copy.exe\") )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\"); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\")); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\"); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\")); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\"); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 1.3 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));// 创建字节缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\")); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\"in.txt\")); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(\"------\"); &#125; // 释放资源 br.close(); &#125;&#125; newLine方法演示，代码如下： 1234567891011121314151617181920public class BufferedWriterDemo throws IOException &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\")); // 写出数据 bw.write(\"黑马\"); // 写出换行 bw.newLine(); bw.write(\"程序\"); bw.newLine(); bw.write(\"员\"); bw.newLine(); // 释放资源 bw.close(); &#125;&#125;输出效果:黑马程序员 1.4 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 解析文本信息到集合中。 遍历集合，按顺序，写出文本信息。 案例实现12345678910111213141516171819202122232425262728293031323334public class BufferedTest &#123; public static void main(String[] args) throws IOException &#123; // 创建map集合,保存文本数据,键为序号,值为文字 HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;(); // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\"in.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\")); // 读取数据 String line = null; while ((line = br.readLine())!=null) &#123; // 解析文本 String[] split = line.split(\"\\\\.\"); // 保存到集合 lineMap.put(split[0],split[1]); &#125; // 释放资源 br.close(); // 遍历map集合 for (int i = 1; i &lt;= lineMap.size(); i++) &#123; String key = String.valueOf(i); // 获取map中文本 String value = lineMap.get(key); // 写出拼接文本 bw.write(key+\".\"+value); // 写出换行 bw.newLine(); &#125; // 释放资源 bw.close(); &#125;&#125; 第二章 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本f符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 字符集 Charset：是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-5559-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(\"E:\\\\File_GBK.txt\"); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = \"E:\\\\file_gbk.txt\"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\"); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; 2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集讲字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\"); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = \"E:\\\\out.txt\"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(\"你好\"); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = \"E:\\\\out2.txt\"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\"); // 写出数据 osw2.write(\"你好\");// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现12345678910111213141516171819202122232425public class TransDemo &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = \"file_gbk.txt\"; String destFile = \"file_utf8.txt\"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \"GBK\"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125; 第三章 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的数据等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(\"employee.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = \"zhangsan\"; e.address = \"beiqinglu\"; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\")); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved 3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(\"employee.txt\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(\"Employee class not found\"); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(\"Name: \" + e.name); // zhangsan System.out.println(\"Address: \" + e.address); // beiqinglu System.out.println(\"age: \" + e.age); // 0 &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 3.4 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学习对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 案例实现12345678910111213141516171819202122232425262728293031323334public class SerTest &#123; public static void main(String[] args) throws Exception &#123; // 创建 学生对象 Student student = new Student(\"老王\", \"laow\"); Student student2 = new Student(\"老张\", \"laoz\"); Student student3 = new Student(\"老李\", \"laol\"); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(student); arrayList.add(student2); arrayList.add(student3); // 序列化操作 // serializ(arrayList); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"list.txt\")); // 读取对象,强转为ArrayList类型 ArrayList&lt;Student&gt; list = (ArrayList&lt;Student&gt;)ois.readObject(); for (int i = 0; i &lt; list.size(); i++ )&#123; Student s = list.get(i); System.out.println(s.getName()+\"--\"+ s.getPwd()); &#125; &#125; private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123; // 创建 序列化流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"list.txt\")); // 写出对象 oos.writeObject(arrayList); // 释放资源 oos.close(); &#125;&#125; 第四章 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream(\"ps.txt\")； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 1234567891011121314public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(\"ps.txt\"); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaSE/课件/day04【final、权限、内部类】","date":"2018-06-20T07:43:33.000Z","updated":"2018-06-20T07:44:02.000Z","comments":true,"path":"2018/06/20/Java/JavaSE/课件/day04【final、权限、内部类】/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/Java/JavaSE/课件/day04【final、权限、内部类】/","excerpt":"","text":"day04【final、权限、内部类、引用类型】今日内容 final关键字 权限 内部类 引用类型 教学目标 描述final修饰的类的特点 描述final修饰的方法的特点 能够说出权限修饰符作用范围 说出内部类的概念 能够理解引用类型作为成员变量 能够理解引用类型作为方法参数 能够理解引用类型作为方法返回值类型 第一章 final关键字1.1 概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了final 关键字，用于修饰不可改变内容。 final： 不可改变。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 1.2 使用方式修饰类格式如下： 123final class 类名 &#123; &#125; 查询API发现像 public final class String 、public final class Math 、public final class Scanner 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 修饰方法格式如下： 123修饰符 final 返回值类型 方法名(参数列表)&#123; //方法体&#125; 重写被 final修饰的方法，编译时就会报错。 修饰变量 局部变量——基本类型 基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下： 12345678910111213141516public class FinalDemo1 &#123; public static void main(String[] args) &#123; // 声明变量，使用final修饰 final int a; // 第一次赋值 a = 10; // 第二次赋值 a = 20; // 报错,不可重新赋值 // 声明变量，直接赋值，使用final修饰 final int b = 10; // 第二次赋值 b = 20; // 报错,不可重新赋值 &#125;&#125; 思考，如下两种写法，哪种可以通过编译？ 写法1： 12345final int c = 0;for (int i = 0; i &lt; 10; i++) &#123; c = i; System.out.println(c);&#125; 写法2： 1234for (int i = 0; i &lt; 10; i++) &#123; final int c = i; System.out.println(c);&#125; 根据 final 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。 局部变量——引用类型 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下： 1234567891011public class FinalDemo2 &#123; public static void main(String[] args) &#123; // 创建 User 对象 final User u = new User(); // 创建 另一个 User对象 u = new User(); // 报错，指向了新的对象，地址值改变。 // 调用setName方法 u.setName(\"张三\"); // 可以修改 &#125;&#125; 成员变量 成员变量涉及到初始化的问题，初始化方式有两种，只能二选一： 显示初始化； 1234public class User &#123; final String USERNAME = \"张三\"; private int age;&#125; 构造方法初始化。 12345678public class User &#123; final String USERNAME ; private int age; public User(String username, int age) &#123; this.USERNAME = username; this.age = age; &#125;&#125; 被final修饰的常量名称，一般都有书写规范，所有字母都大写。 第二章 权限修饰符2.1 概述在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， public：公共的。 protected：受保护的 default：默认的 private：私有的 2.2 不同权限的访问能力 public protected default（空的） private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。 编写代码时，如果没有特殊的考虑，建议这样使用权限： 成员变量使用private ，隐藏细节。 构造方法使用public ，方便创建对象。 成员方法使用public ，方便调用方法。 小贴士：不加权限修饰符，其访问能力与default修饰符相同 第三章 内部类1.1 概述什么是内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 成员内部类 成员内部类 ：定义在类中方法外的类。 定义格式： 12345class 外部类 &#123; class 内部类&#123; &#125;&#125; 在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类Car 中包含发动机类Engine ，这时，Engine就可以使用内部类来描述，定义在成员位置。 代码举例： 12345class Car &#123; //外部类 class Engine &#123; //内部类 &#125;&#125; 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 创建内部类对象格式： 1外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 访问演示，代码如下： 定义类： 12345678910111213141516171819202122public class Person &#123; private boolean live = true; class Heart &#123; public void jump() &#123; // 直接访问外部类成员 if (live) &#123; System.out.println(\"心脏在跳动\"); &#125; else &#123; System.out.println(\"心脏不跳了\"); &#125; &#125; &#125; public boolean isLive() &#123; return live; &#125; public void setLive(boolean live) &#123; this.live = live; &#125;&#125; 定义测试类： 123456789101112131415161718public class InnerDemo &#123; public static void main(String[] args) &#123; // 创建外部类对象 Person p = new Person(); // 创建内部类对象 Heart heart = p.new Heart(); // 调用内部类方法 heart.jump(); // 调用外部类方法 p.setLive(false); // 调用内部类方法 heart.jump(); &#125;&#125;输出结果:心脏在跳动心脏不跳了 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。 比如，Person$Heart.class 1.2 匿名内部类【重点】 匿名内部类 ：是内部类的简化写法。它的本质是一个带具体实现的 父类或者父接口的 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 前提匿名内部类必须继承一个父类或者实现一个父接口。 格式1234567new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 使用方式以接口为例，匿名内部类的使用，代码如下： 定义接口： 123public abstract class FlyAble&#123; public abstract void fly();&#125; 创建匿名内部类，并调用： 12345678910111213141516public class InnerDemo &#123; public static void main(String[] args) &#123; /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble()&#123; public void fly() &#123; System.out.println(\"我飞了~~~\"); &#125; &#125;; //调用 fly方法,执行重写后的方法 f.fly(); &#125;&#125; 通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下： 123456789101112131415161718public class InnerDemo2 &#123; public static void main(String[] args) &#123; /* 1.等号右边:定义并创建该接口的子类对象 2.等号左边:是多态,接口类型引用指向子类对象 */ FlyAble f = new FlyAble()&#123; public void fly() &#123; System.out.println(\"我飞了~~~\"); &#125; &#125;; // 将f传递给showFly方法中 showFly(f); &#125; public static void showFly(FlyAble f) &#123; f.fly(); &#125;&#125; 以上两步，也可以简化为一步，代码如下： 12345678910111213141516public class InnerDemo3 &#123; public static void main(String[] args) &#123; /* 创建匿名内部类,直接传递给showFly(FlyAble f) */ showFly( new FlyAble()&#123; public void fly() &#123; System.out.println(\"我飞了~~~\"); &#125; &#125;); &#125; public static void showFly(FlyAble f) &#123; f.fly(); &#125;&#125; 第四章 引用类型用法总结实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。 4.1 class作为成员变量在定义一个类Role（游戏角色）时，代码如下： 12345class Role &#123; int id; // 角色id int blood; // 生命值 String name; // 角色名称&#125; 使用int 类型表示 角色id和生命值，使用String 类型表示姓名。此时，String本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给Role 增加武器，穿戴装备等属性，我们将如何编写呢？ 定义武器类，将增加攻击能力： 1234class Weapon &#123; String name； // 武器名称 int hurt； // 伤害值 &#125; 定义穿戴盔甲类，将增加防御能力，也就是提升生命值： 1234class Armour &#123; String name；// 装备名称 int protect；// 防御值 &#125; 定义角色类： 1234567891011121314151617181920212223242526272829303132333435class Role &#123; int id； int blood； String name； // 添加武器属性 Weapon wp； // 添加盔甲属性 Armour ar； // 提供get/set方法 public Weapon getWp() &#123; return wp; &#125; public void setWeapon(Weapon wp) &#123; this.wp = wp; &#125; public Armour getArmour() &#123; return ar; &#125; public void setArmour(Armour ar) &#123; this.ar = ar; &#125; // 攻击方法 public void attack()&#123; System.out.println(\"使用\"+ wp.getName() +\", 造成\"+wp.getHurt()+\"点伤害\"); &#125; // 穿戴盔甲 public void wear()&#123; // 增加防御,就是增加blood值 this.blood += ar.getProtect(); System.out.println(\"穿上\"+ar.getName()+\", 生命值增加\"+ar.getProtect()); &#125; &#125; 测试类： 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; // 创建Weapon 对象 Weapon wp = new Weapon(\"屠龙刀\" , 999999); // 创建Armour 对象 Armour ar = new Armour(\"麒麟甲\",10000); // 创建Role 对象 Role r = new Role(); // 设置武器属性 r.setWeapon(wp); // 设置盔甲属性 r.setArmour(ar); // 攻击 r.attack(); // 穿戴盔甲 r.wear(); &#125;&#125;输出结果:使用屠龙刀,造成999999点伤害穿上麒麟甲 ,生命值增加10000 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。 4.2 interface作为成员变量接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role中，可以增加接口作为成员变量，来设置不同的技能。 定义接口： 1234// 法术攻击public interface FaShuSkill &#123; public abstract void faShuAttack();&#125; 定义角色类： 12345678910111213public class Role &#123; FaShuSkill fs; public void setFaShuSkill(FaShuSkill fs) &#123; this.fs = fs; &#125; // 法术攻击 public void faShuSkillAttack()&#123; System.out.print(\"发动法术攻击:\"); fs.faShuAttack(); System.out.println(\"攻击完毕\"); &#125;&#125; 定义测试类： 1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) &#123; // 创建游戏角色 Role role = new Role(); // 设置角色法术技能 role.setFaShuSkill(new FaShuSkill() &#123; @Override public void faShuAttack() &#123; System.out.println(\"纵横天下\"); &#125; &#125;); // 发动法术攻击 role.faShuSkillAttack(); // 更换技能 role.setFaShuSkill(new FaShuSkill() &#123; @Override public void faShuAttack() &#123; System.out.println(\"逆转乾坤\"); &#125; &#125;); // 发动法术攻击 role.faShuSkillAttack(); &#125;&#125;输出结果:发动法术攻击:纵横天下攻击完毕发动法术攻击:逆转乾坤攻击完毕 我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。 接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。 4.3 interface作为方法参数和返回值类型当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。ArrayList类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见List 接口作为参数或者返回值类型时，当然可以将ArrayList的对象进行传递或返回。 请观察如下方法：获取某集合中所有的偶数。 定义方法： 1234567891011121314151617public static List&lt;Integer&gt; getEvenNum(List&lt;Integer&gt; list) &#123; // 创建保存偶数的集合 ArrayList&lt;Integer&gt; evenList = new ArrayList&lt;&gt;(); // 遍历集合list,判断元素为偶数,就添加到evenList中 for (int i = 0; i &lt; list.size(); i++) &#123; Integer integer = list.get(i); if (integer % 2 == 0) &#123; evenList.add(integer); &#125; &#125; /* 返回偶数集合 因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类, 所以evenList可以返回 */ return evenList;&#125; 调用方法： 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; // 创建ArrayList集合,并添加数字 ArrayList&lt;Integer&gt; srcList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; srcList.add(i); &#125; /* 获取偶数集合 因为getEvenNum方法的参数是List,而ArrayList是List的子类, 所以srcList可以传递 */ List list = getEvenNum(srcList); System.out.println(list); &#125;&#125; 接口作为参数时，传递它的子类对象。 接口作为返回值类型时，返回它的子类对象。 第五章 综合案例——发红包【界面版】红包文化源远流长。从古时的红色纸包，到手机App中的手气红包，红包作为一种独特的中华文化传承至今。之前的课程中，我们也编写过程序，模拟发普通红包。那么今天，我们将整合基础班课程中所有的技术和知识，编写一个带界面版的 发红包 案例。 目前，我们尚未学习过任何与界面相关的类。所以，界面相关代码，已经给出。请运用所学技术分析并使用。 案例需求分析并使用已给出的类，编写程序，设置红包类型。 小贴士 红包类型： 普通红包：金额均分。不能整除的，余额添加到最后一份红包中。 手气红包：金额随机。各个红包金额累和与总金额相等。 红包场景： ​ 此案例是模拟群主给群成员发红包，群主自己打开最后一个红包的场景。 案例分析已知的类： RedPacketFrame ：一个抽象类，包含了一些属性，是红包案例的页面。 1234567891011121314151617181920212223public abstract class RedPacketFrame extends JFrame &#123; /* ownerName : 群主名称 */ public String ownerName = \"谁谁谁谁\"; /* openMode : 红包的类型 [普通红包/手气红包] */ public OpenMode openMode = null; /** * 构造方法:生成红包界面. * @param title 页面的标题. */ public RedPacketFrame(String title) &#123; super(title); init();// 页面相关的初始化操作 &#125; /* set方法 */ public void setOwnerName(String ownerName) &#123; this.ownerName = ownerName; &#125; public void setOpenMode(OpenMode openMode) &#123; this.openMode = openMode; &#125;&#125; OpenMode ：一个接口，包含一个分配方法，用来指定红包类型。 12345678910public interface OpenMode &#123; /** * @param totalMoney 总金额,单位是\"分\"。总金额为方便计算,已经转换为整数,单位为分。 * @param count 红包个数 * @return ArrayList&lt;Integer&gt; 元素为各个红包的金额值,所有元素的值累和等于总金额. * * 请将totalMoney,分成count分,保存到ArrayList&lt;Integer&gt;中,返回即可. */ public abstract ArrayList&lt;Integer&gt; divide(int totalMoney, int count);&#125; 案例实现环境搭建： 创建项目：名称自定义，建议为RedPacketDemo 。 导入图片：将pic目录，导入项目中，与src 目录平级。 导入已知类：在src下创建一个包，名字自定义，建议为known ，将类 RedPacketFrame、接口OpenMode 拷入。 代码实现： 定义RedPacket 类，继承RedPacketFrame ，代码如下： 12345public class RedPacket extends RedPacketFrame &#123; public RedPacket(String title) &#123; super(title); &#125;&#125; 定义测试类，创建RedPacket 对象，代码如下： 12345public class RedPacketTest &#123; public static void main(String[] args) &#123; RedPacket rp = new RedPacket(\"大红包\"); &#125;&#125; 运行代码，打开一个发红包的页面。可以输入总金额，红包个数，留言信息。 点击塞钱进红包按钮，跳转到下一页面。 点击谁谁谁谁和開，两个区域，发现可以设置两项内容： 谁谁谁谁：表示群主在发红包，可设置群主名称。通过此方法，熟悉类结构，直接调用父类的方法。 開 ：表示打开红包，跳转到下一页面。但是开启之前，必须先设置红包的类型，否则无法开启。 RedPacket 对象，设置群主名称。 setOwnerName（String ownerName） ，是字符串作为参数。我们只需要传递一个字符串即可。 12345678public class RedPacketTest &#123; public static void main(String[] args) &#123; // 创建红包对象 RedPacket rp = new RedPacket(\"大红包\"); // 设置群主名称 rp.setOwnerName(\"我是群大大\"); &#125;&#125; RedPacket 对象，设置红包类型。 setOpenMode(OpenMode openMode) ，是接口作为参数。我们必须定义接口的实现类，重写接口中方法，并传递实现类对象到setOpenMode方法中，方可设置完成。再观察接口： 12345678910public interface OpenMode &#123; /** * @param totalMoney 总金额,单位是\"分\"。总金额为方便计算,已经转换为整数,单位为分。 * @param count 红包个数 * @return ArrayList&lt;Integer&gt; 元素为各个红包的金额值,所有元素的值累和等于总金额. * * 请将totalMoney,分成count分,保存到ArrayList&lt;Integer&gt;中,返回即可. */ public abstract ArrayList&lt;Integer&gt; divide(int totalMoney, int count);&#125; 普通红包，打开方式Common，代码如下： 1234567891011121314151617181920212223public class Common implements OpenMode &#123; @Override public ArrayList&lt;Integer&gt; divide(int totalMoney, int count) &#123; // 创建保存各个红包金额的集合 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 定义循环次数,总个数-1次 int time = count - 1; // 一次计算,生成平均金额 int money = totalMoney / count; // 循环分配 for (int i = 0; i &lt; time; i++) &#123; // 添加到集合中 list.add(money); // 总金额扣除已分配金额 totalMoney -= money; &#125; // 剩余的金额,为最后一个红包 list.add(totalMoney); System.out.println(\"普通红包金额:\" + list); // 返回集合 return list; &#125;&#125; 发普通红包，代码如下： 12345678910public class RedPacketTest &#123; public static void main(String[] args) &#123; // 创建红包对象 RedPacket rp = new RedPacket(\"大红包\"); // 设置群主名称 rp.setOwnerName(\"我是群大大\"); // 设置红包类型 rp.setOpenMode(new Common()); // 普通红包 &#125;&#125; 手气红包【重点】 本质上，手气红包就是把总金额totalMoney 随机分成指定的count份，所以必须规定每一份金额的取值范围。如果范围太小，可能导致后分配红包金额特别大。反之范围太大，可能导致后分配红包金额为0，不够分。可见，取值范围的定义规则，是手气红包的关键所在。 我们规定：每一份随机金额范围（除最后一份），最小值为1，最大值为当前剩余平均金额的2倍 ，单位为”分”。 计算公式： 1当前剩余平均金额 = 剩余总金额 / 剩余红包个数 举例：总额为50元，发5个红包。 当前剩余平均金额（取整数） 红包范围 随机金额（假设） 第一个红包 50 / 5 = 10 0.01~20 5 第二个红包 45 / 4 = 11 0.01~22 20 第三个红包 25 / 3. = 8 0.01~16 10 第四个红包 15 / 2 = 7 0.01~14 12 第五个红包（最后一个） 无需计算 剩余金额 3 小贴士：为方便表格中进行运算，此处，单位为”元”。程序中，建议换算为”分”进行运算。 手气红包，打开方式Lucky ，代码如下： 1234567891011121314151617181920212223242526272829public class Lucky implements OpenMode &#123; @Override public ArrayList&lt;Integer&gt; divide(int totalMoney, int count) &#123; // 创建保存各个红包金额的集合 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 定义循环次数,总个数-1次 int time = count - 1; // 创建随机数对象 Random random = new Random(); // 循环分配 for (int i = 0; i &lt; time; i++) &#123; /* * 每次重新计算,生成随机金额 * 随机范围: totalMoney / count * 2,totalMoney不断的减少, * count也不断的减少,所以这是一个可变化的范围. */ int money = random.nextInt(totalMoney / count * 2) + 1; // 金额添加到集合 list.add(money); // 总金额扣除已分配金额 totalMoney -= money; // 红包个数-1 count--; &#125; // 剩余的金额,为最后一个红包 list.add(totalMoney); return list; &#125;&#125; 发手气红包，代码如下： 1234567891011public class RedPacketTest &#123; public static void main(String[] args) &#123; // 创建红包对象 RedPacket rp = new RedPacket(\"大红包\"); // 设置群主名称 rp.setOwnerName(\"我是群大大\"); // 设置红包类型,二选一 // rp.setOpenMode(new Common()); // 普通红包 rp.setOpenMode(new Lucky()); // 手气红包 &#125;&#125; 案例总结通过发红包 案例，你都学到了什么呢？请你思考如下问题： 基础语法，你是否清晰？ 一些基本的类的方法，你是否能够调用？ 案例中哪里体现了继承，继承的作用是什么？ 接口作为参数，如何使用？ 接口作为成员变量，如何使用？ 如何简化接口的使用方式？","categories":[],"tags":[]},{"title":"","slug":"MD/idea/active code","date":"2018-06-20T01:41:10.000Z","updated":"2018-06-20T03:08:04.000Z","comments":true,"path":"2018/06/20/MD/idea/active code/","link":"","permalink":"http://io.stelawliet.top/2018/06/20/MD/idea/active code/","excerpt":"","text":"/Applications/IntelliJ IDEA.app/Contents/ 1K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==","categories":[],"tags":[]},{"title":"","slug":"MD/协议编号：ITCAST-2018-cloud2-134142","date":"2018-06-19T07:15:14.000Z","updated":"2018-06-19T07:15:14.000Z","comments":true,"path":"2018/06/19/MD/协议编号：ITCAST-2018-cloud2-134142/","link":"","permalink":"http://io.stelawliet.top/2018/06/19/MD/协议编号：ITCAST-2018-cloud2-134142/","excerpt":"","text":"协议编号：ITCAST-2018-cloud2-134142 黑马程序员培训协议 ​ 甲方：江苏传智播客教育科技股份有限公司 ​ 上海传智播客教育培训有限公司 ​ 乙方(学员)：赵子齐 ​ 身份证号码：532901199512232916 ​ 电话：17612708700 ​ 通讯地址：大理白族自治州大理市海东镇文笔村委会文笔村3社6号 ​ 乙方自愿报名参加江苏传智播客教育科技股份有限公司（以下简称“传智播客公司”）运营 、上海传智播客教育培训有限公司（以下简称“传智播客分（子）公司”）辅助教学的传智播客.黑 马程序员培训班，为明确双方的权利与义务，经双方友好协商，就培训相关事宜达成如下协议： 第一条 培训条款 ​ 1.1 乙方参加学习上海黑马云计算大数据就业6期（20180619面授）课程 ，培训时间为：2018年 06月19日至 2019年01月23日（具体培训时间以实际上课时间为准） 。 ​ 1.2 本培训课程标准费用为 21980元整(￥贰万壹仟玖佰捌拾元整)，根据甲方现有的学费优惠政策 （具体优惠政策以甲方相关规定为准），乙方实际应交纳的培训费用（应交学费） 为21980元整(￥ 贰万壹仟玖佰捌拾元整)。上述费用由传智播客公司全部代为收取，收取后代乙方向传智播客分（子 ）公司支付一定比例的费用作为其辅助教学的费用,具体比例由传智播客公司与传智播客分(子)公司 另行约定。如发生退费，由传智播客公司统一向乙方支付（乙方使用贷款方式缴纳学费的，退费方 式按照甲乙双方与相关方的约定处理），传智播客公司及传智播客分（子）公司内部协商代退费事 宜，与乙方无关。 ​ 1.3 参加培训期间，食宿均由乙方自理，甲方不予负责。 ​ 1.4 培训地点：上海 第二条 培训费支付条款 ​ 2.1 乙方必须在开课前向甲方一次性交清培训费。 ​ 2.2 培训费支付方式：刷卡、转账（含电子支付）。上述培训费用必须支付到甲方公司账户，如 乙方将上述费用支付给个人（包括甲方员工）的，视为乙方未缴费。 ​ 2.3 培训课程结束后对乙方已经支付的学费不予退还。 第三条 培训费逾期规定 ​ 3.1 乙方开课前未交清培训费的，视为乙方违约，甲方有权拒绝为乙方提供培训服务。 第四条 就业 ​ 4.1 乙方自培训结束之日起，须全力完成就业工作。 ​ 4.2 乙方就业后，必须在三个工作日内向甲方提供所就业的时间、单位名称、薪资福利待遇及地 址等信息。 第五条 其他 ​ 5.1 乙方须如实提供相应的照片、身份证、个人居住地址、手机号码、紧急联系人及联系方式等 信息，同时保证所提供信息完全属实。上述信息如有变更，须在三日内提供其更新的信息给甲方 ，如未及时提供，甲方有权联系乙方亲属。 ​ 乙方使用贷款方式缴纳学费的，乙方授权甲方向相关方提供其个人资料，以便相关方进行审核或 借款催收。 ​ 5.2 乙方自参加培训班时起，有义务遵守甲方的教学管理规章制度，不得有影响班级教学和影响 他人学习的不良行为，如出现严重违反规章制度情形，视为乙方违约，甲方有权终止对乙方提供培 训服务,乙方已缴纳费用将不予退还。相关教学管理规章制度详情见附件《入学协议》，该附件为本 协议的有效组成部分。 ​ 5.3 乙方有义务主动配合老师完成教学或其他教育教学工作，按照甲方的规章制度、教学大纲全 力认真完成培训期间的学习。 ​ 5.4 乙方不可自行将学习名额转让给他人。 ​ 5.5 如甲方发现乙方为与甲方有竞争关系公司的员工，或乙方与上述公司具有特殊关系可能导致 商业秘密泄露的，甲方有权随时终止本培训协议。 ​ 5.6 乙方参加培训所需的各种软件，由乙方自行购买、安装、使用，如果因相关软件侵犯第三方 知识产权的，由乙方自行负责，甲方不承担责任。 ​ 5.7 甲方提供的培训为高强度培训，不适合患有或曾经患有高血压、心脏病、抑郁症或其他精神 类疾病、传染性疾病及其他相关病症的人群学习。乙方未向甲方提前作书面说明的，则签署本协议 即视为乙方确认无上述疾病或病史并且能适应培训强度。乙方在培训期间发病或因此产生其他后果 的，因此产生的责任由乙方自行承担，甲方不承担任何责任。 第六条 转班、重读、退学、休学规定 ​ 6.1 转班 ​ 对于遵守甲方相关规定，但由于不可抗力因素造成短期内不能来校学习的，乙方可以申请转班 且只能办理一次转班，但需提前办理转班手续且需要遵守以下约定： ​ （1）乙方提出转班时，尚未学习的课时不得少于20个课时（不包含20课时）。 ​ （2）乙方转班申请得到批准后，乙方应在不可抗力事件发生之日起6个月内向甲方提出后续就 读申请，如果在规定期间内没有提出申请，视为放弃继续就读，已缴纳费用不予退还。 ​ （3）乙方申请继续就读的，需通过入班考核方可进入目标班级（乙方所报首个就业班级自开 班之日起1年之内的同校区、同学科班级），目标班级的学时为其原就读班级的剩余学时，已学课时 不允许重复学习。 ​ （4）甲方批准乙方转班申请后，将告知乙方转班就读时间，如果乙方仍未按要求的时间报到 进班，则视为自动放弃培训，已缴纳的所有费用不予退还。因甲方原因导致无法开班，甲方应提前 告知乙方，并协商后续就读事宜。 ​ （5）乙方申请转班后，不得再申请重读和退费。 ​ 6.2 重读 ​ 对于遵守甲方相关规定，认真学习，但由于不可抗力因素造成短期内不能来校学习的，乙方可 申请重读且只能申请一次，但需提前办理重读手续且需要遵守以下约定： ​ （1）乙方在课程学习过程中出现下列情形之一的：累计旷课2天；累计迟到、早退合计5次 ；累计请事假3次，甲方有权取消乙方重读资格。 ​ （2）乙方重读需缴纳500元重读费，学员缴纳费用后放弃重读的，应于后续拟就读班级开班前 五个工作日通知甲方，则甲方将上述重读费用退还乙方，逾期未通知的，则该重读费不予退还。无 论乙方因任何原因放弃重读的，原课程学费均不予退还。 ​ （3）乙方申请重读时，如遇目标班级人数（新生及升级学员人数）达到教室容量上限，甲方 有权将乙方的重读时间顺延到下期开班时间。 ​ （4）重读仅限同学科、同模式、同一校区，申请重读后不得再申请转班。 ​ （5）乙方重读应在不可抗力因素发生之日起6个月内向甲方提出申请，逾期视为放弃重读。乙 方重读仅限其所报首个就业班级开班之日起2年之内的班级。 ​ （6）甲方收到申请后，有义务告知乙方重读时间，如果乙方未按要求的时间报到进班，则视 为自动放弃视为放弃重读。因甲方原因导致无法开班，甲方应提前告知乙方，并协商后续就读事宜 。 ​ 6.3 休学 ​ 6.3.1对于遵守甲方相关规定，认真学习，但遇以下特殊情况，不能继续参加本期学习，并且无 法确定明确转入班级的，可申请休学。 ​ （1）身体突发疾病，短时间无法治愈的； ​ （2）家庭直系成员突发变故，需要本人回去处理，长时间无法坚持学习的； ​ （3）妊娠期或哺乳期无法坚持学习的； ​ （4）回校参加毕业设计； ​ 6.3.2乙方在课程学习过程中出现下列情形之一的：累计旷课2天；累计迟到、早退合计5次；累 计请事假3次，甲方有权取消乙方休学资格。 ​ 6.3.3乙方提出休学时，尚未学习的课时不得少于20个课时（不包含20课时），出示相关证明材 料，并填写《申请单》，由甲方审批通过后方可办理休学手续。 ​ 6.3.4乙方休学归来，需通过入班考核方可进入目标班级（乙方所报首个就业班级自开班之日起 1年之内的同学科班级），目标班级的学时为其原就读班级的剩余学时，已学课时不允许重复学习。 ​ 6.3.5乙方在甲方安排的课程学习期间仅允许申请一次休学，申请休学后不得再申请转班或重读 。 ​ 6.3.6乙方在所报首个就业班级开班之日起6个月内可向甲方提出继续就读申请，逾期未提出 ，视为放弃继续就读，已交所有费用均不予退还。 ​ 6.3.7甲方收到申请后，有义务告知乙方进班时间，如果乙方未按要求的时间报到进班，则视为 自动放弃再次就读资格，已缴纳所有费用均不予退还。因甲方原因导致无法开班，甲方应提前告知 乙方，并协商后续就读事宜。 ​ 6.4 退学 ​ 6.4.1 开课后，无特殊情况，不允许退学。 ​ 6.4.2 开课7天内遇以下特殊情况，可申请退学。 ​ 经三级甲等医院确诊，患有精神病、癫痫、麻疯、传染性疾病或其他严重疾病，不能坚持学 习或遇不可抗力因素造成无法继续学习。 ​ 对于校方批准退学的、符合退学条件的学员，乙方须立即支付已学习课程的培训费，方可办 理退学。已学课程的培训费金额计算公式：已学课程培训费=(应交学费/总标准课时) * 已学标准课时 * 130%，标准课时是指甲方在乙方正式开班前确认的该课程学时，对于开班后甲方临时增加的课程 不计入标准课时。例如：某学员应交学费2000元，开学前一次性付清（即已收学费2000元），总标 准课时27天，学习2天标准课时后因病退学，则已学课程培训费=（2000/ 27 ) 2 130%=193元；退退 费金额=2000-193=1807元。 ​ 对于不符合退学条件的学员，乙方已缴纳费用不予退还。 ​ 6.4.3开课7天后，乙方不允许以任何理由退学、退费，遇以上特殊情况只可做转班处理。 第七条 协议的终止 ​ 7.1 自双方履行完毕各自义务之日，本协议自动失效。 ​ 7.2 双方确认，本协议的签署、生效和履行以不违反中华人民共和国的法律法规为前提。如本协 议中任意一条款违反相关法律法规，则该条款将被视为无效，但并不影响本协议其他条款的效力。 ​ 7.3 由于无法预见的不可抗力事件，如战争、地震、罢工、动乱、网络黑客的侵犯致使网络不能 正常运行等事件发生，导致任何一方不能执行协议中的义务时，应及时通知对方，对方可根据实际 情况部分或全部免除其应承担责任和义务。 第八条 保密条款 ​ 8.1 乙方有义务对在培训过程中获悉的甲方教材、教案、讲义、习题、案例、教学视频、PPT等教 学产品或其他作品进行保密。除个人学习使用外，不得以任何方式透露给任何第三方。 ​ 8.2 乙方有义务对获悉的甲方（包括甲方关联公司）的其他商业机密、人事信息、薪资标准、培 训信息、教学模式等保密，不得任何方式透露给任何第三方。 ​ 8.3 乙方违反上述保密义务给甲方造成损失的，由乙方负责赔偿，甲方保留追究乙方法律责任的 权利。 第九条 双方共同商定 ​ 9.1 本协议自甲方盖章、乙方签字之日起生效。双方认可以电子合同方式进行签约。 ​ 9.2 对本协议的所有条款，乙方均有权要求甲方进行解释说明，甲方有义务根据乙方要求对涉及 到乙方利益的条款进行解释，但本协议一经乙方签署，即视为乙方对本协议条款已充分理解，甲方 已履行解释说明义务。 ​ 9.3 本协议条款履行中如发生纠纷，各方应协商解决，协商不成，应当将争议提交到江苏省宿迁 市沭阳县人民法院通过诉讼方式解决。 ​ 附件：《入学协议》 ​ 甲方（盖章）： ​ 签署日期：2018年06月19日 ​ 乙方（签字）：赵子齐 ​ 签署日期：2018年06月19日 ​ 附件 入学协议 ​ 乙方自愿报名参加甲方的培训课程，为进一步明确甲乙双方的权利与义务，经甲乙双方友好协 商，就入学相关事宜达成如下协议： 第一条 甲方的权利和义务 ​ 1.1 甲方负责为乙方提供教学场地、教学设施和相应的教学设备，并负责进行维护，保证教学工 作的正常开展。 ​ 1.2 甲方制定规章制度及安全注意事项，且有权利和义务对学员进行安全教育、监管和保护，在 可预见范围内采取必要的安全措施。 ​ 1.3 甲方有义务对乙方在学习纪律及学习成绩方面进行管理及考核。 ​ 1.4 甲方不负责乙方的食宿，因食宿问题产生的相关责任甲方不予承担。 ​ 1.5 乙方违反本协议的，甲方有权要求乙方承担相应责任，直至终止向乙方提供培训服务。因乙 方违约行为导致培训终止的，先付费学员培训费不予退还，后付费学员应支付培训费用。 ​ 1.6 非因甲方原因导致的乙方人身损害及财产损失的，甲方不承担任何责任。 第二条 乙方的权利和义务 ​ 2.1 乙方有义务遵守国家的法律法规、社会公德。 ​ 2.2 乙方自行解决食宿，注意个人住宿安全及饮食卫生。 ​ 2.3 培训过程中出现不可预料的问题，应及时联系甲方班主任或由甲方指定的相关工作人员。 ​ 2.4 如甲方工作人员以外的人员对乙方造成人身损害的（包括学员之间相互造成人身损害），由 侵权人承担侵权责任，甲方不承担任何责任。 ​ 2.5 乙方同意遵守甲方如下的管理制度，发生如下情形的，乙方自愿承担相应责任。 序号 违规情形 承担责任 1 在上课期间吃饭、吃零食 扣2分/次 2 进入教学区（包含休息、自习期间进入教学区域）未佩戴胸卡或园区进门卡 扣2分/次 3 衣着不整洁，穿拖鞋进入教学区 扣2分/次 4 桌面残留食物垃圾、教学区内随地扔垃圾，未将垃圾放到指定位置 扣2分/次 5 上课（含自习课、练习课）大声喧哗，影响他人 扣3分/次 6 迟到、早退（超出规定到教室时间即为迟到，人不在、仅电脑在教室也视为 迟到） 扣3分/次 7 不服从班级学习、工作安排(如值日，演讲，排座位等) 扣3分/次 8 上课期间睡觉或进行打水、取快递、剪指甲等与学习无关的事项 扣5分/次 9 考试作弊或不交作业 扣5分/次 10 损坏公物 扣5分/次（损坏的公 物仍需照价赔偿） 11 请事假（病假无就诊证明的视为事假，毕业答辩等特殊情形单独报批，每名 学员学习期间仅有一次特殊事项请假的机会） 扣5分/天 ​ 乙方被扣分数达到一定分值的处理理措施如下:扣除1—10分，班主任谈话；扣11—20分，每次扣分 甲方学工部/教导处谈话；扣除21—30分，每次扣分班主任联系家长，通报所在学校或单位；扣除 ≥40分，甲方有权终止对乙方的培训服务，提前解除合同，并不予退还任何费用，乙方是后付费学 员的，应足额支付培训费。 ​ 2.6 听课证遗失须向班主任申请补办，补办费用为10元； ​ 2.7 乙方有义务保管好甲方提供的教学设备，如有损坏，乙方必须按照市场价向甲方进行赔偿 ，不得给租用的电脑私设密码，一旦电脑出现损坏，必须按照市场价向甲方进行赔偿。 ​ 2.8 乙方在培训期间，须保管好个人物品，贵重物品要随身携带，如发生丢失，责任自负。 ​ 2.9 乙方迟到、早退合计超过N次（N=培训总天数*10%）；旷课天数合计超过N天（N=培训总天 数5%），或请事假天数合计超过N天（N=培训总天数10%），以上三种情况出现任意一种，甲方 有权终止对乙方的培训服务，提前解除合同，并不予退还任何费用，乙方是后付费学员的，应足额 支付培训费。 第三条 其他 ​ 3.1 甲方的所有培训课程属于高强度培训，不适合有高血压、心脏病、癫痫、其他传染性疾病等 病史及一些遗传病史的人员学习，因隐瞒病史所产生的一切后果由乙方全权负责。 ​ 3.2 乙方在读期间快递、邮件等由本人领取，甲方不代为收取或代为保管。 第四条 协议的终止 ​ 4.1 自双方履行完毕各自义务之日，本协议自动失效。 第五条 保密条款 ​ 5.1 乙方有义务对在培训过程中获悉的甲方教材、教案、讲义、习题、案例、教学视频、PPT等教 学产品或其他作品进行保密。除个人学习使用外，不得以任何方式（包括翻录）透露给任何第三方 。 12 未经允许私自连接外网在教学区内浏览与学习无关网页、看电影、打游戏、 玩手机 第一次扣6分并签署 保证书。第二次扣 16分，全校区通报批 评。第三次扣18分 ，（即扣满40分，将 直接予以开除。） 13 迟到、早退超过20分钟或其他未请假旷课行为 扣10分/次 14 无端指责、调侃老师，当面顶撞、恶意诋毁老师，或与老师发生语言冲突 扣20分/次 15 在课堂上故意捣乱，不听班主任老师劝解,影响其他同学学习 扣20分/次 16 在教学区域（含厕所）吸烟，情节严重拒不整改者 扣40分/次 17 发生打架斗殴或盗窃等违法情形 扣40分/次 ​ 5.2 乙方有义务对获悉的甲方（包括甲方关联公司）的其他商业机密、人事信息、薪资标准、培 训信息、教学模式等保密，不得任何方式透露给任何第三方。 ​ 5.3 乙方违反上述保密义务给甲方造成损失的，由乙方负责按照合同费用的两倍向甲方支付赔偿 ，甲方保留追究乙方法律责任的权利。 第六条 双方共同商定 ​ 6.1 本协议为双方签署的《培训协议》或《培训与就业协议》的组成部分。 ​ 6.2 对本协议的所有条款，乙方均有权要求甲方进行解释说明，甲方有义务根据乙方要求对涉及 到乙方利益的条款进行解释，但本协议一经乙方签署，即视为乙方对本协议条款已充分理解，甲方 已履行解释说明义务。 签订合同","categories":[],"tags":[]},{"title":"","slug":"Java/Internet/分层结构","date":"2018-06-17T11:26:48.000Z","updated":"2018-06-17T11:27:55.000Z","comments":true,"path":"2018/06/17/Java/Internet/分层结构/","link":"","permalink":"http://io.stelawliet.top/2018/06/17/Java/Internet/分层结构/","excerpt":"","text":"应用层 传输层 网络层 数据链路层","categories":[],"tags":[]},{"title":"JVM类加载过程","slug":"Java/JVM/类加载","date":"2018-06-14T12:47:51.000Z","updated":"2018-07-04T11:43:29.000Z","comments":true,"path":"2018/06/14/Java/JVM/类加载/","link":"","permalink":"http://io.stelawliet.top/2018/06/14/Java/JVM/类加载/","excerpt":"","text":"类加载过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。 加载加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。注意，这里第 1 条中的二进制字节流并不只是单纯地从 Class 文件中获取，比如它还可以从 Jar 包中获取、从网络中获取（最典型的应用便是 Applet）、由其他文件生成（JSP 应用）等。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。” 摘录来自: 极客学院. “深入理解 Java 虚拟机”。 iBooks. 类加载过程 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始 化、使用和卸载七个阶段。它们开始的顺序如下图所示： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初 始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是 为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而 不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激 活另一个阶段。 这里简要说明下 Java 中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对 Java 来 说，绑定分为静态绑定和动态绑定： • 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对 Java，简 单的可以理解为程序编译期的绑定。Java 当中的方法只有 final，static，private 和构造方法是前期绑定 的。 • 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在 Java 中，几乎所有 的方法都是后期绑定的。 下面详细讲述类加载过程中每个阶段所做的工作。 加载 加载 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： • 通过一个类的全限定名来获取其定义的二进制字节流。 • 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 • 在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。 第 6 章 类加载机制 | 39 注意，这里第 1 条中的二进制字节流并不只是单纯地从 Class 文件中获取，比如它还可以从 Jar 包中获取、从网 络中获取（最典型的应用便是 Applet）、由其他文件生成（JSP 应用）等。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强 的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也 创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。 说到加载，不得不提到类加载器，下面就具体讲述下类加载器。 类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于类的加载阶段。对于任意 一个类，都需要由它的类加载器和这个类本身一同确定其在就 Java 虚拟机中的唯一性，也就是说，即使两个类 来源于同一个 Class 文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代 表类的 Class 对象的 equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使 用 instanceof 关键字对对象所属关系的判定结果。 站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器： • 启动类加载器：它使用 C++ 实现（这里仅限于 Hotspot，也就是 JDK1.5 之后默认的虚拟机，有很多其他 的虚拟机是用 Java 语言实现的），是虚拟机自身的一部分。 • 所有其他的类加载器：这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.l ang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类： • 启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在 JDK\\jre\\li (JDK 代表 JDK 的安 装目录，下同)下，或被 -Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所 有的 java.* 开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用 的。 • 扩展类加载器：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负 责加载 JDK\\jre\\lib\\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.* 开头的 类），开发者可以直接使用扩展类加载器。 • 应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程 序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 第 6 章 类加载机制 | 40 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JV M 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassL oader，便可以做到如下几点： • 在执行非置信代码之前，自动验证数字签名。 • 动态地创建符合用户特定需要的定制化构建类。 • 从特定的场所取得 java class，例如数据库中和网络中。 事实上当使用 Applet 的时候，就用到了特定的 ClassLoader，因为这时需要从网络上加载 java class，并且要 检查相关的安全信息，应用服务器也大都使用了自定义的 ClassLoader 技术。 这几种类加载器的层次关系如下图所示： 这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当 然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在 JDK1.2 期间被引入并广泛应用于之后几乎所有的 Java 程序中，但它并不是一个强制性的约束模型，而是 Java 设计者们推荐给开发者的一种类的加载器实现方式。 第 6 章 类加载机制 | 41 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是 把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器 中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载 该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是 Java 类随着它的类加载器（说白 了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要。例 如，类java.lang.Object 类存放在 JDK\\jre\\lib 下的 rt.jar 之中，因此无论是哪个类加载器要加载此类，最终都会 委派给启动类加载器进行加载，这边保证了 Object 类在程序中的各种类加载器中都是同一个类。 验证 验证 验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安 全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元 数据的验证、字节码验证和符号引用验证。 • 文件格式的验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，该验证的 主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内 存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 • 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在 不符合 Java 语法规范的元数据信息。 • 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校 验的类的方法在运行时不会做出危害虚拟机安全的行为。 • 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中 发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校 验。 准备 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以 下几点需要注意： • 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一 块分配在 Java 堆中。 • 这里所设置的初始值通常情况下是数据类型默认的零值（如 0、0L、null、false 等），而不是被在 Java 代 码中被显式地赋予的值。 第 6 章 类加载机制 | 42 假设一个类变量的定义为： public static int value = 3； 那么变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 valu e 赋值为 3 的 putstatic 指令是在程序编译后，存放于类构造器 （）方法之中的，所以把 value 赋值为 3 的动作 将在初始化阶段才会执行。 下表列出了 Java 中所有基本数据类型以及 reference 类型的默认零值： 这里还需要注意如下几点： • 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其 赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 • 对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 fi nal 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必 须为其显式地赋值，系统不会为其赋予默认零值。 • 对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使 用，系统都会为其赋予默认的零值，即null。 第 6 章 类加载机制 | 43 • 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零 值。 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 val ue 就会被初始化为 ConstValue 属性所指定的值。 假设上面的类变量 value 被定义为： public static final int value = 3； 编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。回忆上一篇博文中对象被动引用的第 2 个例子，便是这种情况。我们可以理解为 static final 常 量在编译期就将其结果放入了调用它的类的常量池中。 解析 解析 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在 Class 类文件结构一文中已经比较过了符号 引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开 始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之 前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行 时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的 CONSTAN T_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMet hodref_info 四种常量类型。 1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解 析。 2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字 段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接 口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示： 第 6 章 类加载机制 | 44 从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序： class Super{ public static int m = 11; static{ System.out.println(“执行了super类静态语句块”); } } class Father extends Super{ public static int m = 33; static{ System.out.println(“执行了父类静态语句块”); } } class Child extends Father{ static{ System.out.println(“执行了子类静态语句块”); } } public class StaticTest{ public static void main(String[] args){ System.out.println(Child.m); } } 执行结果如下： 执行了super类静态语句块 执行了父类静态语句块 33 如果注释掉 Father 类中对 m 定义的那一行，则输出结果如下： 第 6 章 类加载机制 | 45 执行了super类静态语句块 11 另外，很明显这就是上篇博文中的第 1 个例子的情况，这里我们便可以分析如下：static 变量发生在静态解析阶 段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由 于在子类中没有查找到与 m 相匹配的字段，那么 m 便不会与子类关联在一起，因此并不会触发子类的初始化。 最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范 要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出 现，编译器可能会拒绝编译。如果对上面的代码做些修改，将 Super 改为接口，并将 Child 类继承 Father 类且 实现 Super 接口，那么在编译时会报出如下错误： StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m 都匹配 System.out.println(Child.m); ^ 1 错误 3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步 骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 4、接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。 初始化 初始化 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变 量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变 量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 这里简单说明下()方法的执行规则: 这里简单说明下()方法的执行规则: 1、()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺 序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它 之后的变量，在前面的静态语句中可以赋值，但是不能访问。 2、（）方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类 的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lan g.Object。 3、()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编 译器可以不为这个类生成()方法。 第 6 章 类加载机制 | 46 4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生 成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量 被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 5、虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么 只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类 的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 下面给出一个简单的例子，以便更清晰地说明如上规则： class Father{ public static int a = 1; static{ a = 2; } } class Child extends Father{ public static int b = a; } public class ClinitTest{ public static void main(String[] args){ System.out.println(Child.b); } } 执行上面的代码，会打印出 2，也就是说 b 的值被赋为了 2。 我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样 A 和 B 均被赋值为默 认值 0，而后再在调用()方法时给他们赋予程序中指定的值。当我们调用 Child.b 时，触发 Child 的()方法，根据 规则 2，在此之前，要先执行完其父类Father的()方法，又根据规则1，在执行()方法时，需要按 static 语句或 st atic 变量赋值操作等在代码中出现的顺序来执行相关的 static 语句，因此当触发执行 Fathe r的()方法时，会先将 a 赋值为 1，再执行 static 语句块中语句，将 a 赋值为 2，而后再执行 Child 类的()方法，这样便会将 b 的赋值 为 2。 如果我们颠倒一下 Father 类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打 印出1。很明显是根据规则 1，执行 Father 的()方法时，根据顺序先执行了 static 语句块中的内容，后执行了“p ublic static int a = 1;”语句。 另外，在颠倒二者的顺序之后，如果在 static 语句块中对 a 进行访问（比如将 a 赋给某个变量），在编译时将会 报错，因为根据规则 1，它只能对 a 进行赋值，而不能访问。 第 6 章 类加载机制 | 47 总结 总结 整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机 主导和控制。到了初始化才开始执行类中定义的 Java 程序代码（亦及字节码），但这里的执行代码只是个开 端，它仅限于()方法。类加载过程中主要是将 Class 文件（准确地讲，应该是类的二进制字节流）加载到虚拟机 内存中，真正执行字节码的操作，在加载完成后才真正开始。","categories":[{"name":"Java","slug":"Java","permalink":"http://io.stelawliet.top/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"http://io.stelawliet.top/categories/Java/JVM/"}],"tags":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://io.stelawliet.top/tags/jvm/"}]},{"title":"","slug":"arithmetic/QuickSort","date":"2018-06-13T14:00:48.000Z","updated":"2018-06-13T14:04:26.000Z","comments":true,"path":"2018/06/13/arithmetic/QuickSort/","link":"","permalink":"http://io.stelawliet.top/2018/06/13/arithmetic/QuickSort/","excerpt":"","text":"普通快排时间复杂度平均O(nlogn) a 随机3路快排时间复杂度平均O(nlogn)，额外空间复杂度O(logn)","categories":[],"tags":[]},{"title":"","slug":"arithmetic/tree/tree","date":"2018-06-13T13:52:35.000Z","updated":"2018-07-04T10:40:10.000Z","comments":true,"path":"2018/06/13/arithmetic/tree/tree/","link":"","permalink":"http://io.stelawliet.top/2018/06/13/arithmetic/tree/tree/","excerpt":"","text":"二叉树本文撇开一些非常苦涩、难以理解的概念来讲讲二叉树，仅入门观看(或复习)…. 首先，我们来讲讲什么是树： 树是一种非线性的数据结构，相对于线性的数据结构(链表、数组)而言，树的平均运行时间更短(往往与树相关的排序时间复杂度都不会高) 在现实生活中，我们一般的树长这个样子的： img 但是在编程的世界中，我们一般把树“倒”过来看，这样容易我们分析： img 一般的树是有很多很多个分支的，分支下又有很多很多个分支，如果在程序中研究这个会非常麻烦。因为本来树就是非线性的，而我们计算机的内存是线性存储的，太过复杂的话我们无法设计出来的。 因此，我们先来研究简单又经常用的—&gt; 二叉树 1.1树的一些概念我就拿上面的图来进行画来讲解了： img 二叉树的意思就是说：每个节点不能多于有两个儿子，上面的图就是一颗二叉树。 一棵树至少会有一个节点(根节点) 树由节点组成，每个节点的数据结构是这样的： 因此，我们定义树的时候往往是-&gt;定义节点-&gt;节点连接起来就成了树，而节点的定义就是：一个数据、两个指针(如果有节点就指向节点、没有节点就指向null) 1.2静态创建二叉树上面说了，树是由若干个节点组成，节点连接起来就成了树，而节点由一个数据、两个指针组成 因此，创建树实际上就是创建节点，然后连接节点 首先，使用Java类定义节点： 12345678910111213public class TreeNode &#123; // 左节点(儿子) private TreeNode lefTreeNode; // 右节点(儿子) private TreeNode rightNode; // 数据 private int value;&#125; 下面我们就拿这个二叉树为例来构建吧： img 为了方便构建，我就给了它一个带参数的构造方法和set、get方法了： 1234public TreeNode(int value) &#123; this.value = value;&#125; 那么我们现在就创建了5个节点： 123456789101112131415161718public static void main(String[] args) &#123; //根节点--&gt;10 TreeNode treeNode1 = new TreeNode(10); //左孩子--&gt;9 TreeNode treeNode2 = new TreeNode(9); //右孩子--&gt;20 TreeNode treeNode3 = new TreeNode(20); //20的左孩子--&gt;15 TreeNode treeNode4 = new TreeNode(15); //20的右孩子--&gt;35 TreeNode treeNode5 = new TreeNode(35) &#125; 它们目前的状态是这样子的： img 于是下面我们去把它连起来： 1234567//根节点的左右孩子treeNode1.setLefTreeNode(treeNode2);treeNode1.setRightNode(treeNode3);//20节点的左右孩子treeNode3.setLefTreeNode(treeNode4);treeNode3.setRightNode(treeNode5); 连接完之后，那么我们的树就创建完成了。 img 1.3遍历二叉树上面说我们的树创建完成了，那怎么证明呢？？我们如果可以像数组一样遍历它(看它的数据)，那就说明它创建完成了～ 值得说明的是：二叉树遍历有三种方式 中序遍历 先访问根节点，然后访问左节点，最后访问右节点(根-&gt;左-&gt;右) 先序遍历 先访问左节点，然后访问根节点，最后访问右节点(左-&gt;根-&gt;右) 后序遍历 先访问左节点，然后访问右节点，最后访问根节点(左-&gt;右-&gt;根) 以上面的二叉树为例： 如果是中序遍历：10-&gt;9-&gt;20-&gt;15-&gt;35 如果是先序遍历：9-&gt;10-&gt;15-&gt;20-&gt;35 可能需要解释地方：访问完10节点过后，去找的是20节点，但20下还有子节点，因此先访问的是20的左儿子15节点。由于15节点没有儿子了。所以就返回20节点，访问20节点。最后访问35节点 如果是后序遍历：9-&gt;15-&gt;35-&gt;20-&gt;10 可能需要解释地方：先访问9节点，随后应该访问的是20节点，但20下还有子节点，因此先访问的是20的左儿子15节点。由于15节点没有儿子了。所以就去访问35节点，由于35节点也没有儿子了，所以返回20节点，最终返回10节点 一句话总结：中序(根-&gt;左-&gt;右)，先序(左-&gt;根-&gt;右)，后序(左-&gt;右-&gt;根)。如果访问有孩子的节点，先处理孩子的，随后返回 无论先中后遍历，每个节点的遍历如果访问有孩子的节点，先处理孩子的(逻辑是一样的) 因此我们很容易想到递归 递归的出口就是：当没有子节点了，就返回 因此，我们可以写出这样的中序遍历代码： 123456789101112131415161718/** * 中序遍历 * @param rootTreeNode 根节点 */public static void inTraverseBTree(TreeNode rootTreeNode) &#123; if (rootTreeNode != null) &#123; //访问根节点 System.out.println(rootTreeNode.getValue()); //访问左节点 preTraverseBTree(rootTreeNode.getLefTreeNode()); //访问右节点 preTraverseBTree(rootTreeNode.getRightNode()); &#125;&#125; 结果跟我们刚才说的是一样的： img 我们再用先序遍历调用一遍吧： 123456789101112131415161718/** * 中序遍历 * @param rootTreeNode 根节点 */public static void preTraverseBTree(TreeNode rootTreeNode) &#123; if (rootTreeNode != null) &#123; //访问左节点 preTraverseBTree(rootTreeNode.getLefTreeNode()); //访问根节点 System.out.println(rootTreeNode.getValue()); //访问右节点 preTraverseBTree(rootTreeNode.getRightNode()); &#125;&#125; 结果跟我们刚才说的是一样的： img 有意思的是：通过先序和中序或者中序和后序我们可以还原出原始的二叉树，但是通过先序和后续是无法还原出原始的二叉树的 也就是说：通过中序和先序或者中序和后序我们就可以确定一颗二叉树了！ 二、动态创建二叉树上面我们是手动创建二叉树的，一般地：都是给出一个数组给你，让你将数组变成一个二叉树，此时就需要我们动态创建二叉树了。 二叉树中还有一种特殊的二叉树：二叉查找树(binary search tree) 定义：当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大。 明眼人可以看出，这对我们来找一个数是非常方便快捷的 往往我们动态创建二叉树都是创建二叉查找树 img 2.1动态创建二叉树体验假设我们有一个数组：int[] arrays = {3, 2, 1, 4, 5}; 那么创建二叉树的步骤是这样的： 首先将3作为根节点 img 随后2进来了，我们跟3做比较，比3小，那么放在3的左边 img 随后1进来了，我们跟3做比较，比3小，那么放在3的左边，此时3的左边有2了，因此跟2比，比2小，放在2的左边 img 随后4进来了，我们跟3做比较，比3大，那么放在3的右边 img 随后5进来了，我们跟3做比较，比3大，那么放在3的右边，此时3的右边有4了，因此跟4比，比4大，放在4的右边 img 那么我们的二叉查找树就建立成功了，无论任何一颗子树，左边都比根要小，右边比根要大 img 2.2代码实现我们的代码实现也很简单，如果比当前根节点要小，那么放到当前根节点左边，如果比当前根节点要大，那么放到当前根节点右边。 因为是动态创建的，因此我们得用一个类来表示根节点 123456789101112public class TreeRoot &#123; private TreeNode treeRoot; public TreeNode getTreeRoot() &#123; return treeRoot; &#125; public void setTreeRoot(TreeNode treeRoot) &#123; this.treeRoot = treeRoot; &#125;&#125; 比较与根谁大，大的往右边，小的往左边： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 动态创建二叉查找树 * * @param treeRoot 根节点 * @param value 节点的值 */ public static void createTree(TreeRoot treeRoot, int value) &#123; //如果树根为空(第一次访问)，将第一个值作为根节点 if (treeRoot.getTreeRoot() == null) &#123; TreeNode treeNode = new TreeNode(value); treeRoot.setTreeRoot(treeNode); &#125; else &#123; //当前树根 TreeNode tempRoot = treeRoot.getTreeRoot(); while (tempRoot != null) &#123; //当前值大于根值，往右边走 if (value &gt; tempRoot.getValue()) &#123; //右边没有树根，那就直接插入 if (tempRoot.getRightNode() == null) &#123; tempRoot.setRightNode(new TreeNode(value)); return ; &#125; else &#123; //如果右边有树根，到右边的树根去 tempRoot = tempRoot.getRightNode(); &#125; &#125; else &#123; //左没有树根，那就直接插入 if (tempRoot.getLefTreeNode() == null) &#123; tempRoot.setLefTreeNode(new TreeNode(value)); return; &#125; else &#123; //如果左有树根，到左边的树根去 tempRoot = tempRoot.getLefTreeNode(); &#125; &#125; &#125; &#125; &#125; 测试代码： 12345678910111213141516int[] arrays = &#123;2, 3, 1, 4, 5&#125;;//动态创建树TreeRoot root = new TreeRoot();for (int value : arrays) &#123; createTree(root, value);&#125;//先序遍历树preTraverseBTree(root.getTreeRoot());System.out.println(&quot;---------------公众号：Java3y&quot;);//中序遍历树inTraverseBTree(root.getTreeRoot());System.out.println(&quot;---------------公众号：Java3y&quot;); img 三、查询二叉查找树相关3.1查询树的深度查询树的深度我们可以这样想：左边的子树和右边的字数比，谁大就返回谁，那么再接上根节点+1就可以了 img 123456789101112131415161718192021public static int getHeight(TreeNode treeNode) &#123; if (treeNode == null) &#123; return 0; &#125; else &#123; //左边的子树深度 int left = getHeight(treeNode.getLefTreeNode()); //右边的子树深度 int right = getHeight(treeNode.getRightNode()); int max = left; if (right &gt; max) &#123; max = right; &#125; return max + 1; &#125;&#125; 3.1查询树的最大值从上面先序遍历二叉查找树的时候，细心的同学可能会发现：先序遍历二叉查找树得到的结果是排好顺序的～ 那么，如果我们的二叉树不是二叉查找树，我们要怎么查询他的最大值呢？ 可以这样： img 左边找最大值-&gt;递归 右边找最大值-&gt;递归 1234567891011121314151617181920212223242526272829303132333435/** * 找出树的最大值 * * @param rootTreeNode */public static int getMax(TreeNode rootTreeNode) &#123; if (rootTreeNode == null) &#123; return -1; &#125; else &#123; //找出左边的最大值 int left = getMax(rootTreeNode.getLefTreeNode()); //找出右边的最大值 int right = getMax(rootTreeNode.getRightNode()); //与当前根节点比较 int currentRootValue = rootTreeNode.getValue(); //假设左边的最大 int max = left; if (right &gt; max) &#123; max = right; &#125; if (currentRootValue &gt; max) &#123; max = currentRootValue; &#125; return max ; &#125;&#125; 四、最后无论是在遍历树、查找深度、查找最大值都用到了递归，递归在非线性的数据结构中是用得非常多的… 树的应用也非常广泛，此篇简单地说明了树的数据结构，高级的东西我也没弄懂，可能以后用到的时候会继续深入…","categories":[],"tags":[]},{"title":"java 随机取值","slug":"arithmetic/Java随机Math和Random","date":"2018-06-13T12:26:06.000Z","updated":"2018-07-04T11:11:26.000Z","comments":true,"path":"2018/06/13/arithmetic/Java随机Math和Random/","link":"","permalink":"http://io.stelawliet.top/2018/06/13/arithmetic/Java随机Math和Random/","excerpt":"","text":"Math.random()返回long类型。[0,1)的16位 Random r= new Random(); r.netInt(n); 返回[0,n)的int","categories":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/categories/java/"},{"name":"Api","slug":"java/Api","permalink":"http://io.stelawliet.top/categories/java/Api/"}],"tags":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/tags/java/"},{"name":"random","slug":"random","permalink":"http://io.stelawliet.top/tags/random/"}]},{"title":"[object Object]","slug":"arithmetic/sort-mem","date":"2018-06-13T12:18:07.000Z","updated":"2018-07-04T10:39:55.000Z","comments":true,"path":"2018/06/13/arithmetic/sort-mem/","link":"","permalink":"http://io.stelawliet.top/2018/06/13/arithmetic/sort-mem/","excerpt":"牛课网算法学习day1-2 mem for 循环分析 记为 for i -&gt; n-1 i++ 先写好分析过程再代码 Math.random方法和Random类的使用","text":"牛课网算法学习day1-2 mem for 循环分析 记为 for i -&gt; n-1 i++ 先写好分析过程再代码 Math.random方法和Random类的使用 Math.random方法生成double [0,1)的0后16位小数 Random类的nextInt(a)可以生成[0,a)的整数 几个要点 数组复制时的赋值 a[i] = help[i]; for循环中的前后边界 for循环中的for循环前后边界与外层循环的关系 for i -&gt; n-1 j++ day3 堆结构 从数组建立大根堆heapInsert()，[0,heapSize] 堆顶弹出时重新维护大根堆heapify() 快速排序 经典快排 中间量没选好 复杂度为O(n^2) 一般为O(nlogn); 随机快排 随机选取中间量 双路遍历 排序选择 样本小于60一般采用插入排序 排本小 常数项小基本数据类型采用快速排序多数据对象采用归并排序 保证稳定性 day4 堆排序 数组的栈实现 index 记录下次放入的位置 push pop 队列的栈实现 start end size 双队列实现栈的结构","categories":[{"name":"algorithme note","slug":"algorithme-note","permalink":"http://io.stelawliet.top/categories/algorithme-note/"}],"tags":[{"name":"algorithme","slug":"algorithme","permalink":"http://io.stelawliet.top/tags/algorithme/"},{"name":"todo","slug":"todo","permalink":"http://io.stelawliet.top/tags/todo/"}]},{"title":"归并排序MergeSort","slug":"arithmetic/mergeSort","date":"2018-06-13T08:35:36.000Z","updated":"2018-07-04T11:12:48.000Z","comments":true,"path":"2018/06/13/arithmetic/mergeSort/","link":"","permalink":"http://io.stelawliet.top/2018/06/13/arithmetic/mergeSort/","excerpt":"时间复杂度O(nlogn),额外空间复杂度O(n); 分治,中间分开mid=(l+r)/2 递归调用结束条件if（l==r) return; 分别处理递归 l -&gt; mid和mid+1 -&gt; r","text":"时间复杂度O(nlogn),额外空间复杂度O(n); 分治,中间分开mid=(l+r)/2 递归调用结束条件if（l==r) return; 分别处理递归 l -&gt; mid和mid+1 -&gt; r 123456789public static void mergeSort(int[] arr, int l, int r) &#123; if (l == r) &#123; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r); &#125; 合并递归结束的 l -&gt;mid和mid+1 -&gt; r 创建辅助数组help[]，长度为r-l+1; 使用外排的方式把 l -&gt; mid和mid+1 -&gt; r中小的数放进help[]中; 把排序好的help[]复制进要排序的数组中l -&gt; r; 123456789101112131415161718public static void merge(int[] arr, int l, int m, int r) &#123; int[] help = new int[r - l + 1]; int i = 0; int p1 = l; int p2 = m + 1; while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; while (p1 &lt;= m) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= r) &#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i]; &#125; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"http://io.stelawliet.top/categories/algorithm/sort/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/tags/algorithm/"},{"name":"排序","slug":"排序","permalink":"http://io.stelawliet.top/tags/排序/"}]},{"title":"O(n2)的排序","slug":"arithmetic/insertSort","date":"2018-06-13T05:40:11.000Z","updated":"2018-07-04T10:44:34.000Z","comments":true,"path":"2018/06/13/arithmetic/insertSort/","link":"","permalink":"http://io.stelawliet.top/2018/06/13/arithmetic/insertSort/","excerpt":"","text":"插入排序 1234(n = size)for 1 -&gt; n-1 i++ for i -&gt; 1 j-- if [j-1] &lt; [j] swap() 冒泡排序 123for 0 -&gt; n-2 i++ for 0 -&gt; n-1-1-i j++ if [j]&gt;[j+1] swap() 123for n-1 -&gt; 1 end-- for 0 -&gt; end-1 i++ if [i]&gt;[i+1] swap() 选择排序 123for 0 -&gt; n-2 i++ //选择最小的值放到i for i -&gt; n-1 j++ //遍历选出最小值 if [i] &gt; [j] swap() 123for 0 -&gt; n-2 i++ for i -&gt; n-2 j++ [i] = [i] &lt; [j+1] ? [i] : [j+1]","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://io.stelawliet.top/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"http://io.stelawliet.top/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"http://io.stelawliet.top/tags/sort/"}]},{"title":"","slug":"MD/mem/劝学","date":"2018-06-11T14:09:08.000Z","updated":"2018-06-11T14:09:29.000Z","comments":true,"path":"2018/06/11/MD/mem/劝学/","link":"","permalink":"http://io.stelawliet.top/2018/06/11/MD/mem/劝学/","excerpt":"","text":"不积跬步,无以至千里。 不积小流,无以成江海。 ——荀子《劝学篇》","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/对象访问定义","date":"2018-06-11T10:15:43.000Z","updated":"2018-06-11T10:40:30.000Z","comments":true,"path":"2018/06/11/Java/JVM/对象访问定义/","link":"","permalink":"http://io.stelawliet.top/2018/06/11/Java/JVM/对象访问定义/","excerpt":"","text":"对象的访问定位句柄定位我们的Java程序需要通过栈上的Reference数据来操作堆上的具体对象。Reference访问对象的方式目前主流的有两种：句柄和直接指针。 如果直接使用句柄访问，java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息，如下图所示。 句柄定位 指针定位“如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址” 摘录来自: Gavin Zhang. “深入理解java虚拟机”。 iBooks.","categories":[],"tags":[]},{"title":"GC垃圾判定算法","slug":"Java/JVM/GC算法","date":"2018-06-11T10:11:09.000Z","updated":"2018-07-04T11:45:18.000Z","comments":true,"path":"2018/06/11/Java/JVM/GC算法/","link":"","permalink":"http://io.stelawliet.top/2018/06/11/Java/JVM/GC算法/","excerpt":"","text":"可达性分析算法Java中使用可达性分析（Reachability Analysis）来判定对象是否存活的。 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。” 在Java语言中，可作为GC Roots的对象包括下面几种： ==虚拟机栈（栈帧中的本地变量表）中引用的对象==。 ==方法区中类静态属性引用的对象==。 ==方法区中常量引用的对象。== ==本地方法栈中JNI（即一般说的Native方法）引用的对象。== 摘录来自: Gavin Zhang. “深入理解java虚拟机”。 iBooks.","categories":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/categories/java/"},{"name":"JVM","slug":"java/JVM","permalink":"http://io.stelawliet.top/categories/java/JVM/"},{"name":"GC roots","slug":"java/JVM/GC-roots","permalink":"http://io.stelawliet.top/categories/java/JVM/GC-roots/"}],"tags":[]},{"title":"","slug":"MD/mem/？？","date":"2018-06-11T02:27:09.000Z","updated":"2018-06-11T02:27:20.000Z","comments":true,"path":"2018/06/11/MD/mem/？？/","link":"","permalink":"http://io.stelawliet.top/2018/06/11/MD/mem/？？/","excerpt":"","text":"志向和热爱是伟大行为的双翼。——歌德","categories":[],"tags":[]},{"title":"[object Object]","slug":"hexo/post","date":"2018-05-26T07:33:13.000Z","updated":"2018-06-25T01:29:07.000Z","comments":true,"path":"2018/05/26/hexo/post/","link":"","permalink":"http://io.stelawliet.top/2018/05/26/hexo/post/","excerpt":"","text":"&lt;more!&gt;","categories":[],"tags":[]},{"title":"vscode shell","slug":"MD/Mac/vscode shell中打开配置","date":"2018-05-26T06:51:48.000Z","updated":"2018-06-29T13:37:01.000Z","comments":true,"path":"2018/05/26/MD/Mac/vscode shell中打开配置/","link":"","permalink":"http://io.stelawliet.top/2018/05/26/MD/Mac/vscode shell中打开配置/","excerpt":"","text":"在登录脚本中添加代码~/.zshrc~/.bash_profile 12code () &#123; VSCODE_CWD=\"$PWD\" open -n -b \"com.microsoft.VSCode\" --args $* ;&#125; 然后通过 code . 就可以打开当前目录通过VSCODE","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"http://io.stelawliet.top/tags/shell/"},{"name":"vscode","slug":"vscode","permalink":"http://io.stelawliet.top/tags/vscode/"},{"name":"zshrc","slug":"zshrc","permalink":"http://io.stelawliet.top/tags/zshrc/"}]},{"title":"","slug":"MD/mem/记忆祭坛","date":"2018-05-22T17:24:37.000Z","updated":"2018-05-22T17:25:31.000Z","comments":true,"path":"2018/05/23/MD/mem/记忆祭坛/","link":"","permalink":"http://io.stelawliet.top/2018/05/23/MD/mem/记忆祭坛/","excerpt":"","text":"记忆祭坛 IMG_6661","categories":[],"tags":[]},{"title":"","slug":"MD/mem/憧憬？","date":"2018-05-22T16:18:56.000Z","updated":"2018-05-22T16:20:10.000Z","comments":true,"path":"2018/05/23/MD/mem/憧憬？/","link":"","permalink":"http://io.stelawliet.top/2018/05/23/MD/mem/憧憬？/","excerpt":"","text":"憧憬？ Gekijouban","categories":[],"tags":[]},{"title":"","slug":"MD/mem/来自深渊","date":"2018-05-22T16:11:04.000Z","updated":"2018-05-22T16:21:23.000Z","comments":true,"path":"2018/05/23/MD/mem/来自深渊/","link":"","permalink":"http://io.stelawliet.top/2018/05/23/MD/mem/来自深渊/","excerpt":"","text":"当你凝视着深渊，深渊也在凝视着你。 Made","categories":[],"tags":[]},{"title":"Vue Timer","slug":"Vue/project/定时器","date":"2018-05-21T15:46:31.000Z","updated":"2018-07-05T06:52:56.000Z","comments":true,"path":"2018/05/21/Vue/project/定时器/","link":"","permalink":"http://io.stelawliet.top/2018/05/21/Vue/project/定时器/","excerpt":"","text":"Timer.vueUI使用Element的组件。 导入UI123import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI); Template模版123456789&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;计时&lt;/h1&gt; &lt;h1&gt;&#123;&#123; nowTime &#125;&#125;&lt;/h1&gt; &lt;el-input-number v-model=&quot;selMin&quot; placeholder=&quot;&quot;&gt;&lt;/el-input-number&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;starttimer&quot;&gt;Start&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;endtimer&quot;&gt;End&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt; Script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script&gt; export default &#123; data() &#123; return &#123; clear: 0, falg: false, //选择的计时时间 selMin: 0, selTime: 0, nowTime: &apos;00 : 00&apos;, endTime: 0, &#125; &#125;, created() &#123;&#125;, computed: &#123;&#125;, methods: &#123; //选择n分钟 //计算n分钟的结束时间 end+new date() //end-nowTime //转化格式输出endTime/1000/60 m : endTime/1000*60) starttimer() &#123; this.$message.success(&quot;start&quot;); //选择的计时分钟+开始时间，计算出计时结束时的毫秒数 this.endTime = this.selMin * 60 * 1000 + new Date().getTime(); const my = this; //0.5秒调用一次，来更新，记录定时器ID this.clear = window.setInterval( () =&gt; &#123; my.getTime() &#125;, 500); &#125;, //清除定时任务 endtimer() &#123; window.clearInterval(this.clear); &#125;, getTime() &#123; //结束毫秒数-当前毫秒数得剩余毫秒数 const end0 = this.endTime - new Date().getTime(); //剩余毫秒数格式化输出 this.nowTime = &quot; &quot; + this.formatTime(parseInt(end0 / 1000 / 60)) + &quot; : &quot; + this.formatTime(parseInt(end0 / 1000 % 60)); //剩余&lt;=0时计时完成 if (end0 &lt;= 0) &#123; //通过ID结束计时 window.clearInterval(this.clear); this.$message.success(&quot;time now!!&quot;) &#125; &#125;, //位数格式化小于1位时补0 formatTime(time) &#123; return time / 10 &gt;= 1 ? time :`0$&#123; time&#125;`; &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://io.stelawliet.top/categories/vue/"},{"name":"todo","slug":"vue/todo","permalink":"http://io.stelawliet.top/categories/vue/todo/"}],"tags":[]},{"title":"","slug":"MD/mem/EMT??","date":"2018-05-19T18:15:01.000Z","updated":"2018-05-19T18:16:18.000Z","comments":true,"path":"2018/05/20/MD/mem/EMT??/","link":"","permalink":"http://io.stelawliet.top/2018/05/20/MD/mem/EMT??/","excerpt":"","text":"EMT 私にできることならとは言ったけど EMILIA-0001","categories":[],"tags":[]},{"title":"","slug":"TODOlist/2018-5-29","date":"2018-05-19T15:16:34.000Z","updated":"2018-05-19T15:16:47.000Z","comments":true,"path":"2018/05/19/TODOlist/2018-5-29/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/TODOlist/2018-5-29/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"todo vue 概要","slug":"TODOlist/todo vue","date":"2018-05-19T15:13:33.000Z","updated":"2018-06-29T13:35:38.000Z","comments":true,"path":"2018/05/19/TODOlist/todo vue/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/TODOlist/todo vue/","excerpt":"","text":"从日历出发 每天的todolist 在todo中加番茄时间 番茄时间中25分计时一次。间隔5-9分钟 统计总的番茄，统计todo","categories":[{"name":"TODO","slug":"TODO","permalink":"http://io.stelawliet.top/categories/TODO/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://io.stelawliet.top/tags/vue/"},{"name":"javascropt","slug":"javascropt","permalink":"http://io.stelawliet.top/tags/javascropt/"},{"name":"plan","slug":"plan","permalink":"http://io.stelawliet.top/tags/plan/"}]},{"title":"","slug":"TODOlist/2018-5-20","date":"2018-05-19T14:45:44.000Z","updated":"2018-05-20T18:29:33.000Z","comments":true,"path":"2018/05/19/TODOlist/2018-5-20/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/TODOlist/2018-5-20/","excerpt":"","text":"MySQL 触发器 整理快速排序代码 博客SQL练习 博客mysql 学习http://www.cnblogs.com/geaozhang/p/7347950.html chrome canary tab clean 独立评论模块学习","categories":[],"tags":[]},{"title":"","slug":"MD/mac强化","date":"2018-05-19T14:14:52.000Z","updated":"2018-05-19T14:24:35.000Z","comments":true,"path":"2018/05/19/MD/mac强化/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/MD/mac强化/","excerpt":"","text":"高效MacBook工作环境配置2015年08月03日 19:53:48 阅读数：2568 转自：http://www.xialeizhou.com/?p=71 本文记录整个配置过程，供新入手MacBook和觉得MacBook比较难用的同学参考。 硬件提升 笔记本电脑的特点是携带方便，缺点是屏幕太小，因此你首先需要再申请领用一个外接显示器，多一个屏幕会大大减少你切换应用程序的次数，显著提升你的工作效率，别忘了同时申请一个Mini DP转VGA的转接头用于连接显示器。为了配合多显示器，后面会推荐一个软件来管理多显示器窗口。 如果你资金宽裕，可以买个机械键盘和无线鼠标，进一步提升工作效率。 系统设置 2.1 将功能键(F1-F12)设置为标准的功能键MacBook键盘最上面一排的功能键(F1-F12)默认是系统亮度和声音之类的快捷设置，当MacBook作为你的娱乐电脑时，这样的默认设置是非常方便的，但是对于将MacBook作为工作电脑而且需要频繁使用功能键(F1-F12)的人，最好将功能键(F1-F12)的行为设置为标准的功能键。 首先打开System Preferences，点击Keyboard图标，勾选上Use all F1, F2, etc. keys as standard function keys。以后如果你要调节音量，就按住键盘左下角的fn键再按F11或者F12。 [ 211](picture/046129e254a9d24fa83b87c45019cc65c758e418.png) 图2.1-1 2.2 设置Trackpad（触摸板）轻触为单击当你首次使用MacBook，是否会觉得触摸板一点都不顺滑？那是因为你需要做如下设置。打开System Preferences，点击Trackpad图标，勾选Tap to click选项，现在手指轻轻一碰触摸板，就达到鼠标单击的顺滑效果。 2.3 将Dock停靠在屏幕左边为什么要将Dock停靠在屏幕左边？MacBook的屏幕是一个长方形，如果你将Dock放在下面，那么屏幕的可用宽度就会减少，另外人眼阅读时的顺序是从左往右，因此Dock放在左边更适合将MacBook作为工作电脑的人。 打开System Preferences，点击Dock图标， 将图标的Size调到合适大小 关闭Magnification特效（即鼠标放到Dock上图标放大的效果，此效果干扰注意力） 在Position on screen一栏，选择Left 勾选Minimize window into application icon [ 231](http://img4.tbcdn.cn/L1/461/1/613945b61050a6fbbef7145784ca728e3a4b3c69) 图2.3-1 2.4 全键盘控制模式全键盘控制模式是什么？ 举一个例子，如下图所示，我正在写一个文档，此文档还没有保存，也没有文件名，如果不不小心点了关闭按钮，将会弹出一个对话框： [ 241](http://img4.tbcdn.cn/L1/461/1/d390b46f0e56030ee7731af9231d52b8a997c4ee) 图2.4-1 当前，[Save]按钮处于默认激活状态，按回车将会弹出保存对话框。但是如果我不想保存呢？ 只能通过鼠标或者触摸板来移动光标后点击[Don&#39;t Save]来取消保存。那我能不能通过键盘控制光标激活[Don&#39;t Save]按钮呢？ 答案是肯定的，做一个简单设置就好。 如图，首先打开System Preferences，点击Keyboard图标，选择Shortcuts这个Tab, 选中All controls [ 242](http://img3.tbcdn.cn/L1/461/1/b4743db32d0f97b9bfcd076b293793046c410cb4) 图2.4-2 现在当我再次试图关闭一个未保存的文件时，新弹出的对话框如下，有了些许变化，在[Don&#39;t Save]按钮上多了一个蓝色的外框，当你按键盘上的tab键的时候，蓝色的外框会在3个按钮间切换。 假设现在蓝色的外框在[Don&#39;t Save]按钮上，你按下回车，却发现系统依然进入了保存文件对话框，为什么蓝色的外框不起作用呢？那是因为蓝色的外框选中的按钮是由空格键触发的，当你按下空格键，系统就会不保存文件直接退出。 这样当你不方便使用鼠标和触摸板的时候，可以更快速的和你的MacBook交互。 [ 243](http://img1.tbcdn.cn/L1/461/1/3abe8997fe7e3180655e05505d532fca0a37e640) 图2.4-3 2.5 快速锁定屏幕如果你长时间离开电脑，最好锁定你的屏幕，以防止数据泄露。 那如何快速的锁定你的MacBook呢？ 答案是只需要一摸触摸板或者一甩鼠标就可以了。 打开System Preferences，点击Desktop &amp; Screen Saver图标，选择Screen Saver这个Tab，再点击Hot Corners...，在弹出的如下界面里面，右下角选择Put Display to Sleep，点击OK确定。[ 251](http://img2.tbcdn.cn/L1/461/1/1accf3c0f885fdac290bca59f2ba158896ac7082) 图2.5-1 再打开System Preferences，点击Security &amp; Privacy图标，在GeneralTab内，勾选Require password[immediately] after sleep or screen save begins。 [ 252](http://img4.tbcdn.cn/L1/461/1/860acb1af1045d34664b96061c7e414f6e4ab9d6) 图2.5-2 现在当你离开电脑前时，记得一摸触摸板或者一甩鼠标将光标快速的移到屏幕的右下角，MacBook将立刻进入Screen Saver模式并且需要密码才能进入桌面。 系统常用快捷键 请点击这个文档，学习系统快捷键，适当使用快捷键将会提升你的工作效率。 日常软件推荐 4.1 中文输入法系统自带的输入法不是很好用，推荐安装搜狗输入法或者RIME输入法。安装完成后，打开System Preferences，选择Keyboard，切换到Shortcuts这个Tab下，勾选Select the previous input source，并点击上述文字后面的空白处，设置快捷键为Ctrl+Space(即如图所示的^Space)。 [ 411](http://img3.tbcdn.cn/L1/461/1/924d005e0c8b910bea9110803ac9920b2450f635) 图4.1-1 4.2 窗口管理软件 - SizeUp 你是否经常想让某个Word文档占满屏幕的左半部分，旺旺聊天占满屏幕的右半部分，从而一边对着文档一边和小伙伴聊需求？ 终于搞好了外接显示器，你是否经常将某个窗口在笔记本和外接显示器屏幕之间直接来回拖动？ SizeUp快速解决这样的需求，该软件可以永久免费试用，下载安装后打开SizeUp，再打开旺旺，快捷键按下control+option+command + M，则旺旺就会立即进入全屏模式。 然而大部分情况下，你会看到如下这个提示，这是因为SizeUp需要你的授权才能控制窗口。 [ 421](http://img4.tbcdn.cn/L1/461/1/999f26354ec892e3d7a578a423071c5b96b52cfd) 图4.2-1 直接点击Open System Preferences或者打开System Preferences，点击Security &amp; Privacy图标，在PrivacyTab内，点击Accessibility，然后将SizeUp加到右边的列表里面。（提示：你可能需要先点击右下角的黄色锁，输入密码后才能编辑右边的列表。） [ 422](http://img1.tbcdn.cn/L1/461/1/1e1da9b2f90668f13adf273429e6d6e738ddea9d) 图4.2-2 如果你此时接上了外接显示器，快捷键按下control+option + 方向键右键，则当前左边显示器激活的最前端窗口将被立即发送到右边的显示器。 下面列举一些SizeUp常用的快捷键，更多的快捷键和使用方式请查询其官方网站。 control+option+command + M ： 使当前窗口全屏 control+option+command + 方向键上键 ： 使当前窗口占用当前屏幕上半部分 control+option+command + 方向键下键 ： 使当前窗口占用当前屏幕下半部分 control+option+command + 方向键左键 ： 使当前窗口占用当前屏幕左半部分 control+option+command + 方向键右键 ： 使当前窗口占用当前屏幕右半部分 control+option + 方向键左键 ： 将当前窗口发送到左边显示器屏幕 control+option + 方向键右键 ： 将当前窗口发送到右边显示器屏幕 4.3 查找文件和应用程序以及无限想象力 - Alfred如果你曾经使用过MacBook，你应该接触过Spotlight，就是屏幕中间弹出一个长条输入框，你输入文件名或者应用程序名，Spotlight将模糊查找到对应的候选项，按回车快速的打开你需要的文件或程序。 Alfred的能力远远超过了Spotlight, 你可以直接下载免费版安装使用，Alfred另外还提供了更强大的工作流(Workflows)和剪切板(Clipboard)管理等高级功能，需要购买Powerpack。对于日常的操作，免费版已经足够使用了。 因为Alfred可以完全取代Spotlight，下面先删除Spotlight占用的快捷键command + 空格，以供Alfred将来使用。 打开System Preferences，选择Keyboard，切换到Shortcuts这个Tab下，点击Spotlight，取消对应的2个快捷键设置。 [ 431](http://img2.tbcdn.cn/L1/461/1/62f3d89b8c2f42cbc28df7e4fd0e1055c4a15105) 图4.3-1 打开Alfred，在菜单栏点击Alfred图标，打开Preferences... [ 432](http://img3.tbcdn.cn/L1/461/1/dbb0d56ee24de047dc0b279bc38b547ca610e621) 图4.3-2 如下图所示，设置Alfred的快捷键为command + 空格 [ 433](http://img4.tbcdn.cn/L1/461/1/b84bccd1ff0ae8e93bc54d4c1c5da7a43f1e0630) 图4.3-3 现在按下快捷键command + 空格，输入ali，则Alfred不区分大小写的将所有包含ali的应用程序，文档以及历史网址都列出来了，如下图所示，回车打开淘云盘，command+2打开本地一个xmind文件，你还可以移动键盘上下键或者光标来选择目标。 [ 434](http://img1.tbcdn.cn/L1/461/1/9dc7c00720205a3de3ea4bc2ba3f33999490b997) 图4.3-4 更多关于Alfred的使用方式和无限想象力，请参考官方网站或者网上现有的大量的教程。 下面简单演示一下剪切板管理和厂内查人工作流的使用。如下图所示，我使用快捷键打开剪切板管理器，列出来我最近复制过的文本片段，我可以快速的选取这些文本片段或者输入部分字符来查找 [ 435](http://img3.tbcdn.cn/L1/461/1/72f3e06475119fb924c0535a4f45016bd4a0292e) 图4.3-5 当你安装了由@文通开发的厂内查人workflow后，激活Alfred，输入r+空格，再输入某人的花名，就可以看到对方的简单信息。 按回车打开阿里内外对方信息页面 按ctrl+回车，直接打开对方旺旺进入聊天模式 [ 436](http://img2.tbcdn.cn/L1/461/1/5e78176ac9a22ea36cdbaeb478fc8f6f4812dcd9) 图4.3-6 4.4 聪明又美丽的日历 – Fantastical 2打开Fantastical 2的网站，你一定会被她漂亮的外表所吸引，最可贵的是Fantastical还很聪明，当你在日历里面新建一个提醒的时候，输入如下内容“HTML training at 7:30pm tomorrow alert 5 min”, 则Fantastical会自动将日期设置为明天，然后将开始时间设置为晚上7点半，并且提前5分钟提醒，是不是很聪明？ [ 441](http://img1.tbcdn.cn/L1/461/1/d611de3740f64721e11e869ede0a6a0131da81d0) 图4.4-1 4.5 来杯免费咖啡 – Caffeine今天下午给大老板和重要客户演示PPT，你仿佛看到了升职加薪走上人生巅峰，当你打开MacBook接上投影仪，口若悬河的讲解，突然MacBook进入休眠模式了，画面太美了，我不敢想了。 你应该立刻安装这款免费的良心软件—Caffeine，设置开机启动，点一下状态栏的咖啡杯图标，当咖啡是满的时候，MacBook将不会进入休眠模式，再点一下咖啡杯空了就正常休眠，我默认设置开机启动，咖啡杯保持满满的状态。 4.6 快速切换和打开应用程序 – ManicoMacBook系统默认设置了一个快捷键来显示当前运行中的应用程序，同时按下tab + command，将看到如下图的样式： [ 461](http://img4.tbcdn.cn/L1/461/1/216e6046485410605dc1883952ae22f8a685e3c5) 图4.6-1 如果你想要却换到Firefox，需要再按一下tab，如果要切换到日历，需要按两下‘tab’，如果一次性打开10几个应用程序，你经常需要按十几下tab才能却换到想要的程序。 Manico专为这个场景而设计，安装好后打开，默认快捷键是按住option，如图所示，此时按下数字7就能快速打开编号为7的地图。 [ 462](http://img4.tbcdn.cn/L1/461/1/bd61382e4d329f7932dff65e7bf426a3bf6dc8cf) 图4.6-2 另外，推荐设置Manico使用左手边的字母加数字做索引，方便仅仅用左手就能快速切换应用程序。在菜单栏点击Manico图标，打开Preferences...， 在AppearanceTab里面，选择Uses left hand area和Use numeric and alphabet。 [ 463](http://img1.tbcdn.cn/L1/461/1/3fc434c7ed3fb8ab3d80fc726996d173d60dc5e3) 图4.6-3 4.7 随心所欲的复制粘贴以及无限想象 – PopClip 日常工作中，你有多少次是从一个应用程序复制一段文本然后粘贴到另外一个地方？ 有多少次是复制一个网址然后打开浏览器粘贴到地址栏然后回车打开？ 有多少次是复制一个名词，然后打开浏览器找到搜索引擎来搜索？ 这些重复的操作模式都是可以简化的，你唯一需要的就是PopClip，当你选中一段文字（如下图，选中“当日收益”），PopClip就会弹出来一个快捷操作栏，你可以复制，剪切或者粘贴，更为强大的是，PopClip提供了很多免费的插件，例如使用指定的搜索引擎搜索选中的文字，或者选中英文单词做大小写转换等等。 [ 471](http://img4.tbcdn.cn/L1/461/1/43e10d3e2589595b9b371620817878ffa49bf8f2) 图4.7-1 需要注意的是，PopClip需要你的授权才能弹出快捷状态栏，直接点击Open System Preferences或者打开System Preferences，点击Security &amp; Privacy图标，在PrivacyTab内，点击Accessibility，然后将PopClip加到右边的列表里面并且勾选前面的checkbook。（提示：你可能需要先点击右下角的黄色锁，输入密码后才能编辑右边的列表。） 4.8 增强资源管理器 – XtraFinderMacBook自带的资源管理器(Finder)已经可以满足一般的需要，但是当你有大量文件维护操作后，你就需要一个更强大的Finder。XtraFinder完全集成到Finder里面，你根本感觉不出它是一个第三方的应用程序，同时还提供很多增强特性，比如： 像浏览器那样的标签页(Tab) 支持双操作面板(Panel) 增强的全局快捷键，例如新建文件(New File)等 多彩的侧边栏图标 快速在当前文件夹打开终端 快速在当前文件夹新建文件 [ 481](http://img2.tbcdn.cn/L1/461/1/a9d636d1331d528d71ab9d720c7f64987b1b1350) 图4.8-1 4.9 随心所欲的全键盘控制 - Shortcat在系统设置里面，我介绍了全键盘控制模式，但是此模式只能做简单的按钮控制，无法达到随心所欲的控制。下面介绍一款比较geek的软件，Shortcat帮助你完全使用键盘来控制系统，供有键盘强迫症的同学使用。 [ 491](http://img3.tbcdn.cn/L1/461/1/5920267ce10a6f28b669919720f4d8b196b78ff9) 图4.9-1 4.10 来杯鸡尾酒 – Bartender如果你看到这里，相信你已经被我推(hu)荐(you)的安装了一排软件，你的系统状态栏已经人满为患，有时候会因为当前激活的应用程序的菜单比较多挡住你要点击的状态栏图标，这个时候你需要一个酒保来帮你调理一下状态栏，Bartender将是我推荐的最后一个日常使用的App，你可以自定义隐藏某些不常用的状态栏图标，特别适合处女座强迫症。 [ 4101](http://img4.tbcdn.cn/L1/461/1/ed09772f6172235bd4b9de1a10c182703e298a35) 图4.10-1 开发环境配置 终于到了开发环境配置阶段，在配置开发环境前，建议先将OS X系统升级到最新版，同时去Mac App Store下载最新版的Xcode，然后使用下面的命令安装Xcode command line tools，这将为你安装很多终端下面常用的命令，将来很可能会使用到： 1xcode-select --install 5.1 命令行终端Terminal在用户界面没有发明前，终端Terminal曾经是计算机的唯一交互方式，就算到了今天，很多服务器仍然只提供终端登陆来操作，作为开发测试运维相关人员，在日常工作中合理使用终端将大大提高工作效率。 5.1.1 替换系统默认Shell – Oh My ZSH!Bash作为大多数系统默认安装的Shell，大家都多少有所接触，Zsh和Bash类似都是一个Shell，但是Zsh更注重用户体验和与人的交互，OS X默认也安装好了Zsh，然而你想自己从头开始配置一个顺手的Zsh是比较浪费时间的，有人已经帮我们配置好了，这个流行的Zsh配置叫—Oh My ZSH!，直观的效果如下图所示，代码开源在github。 [ 5111](http://img2.tbcdn.cn/L1/461/1/e63853028eb8119689986663bf0c794263f27be4) 图5.1.1-1 切换默认Shell到Zsh Mac OS X默认已经安装好了Zsh，你可以打开终端，输入zsh --version来确认，如果没有安装，请参考这个文档。 打开终端输入下面的命令，切换默认Shell为Zsh： 1chsh -s /bin/zsh 关闭终端重新打开后，你将默认使用zsh作为终端Shell。然而你会发现，终端并没有变得多酷炫，接着往下走，安装Oh My ZSH! 安装Oh My ZSH! 打开终端输入下面的命令： 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 耐心等待一会儿，然后你就会发现你的终端变成了彩色的了。 [ 5112](http://img3.tbcdn.cn/L1/461/1/379712ed6ac5b61c40224f663ccd4ce4c4ab0180) 图5.1.1-2 你可以修改终端的Profile，选择深色背景profile，这样就比较炫酷了。如果你对默认的Oh My ZSH的配色不满意，请参考这里找到你喜欢的配色。 5.1.2 替换系统默认终端 – iTerm 2如果你经常使用终端，那么推荐你使用iTerm 2来替代系统自带的终端。关于iTerm 2的特性，请看这里。 这里我只介绍一个小技巧，我想设置一个快捷键假设为F12，在任意场合，我按一下快捷键F12就弹出终端，输入一些命令执行后，再按一下F12终端就自动隐藏，这对经常使用终端的人，例如经常ssh连接服务器的人来说实在太方便了。 设置过程如下： 系统已经默认将F12分配给Show Dashboard，需要先取消这个设置。 打开System Preferences，选择Keyboard，切换到Shortcuts这个Tab下，点击Mission Control，取消对应F12的快捷键。[ 5121](http://img4.tbcdn.cn/L1/461/1/41c698397b3249cdb30157c108a9e918bcb5de19) 图5.1.2-1 打开iTerm的Preferences...， 在ProfilesTab里面，点击下面的[+]添加一个新的profile，为什么要新建一个profile？答案是为了定制将来弹出的终端样式和大小等等参数。新的profile假设命名为guake，(注：guake这个名称是为了向Linux下的Guake终端致敬)，你可以自己任意起个名称，下面会用到。 [ 5122](http://img2.tbcdn.cn/L1/461/1/628bb16fba1881c3afd612b0e0480f5a36401550) 图5.1.2-2 再切换到WindowTab下，将Style，Screen和Space这3个值设置和下图一样。 [ 5123](http://img1.tbcdn.cn/L1/461/1/b24f89513f3965239bbeca6e4db3f325112ea5af) 图5.1.2-3 再切换到KeysTab下，设置如下图所示的HotkeyF12。 [ 5124](http://img2.tbcdn.cn/L1/461/1/3748ce750bddc07aa13e22cc8ebbc03f2f396446) 图5.1.2-4 现在你按下F12，就立即得到一个占满全屏的黑色命令行终端，再按一下F12隐藏终端，非常的方便。 5.2 终端下的命令管理 – HomebrewMac App Store你一定非常熟悉了，它可以帮你下载和安装大部分常见的软件。 在终端下，我们也需要一个App Store一样的管理程序，当你需要安装某个终端下的新命令的时候，这个程序可以帮助我们自动下载该命令以及相关的依赖，甚至在下载以后做必要的编译和环境设置。 Homebrew就是这样一款终端下的命令程序包管理器，安装非常简单，复制如下命令在终端下运行，按回车并输入密码后等待安装成功： 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 下面是安装截图： [ 521](http://img4.tbcdn.cn/L1/461/1/d97a24018bf9c6a95000f66b46800f7c3d9ff208) 图5.2-1 curl和wget是命令行下面常用的命令，其中curl已经默认安装在OS X中了，但是wget没有默认安装，下面演示如何使用Homebrew来安装wget。 1brew install wget 下面是运行截图：[ 522](http://img4.tbcdn.cn/L1/461/1/c821f88dc7fa44040ea4261a57f6906fcc41a822) 图5.2-2 5.3 终端下管理非终端软件 – Homebrew Cask因为Apple不允许第三方的浏览器进入Mac App Store，如果你想要安装Google Chrome，只能去Google网站下载后运行安装文件。这一类App Store没有的非终端下的软件能不能享受Homebrew一样的命令行安装的便捷性呢？ Homebrew Cask就是这样一款终端下的程序管理器，它扩展了Homebrew，作为Mac App Store的有益补充，方便你快速维护日常软件的安装升级和卸载，复制如下命令在终端下运行，按回车后等待安装成功： 1brew install caskroom/cask/brew-cask 下面是运行截图： [ 531](http://img2.tbcdn.cn/L1/461/1/fcc161f5926170d0d2bb3ecaf9be280b563b1726) 图5.3-1 那如何使用Homebrew Cask来安装Google Chrome呢？ 首先使用chrome作为关键字查找一下： 1&gt; brew cask search chrome ==&gt; Partial matches chrome-devtools chrome-remote-desktop-host chromecast google-chrome 上面的命令运行后列出了4个候选项，很明显最后一个google-chrome就是我们要安装的，继续输入 1&gt; brew cask install google-chrome 下面只需要稍微等一会儿，最新版的Google Chrome就乖乖的安装在你的MacBook里面了。 5.4 Java开发环境搭建5.4.1 安装Java和Maven现在OS X没有默认安装JDK，如果你在终端输入java，系统会引导你到Oracle网站去下载，然后自己点击下载文件来安装，这个过程一点都不酷，而且不能自动化。现在你有了Homebrew Cask，只要输入如下命令，Java就可以自动安装好啦。 1brew cask install java 现在最近版本的JDK是1.8，Homebrew默认安装最新版软件，如果你要安装非最新版的JDK，那么去Oracle网站下载吧，Homebrew的多版本支持不是很好用。 同样的，输入如下命令来安装Maven最新版。 1brew install maven 在开发中，你很可能会碰到这个错误java.security.InvalidKeyException: Illegal key size or default parameters，那是因为美国对出口软件加密算法长度的限制，你需要去如下链接下载补丁包： JCE Unlimited Policy for JDK 6 JCE Unlimited Policy for JDK 7 JCE Unlimited Policy for JDK 8 补丁替换路径为${java.home}/jre/lib/security/，大约如下所示： 1/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib/security 5.4.2 安装版本控制软件 – SmartGit &amp; SmartSVN如果代码就是生命，版本控制系统就是时光机。Git和Subversion分别是现在最流行的2个版本控制系统，SmartGit和SmartSVN分别是他们的一个第三方客户端，当然他们有很多第三方客户端，我觉得SmartGit和SmartSVN是最好用的。 5.4.3 安装和配置IDE – IntelliJ IDEAIntelliJ IDEA作为最智能的Java IDE，推荐所有Java开发人员使用，你可以在这里下载安装文件，或者使用如下的Homebrew Cask命令来下载安装： 1brew cask install intellij-idea 打开IDEA，推荐选择Darcula主题，快捷键映射选择I&#39;ve never used IDEA, 一路确认下去进入主界面。 推荐使用版本控制客户端(SmartGit &amp; SmartSVN)下载好源代码后，再使用IDEA导入源代码，原因是如果用IDEA来checkout源代码，一边checkout一边分析代码，对于有多个模块的Maven项目，IDEA动态检测Spring框架的配置文件可能会得不到及时而完整的依赖分析。 [ 5421](http://img2.tbcdn.cn/L1/461/1/872703cfd2eb192076b0e3598938cfed57d96653) 图5.4.2-1 我们假设项目是基于Maven的，如下图，选择Maven：[ 5422](http://img2.tbcdn.cn/L1/461/1/e872d8bc7b908ec4dbf4362608cac90cbd4838ce) 图5.4.2-2 一路点击[Next]进入主界面，IDEA会帮我们自动检测到依赖的框架，如图IDEA发现我们使用了OSGI和Spring框架，点击[Configure]，然后去除OSGI依赖，因为SOFA项目不是完全实现OSGI规范的，勾选Spring配置文件。 [ 5423](http://img1.tbcdn.cn/L1/461/1/c5ab9029cd05ae5ee196ba94588e64b4957ec712) 图5.4.2-3 IDEA会在你首次导入一个项目的时候建立索引，耐心等待索引建立完成，之后的查找就会非常快速。 工具的意义 工欲善其事，必先利其器，工具永远都是用来解决问题的，没必要为了工具而工具，一切工具都是为了能快速准确的完成工作和学习任务而服务。","categories":[],"tags":[]},{"title":"","slug":"sql/MySQL变量","date":"2018-05-19T13:21:38.000Z","updated":"2018-05-19T13:34:49.000Z","comments":true,"path":"2018/05/19/sql/MySQL变量/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/sql/MySQL变量/","excerpt":"","text":"mysql变量MySQL中的变量以定义者分类分为用户变量与系统变量。 以作用域分类为全局变量，会话变量。 用户变量：以”@”开始，形式为”@变量名”。用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效 系统变量：定义时，以如下两种形式出现，set GLOBAL 变量名 或者 set @@global.变量名，对所有客户端生效。只有具有super权限才可以设置全局变量 会话变量：只对连接的客户端有效。 局部变量：作用范围在begin到end语句块之间。在该语句块里设置的变量。declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量 通俗理解术语之间的区别： 用户定义的变量就叫用户变量。这样理解的话，会话变量和全局变量都可以是用户定义的变量。只是他们是对当前客户端生效还是对所有客户端生效的区别了。所以，用户变量包括了会话变量和全局变量 局部变量与用户变量的区分在于两点:1.用户变量是以”@”开头的。局部变量没有这个符号。2.定义变量不同。用户变量使用set语句，局部变量使用declare语句定义 3.作用范围。局部变量只在begin-end语句块之间有效。在begin-end语句块运行完之后，局部变量就消失了。 所以，最后它们之间的层次关系是：变量包括局部变量和用户变量。用户变量包括会话变量和全局变量。 mysql declare定义变量mysql declare用于定义变量，在存储过程和函数中通过declare定义变量在BEGIN…END中，且在语句之前。并且可以通过重复定义多个变量 declare变量的作用范围同编程里面类似，在这里一般是在对应的begin和end之间。在end之后这个变量就没有作用了，不能使用了。这个同编程一样。 注意：declare定义的变量名不能带‘@’符号，mysql在这点做的确实不够直观，往往变量名会被错成参数或者字段名。 mysql存储过程中使用declare定义变量，实例如下： 12345678910111213DROP PROCEDURE IF EXISTS insert_ten_rows $$CREATE PROCEDURE insert_ten_rows () BEGIN DECLARE crs INT DEFAULT 0; WHILE crs &lt; 10 DO INSERT INTO `continent`(`name`) VALUES (&apos;cont&apos;+crs); SET crs = crs + 1; END WHILE; END $$DELIMITER ;12345678910111213 mysql SET定义变量mysql set也可以用来定于变量，定义变量的形式是以”@”开始，如：”@变量名”。 mysql SET定义变量实例： 123456789101112131415161718192021222324mysql&gt; SET @t1=0, @t2=1, @t3=2;mysql&gt; select @t1;+------+| @t1 |+------+| 0 |+------+mysql&gt; select @t2;+------+| @t2 |+------+| 1 |+------+mysql&gt; select @t3;+------+| @t3 |+------+| 2 |+------+mysql&gt; 复杂一点的实例： 12345678910mysql&gt; SET @t1=0, @t2=1, @t3=2;mysql&gt; SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;+----------------------+------+------+------+| @t1:=(@t2:=1)+@t3:=4 | @t1 | @t2 | @t3 |+----------------------+------+------+------+| 5 | 5 | 1 | 4 |+----------------------+------+------+------+12345678910 mysql declare和set定义变量的区别mysql declare和set定义变量，除了一个不加@和一个加@这个区别之外，还有以下区别： declare用来定义局部变量 @用来定义会话变量 declare变量的作用范围同编程里面类似，在这里一般是在对应的begin和end之间。在end之后这个变量就没有作用了，不能使用了。这个同编程一样。 另外有种变量叫做会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，叫做会话变量，代表整个会话过程他都是有作用的，这个有点类似于全局变量一样。这种变量用途比较广，因为只要在一个会话内(就是某个应用的一个连接过程中)，这个变量可以在被调用的存储过程或者代码之间共享数据。 MySQL的用户变量和系统变量MySQL中的变量分为用户变量与系统变量。 一、用户变量用户变量是指与数据库的一次连接中声明的变量，在连接断开后就会消失。1、变量命名变量名必须以@开头，例如@name 2、声明及赋值声明与赋值的方法两种，一种是使用set语句，一种是使用select语句。 12345/*使用set语句声明变量并赋值（注：声明的时候必须赋初值）*/set @name=&apos;zhangsan&apos;;/*使用select语句声明并赋值*/select @age:=23; 3、查看用户变量查看变量使用select语句 1select @name; 二、系统变量系统变量又分为全局变量与会话变量。 全局变量在MySQL启动的时候由服务器自动将它们初始化为默认值，这些默认值可以通过更改my.ini这个文件来更改。 会话变量在每次建立一个新的连接的时候，由MySQL来初始化，MySQL会将当前所有全局变量的值复制一份，作为会话变量。也就是说，如果在建立会话以后，没有手动更改过会话变量与全局变量的值，那所有这些变量的值都是一样的。 全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话（也就是当前的数据库连接）。 1、查看系统变量查看全局变量可以使用show global variables语句，查看会话变量可以使用show session variables或者show variables语句。这些语句会列出所有的变量，如果需要查看某个变量，可以在后面加like进行模糊查询，例如：show variables like ‘%sql_mode%’。 另外，还可以使用select语句来查看系统变量。会话变量：select @@ session/local.varname;全局变量：select @@global.varname; 1234567891011121314/*查询所有的全局变量*/show global variables;/*查询所有的会话变量*/show variables;/*查询名字中含有sql_mode的全局变量*/show global variables like &apos;%sql_mode%&apos;;select @@global.varname;/*查询名字中含有sql_mode的会话变量*/show variables like &apos;%sql_mode%&apos;;select @@session.varname;select @@local.varname; 2、修改系统变量跟修改用户变量相同，修改系统变量使用的也是set语句。当需要修改会话变量时，可以使用 1set session varname=value //或者 set @@session.varname=value 当需要修改系统变量时，可以使用 12set global varname=value //或者set @@ global.varname=value","categories":[],"tags":[]},{"title":"","slug":"Linux/security/fail2ban ssh security","date":"2018-05-19T06:54:10.000Z","updated":"2018-05-19T07:46:42.000Z","comments":true,"path":"2018/05/19/Linux/security/fail2ban ssh security/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/Linux/security/fail2ban ssh security/","excerpt":"","text":"CentOS下fail2ban安装与配置教程介绍fail2ban用于监视系统日志，通过正则表达式匹配错误错误信息，设置一定的条件触发相应的屏蔽动作。在笔者的vps里，主要是用于ssh的保护，ssh登录错误的时候会记录到 /var/log/secure，fail2ban通过 gamin检测到新增日志，10min内同一ip连续登陆5次就会封禁30min。当然，一个足够的强密码也是必须的！ 官方主页：http://www.fail2ban.org/wiki/index.php/Main_Page github：https://github.com/fail2ban/fail2ban 安装这里有两种安装方式，使用yum安装或者通过rpm安装。笔者的系统版本是CentOS-6.7 yum安装 12345#首先安装epel源，如果已经安装可以跳过此步yum install -y epel-release#然后安装fail2ban：yum install -y fail2ban rpm安装 fail2ban依赖下面四个安装包：ed： Linux 操作系统下最简单的文本编辑器，以行为单位对文件进行编辑gamin-python： python调用gamin的一个模块，gamin实现了一套监控文件变化的机制ipset： 管理 ip地址/端口/mac地址 的模块，一般用于辅助提高iptables的性能python-inotify： python的一个模块，实现了文件变化通知机制 1234567891011#其中前三个都可以使用yum安装：yum -y install ed gamin-python ipset python-inotify#然后根据系统架构不同，使用不同的rpm包安装：#i386rpm -Uvh ftp://rpmfind.net/linux/atrpms/el6-i386/atrpms/stable/python-inotify-0.9.1-1.1.el6.noarch.rpmrpm -Uvh ftp://rpmfind.net/linux/epel/testing/6/i386/fail2ban-0.9.3-1.el6.noarch.rpm#x86-64rpm -Uvh ftp://rpmfind.net/linux/atrpms/el6-x86_64/atrpms/stable/python-inotify-0.9.1-1.1.el6.noarch.rpmrpm -Uvh ftp://rpmfind.net/linux/epel/testing/6/x86_64/fail2ban-0.9.3-1.el6.noarch.rpm 配置目前的最新版本是0.9.3 12345678配置文件位于：/etc/fail2ban/action.d/ //采取相对应措施的目录/etc/fail2ban/fail2ban.conf //fail2ban的配置文件/etc/fail2ban/fail2ban.d/ //fail2ban的配置文件目录/etc/fail2ban/filter.d/ //具体过滤规则文件目录/etc/fail2ban/jail.conf //阻挡设定文件/etc/fail2ban/jail.d/ //阻挡设定文件的目录/etc/fail2ban/paths-*.conf //不同linux发行版下路径的相关设置，在jail.conf的[INCLUDES]里指定 fail2ban.conf 是针对fail2ban程序运行本身的一些设置。jail.conf 是fail2ban的业务功能设置，里面设置了需要监控那些服务以及如何保护等，里边已经针对常用的服务提供了监控方案，比如sshd、apache、3proxy等，笔者只启用了sshd的保护。 jail.conf里的注释十分丰富，简单介绍一些基本的设置： 123456789101112131415#所有监控项的默认设置[DEFAULT]#忽略的ip，这里表示本机ip将永不被封禁ignoreip = 127.0.0.1/8#封禁时间，单位为秒bantime = 600#监控周期，表示在600s内，失败次数达到maxretry的主机将会被封禁findtime = 600#最大重试次数，表示在findtime内，失败次数达到5次的主机将会被封禁maxretry = 5#默认关闭对所有服务的保护enabled = false 启用sshd的保护很简单，在jail.conf的[sshd]中加上一行enabled = true就可以： 12345678# SSH servers#[sshd]port = sshlogpath = %(sshd_log)senabled = true 最后就是设置服务自启动了 12chkconfig fail2ban onservice fail2ban start CentOS7的补充说明在CentOS7下可能会出现类似错误 1234567891011122017-04-19 10:19:30,335 fail2ban.action [526]: ERROR ipset create fail2ban-sshd hash:ip timeout 600firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -p tcp -m multiport --dports ssh -m set --match-set fail2ban-sshd src -j REJECT --reject-with icmp-port-unreachable -- stdout: &apos;&apos;2017-04-19 10:19:30,335 fail2ban.action [526]: ERROR ipset create fail2ban-sshd hash:ip timeout 600firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -p tcp -m multiport --dports ssh -m set --match-set fail2ban-sshd src -j REJECT --reject-with icmp-port-unreachable -- stderr: &apos;ipset v6.19: Cannot open session to kernel.\\n\\x1b[91mFirewallD is not running\\x1b[00m\\n&apos;2017-04-19 10:19:30,336 fail2ban.action [526]: ERROR ipset create fail2ban-sshd hash:ip timeout 600firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -p tcp -m multiport --dports ssh -m set --match-set fail2ban-sshd src -j REJECT --reject-with icmp-port-unreachable -- killed with signal 124 (return code: 252)2017-04-19 10:19:30,336 fail2ban.actions [526]: ERROR Failed to start jail &apos;sshd&apos; action &apos;firewallcmd-ipset&apos;: Error starting action……2017-04-19 10:19:41,529 fail2ban.action [526]: ERROR ipset add fail2ban-sshd 116.31.116.14 timeout 600 -exist -- stdout: &apos;&apos;2017-04-19 10:19:41,530 fail2ban.action [526]: ERROR ipset add fail2ban-sshd 116.31.116.14 timeout 600 -exist -- stderr: &apos;ipset v6.19: Cannot open session to kernel.\\n&apos;2017-04-19 10:19:41,530 fail2ban.action [526]: ERROR ipset add fail2ban-sshd 116.31.116.14 timeout 600 -exist -- returned 12017-04-19 10:19:41,531 fail2ban.actions [526]: ERROR Failed to execute ban jail &apos;sshd&apos; action &apos;firewallcmd-ipset&apos; info &apos;CallingMap(&#123;&apos;ipjailmatches&apos;: &lt;function &lt;lambda&gt; at 0xb08578&gt;, &apos;matches&apos;: &apos;[……]&apos;, &apos;ip&apos;: &apos;116.31.116.14&apos;, &apos;ipmatches&apos;: &lt;function &lt;lambda&gt; at 0xb08410&gt;, &apos;ipfailures&apos;: &lt;function &lt;lambda&gt; at 0xb086e0&gt;, &apos;time&apos;: 1492568381.402617, &apos;failures&apos;: 40, &apos;ipjailfailures&apos;: &lt;function &lt;lambda&gt; at 0xb08500&gt;&#125;)&apos;: Error banning 116.31.116.14 CentOS7使用了firewall作为默认防火墙，而fail2ban默认使用firewallcmd-ipset作为封禁动作，但是在基于openvz的vps平台上是不能调用ipset的，所以需要做一些更改。更改/etc/fail2ban/jail.d/00-firewalld.conf文件，将其更改为使用firewallcmd-new 123[DEFAULT]#banaction = firewallcmd-ipsetbanaction = firewallcmd-new FAQQ：日志中出现Error starting action错误 123456fail2ban.server[2228]: INFO Jail sshd is not a JournalFilter instancefail2ban.jail[2228]: INFO Jail &apos;sshd&apos; startedfail2ban.action[2228]: ERROR iptables -w -N f2b-sshd#012iptables -w -A f2b-sshd -j RETURN#012iptables -w -I INPUT -p tcp -m multiport --dports ssh -j f2b-sshd -- stdout: &apos;&apos;fail2ban.action[2228]: ERROR iptables -w -N f2b-sshd#012iptables -w -A f2b-sshd -j RETURN#012iptables -w -I INPUT -p tcp -m multiport --dports ssh -j f2b-sshd -- stderr: &apos;&apos;fail2ban.action[2228]: ERROR iptables -w -N f2b-sshd#012iptables -w -A f2b-sshd -j RETURN#012iptables -w -I INPUT -p tcp -m multiport --dports ssh -j f2b-sshd -- returned 2fail2ban.actions[2228]: ERROR Failed to start jail &apos;sshd&apos; action &apos;iptables-multiport&apos;: Error starting action A：fail2ban-0.9.3在执行iptable命令时，加上了-w参数用于防止冲突，但是iptables-1.4.20才有这个参数，而CentOS6.7下的是iptables-1.4.7,因此导致iptable的命令执行失败，Github有这个问题：https://github.com/fail2ban/fail2ban/issues/1122 一个折中方案是，修改/etc/fail2ban/action.d/iptables-common.conf文件，去掉，也就是-w参数： 12345# Option: iptables# Notes.: Actual command to be executed, including common to all calls options# Values: STRING#iptables = iptables &lt;lockingopt&gt;iptables = iptables Q：日志中出现ERROR findFailure failed to parse timeText错误： 1234Sep 21 09:57:51 12345 fail2ban.filter[1588]: ERROR findFailure failed to parse timeText: Sep 21 09:57:26 1234#在fail2ban-0.9.2 是这样的错误Sep 21 10:05:37 12345 fail2ban.filterpyinotify[1305]: ERROR Error in FilterPyinotify callback: mktime argument out of range A：这个错误源于一个不算bug的bug，当用户的hostname前面为数字的时候就会触发 12[root@12345 ~]# hostname12345.domain.com 在日志中，12345.domain.com前面的12345被当作是年份被解析了，笔者的vps很不幸，hostname就是数字开头的，而且当时的版本还是fail2ban-0.9.2，排错过程十分辛苦。解决的方法有很多，比如最直接的修改hostname 1vi /etc/sysconfig/network 而笔者采用的方案是修改 rsyslog 的日志格式： 123456vi /etc/rsyslog.conf# Use default timestamp format#$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat$template FileFormat,&quot;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\\n&quot;$ActionFileDefaultTemplate FileFormat 重启 rsyslog 服务 1service rsyslog restart 关于rsyslog日志格式的说明：http://www.rsyslog.com/doc/v8-stable/configuration/templates.html#reserved-template-names","categories":[],"tags":[]},{"title":"","slug":"Linux/postfix mail","date":"2018-05-19T06:12:38.000Z","updated":"2018-05-19T06:13:50.000Z","comments":true,"path":"2018/05/19/Linux/postfix mail/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/Linux/postfix mail/","excerpt":"","text":"Centos 7安装Postfix用于发送提醒邮件发布时间：2015-03-19 更新时间：2015-03-26 作者：boxwang 本文仅介绍Centos 7安装Postfix用于发送提醒邮件，并非搭建完整邮件服务器教程。 1. 卸载sendmail，没有安装sendmail的跳过 1yum remove sendmail 2. 安装 Postfix 1yum install postfix 3. 更改默认MTA为Postfix 1/usr/sbin/alternatives --set mta /usr/sbin/sendmail.postfix 4. 检查是否将MTA改为Postfix 1alternatives --display mta 5. 配置Postfix，修改main.cf 1vi /etc/postfix/main.cf 查找以下各项，去掉最前面的#，参考说明修改 1234567myhostname = www.ifshow.commydomain = ifshow.commyorigin = $mydomaininet_interfaces = allmydestination = $myhostname, localhost.$mydomain, localhost, $mydomainrelay_domains =home_mailbox = Maildir/ myhostname是服务器的主机名，mydomain是域名，myorigin定义邮箱后缀，inet_interfaces是指定使用的网络接口，relay_domains是转发域留空，home_mailbox是指定邮箱格式。 6. 启动Postfix并设为开机自启 12systemctl start postfix.servicesystemctl enable postfix.service 到此完成配置，其它服务已经能够通过postfix发送提醒邮件。由于只发邮件，所以防火墙不必开启POP3、SMTP等服务端口。","categories":[],"tags":[]},{"title":"","slug":"Linux/security/firewall-cmd","date":"2018-05-19T05:01:57.000Z","updated":"2018-05-19T05:03:16.000Z","comments":true,"path":"2018/05/19/Linux/security/firewall-cmd/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/Linux/security/firewall-cmd/","excerpt":"","text":"Fail2ban防御暴力破解密码fail2ban可以监视你的系统日志，然后匹配日志的错误信息（正则表达式匹配）执行相应的屏蔽动作（一般情况下是调用防火墙屏蔽）。比如有人在试探你的SSH、SMTP、FTP密码，只要达到你预设的次数，fail2ban就会调用防火墙屏蔽这个IP，而且可以发送e-mail通知系统管理员。 安装EPEL源 1yum -y install epel-release.noarch 安装支持firewalld的fail2ban 1yum -y install fail2ban-firewalld fail2ban-systemd 安装相关软件，让fail2ban可以通过postfix发送提醒邮件（可选） 安装配置postfix用于发送提醒邮件请点这里 123yum -y install postfix whois fail2ban-sendmailsystemctl enable postfixsystemctl start postfix 设定fail2ban 新建配置文件jail.local 1vi /etc/fail2ban/jail.local 输入以下内容后保存退出 12345678910111213[DEFAULT]bantime = 86400findtime = 300maxretry = 3sender = fail2ban@ifshow.comdestemail = admin@ifshow.comaction = %(action_mwl)s[sshd]enabled = trueport = 2345[sshd-ddos]enabled = trueport = 2345 bantime是被封IP禁止访问的时间，设定值为24小时，单位是秒。findtime是检测时间，在此时间内超过规定的次数会激活fail2ban，单位是秒。maxretry是允许错误登录的最大次数，和findtime配合使用。sender为邮件发送者，destemail为接收通知邮箱。action是触发fail2ban采取的动作，action_mwl为禁IP+发通知邮件+写入日志。sshd区块的enabled = true开启对SSH服务的防护，port为SSH的自定义端口。sshd-ddos区块的enabled = true开启SSH-DDOS防护，port为SSH的自定义端口。 如果装有vsftpd，在配置文件最后加上以下内容（port为vsftpd的登录和数据端口） 123[vsftpd]enabled = trueport = 2121,2122 启用fail2ban并设为开机自启 12systemctl enable fail2bansystemctl start fail2ban fail2ban常用命令 查看SSH服务监护状态，能看到当前被禁IP。 1fail2ban-client status sshd 在SSH监护服务忽略IP列表（白名单）中添加IP 192.168.111.111 1fail2ban-client set sshd addignoreip 192.168.111.111 在SSH监护服务忽略IP列表（白名单）中删除IP 192.168.111.111 1fail2ban-client set sshd delignoreip 192.168.111.111 查看fail2ban日志 1tail /var/log/fail2ban.log","categories":[],"tags":[]},{"title":"","slug":"Linux/firewall","date":"2018-05-19T03:52:09.000Z","updated":"2018-05-19T03:59:11.000Z","comments":true,"path":"2018/05/19/Linux/firewall/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/Linux/firewall/","excerpt":"","text":"firewall-cmd –permanent –zone=public –add-rich-rule=”rule family=”ipv4” source address=”180.151.83.30/24” service name=”ssh” reject” 123firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;180.151.83.30/24&apos; port port=80 protocol=tcp reject&quot;firewall-cmd --reload `##重新加载防火墙配置，不然firewall-cmd –list-all-zones不会显示刚加上的规则`","categories":[],"tags":[]},{"title":"","slug":"TODOlist/2018-5-19","date":"2018-05-18T17:47:14.000Z","updated":"2018-05-19T03:52:18.000Z","comments":true,"path":"2018/05/19/TODOlist/2018-5-19/","link":"","permalink":"http://io.stelawliet.top/2018/05/19/TODOlist/2018-5-19/","excerpt":"","text":"MySQL procedure out inout MySQL variables MySQL 触发器 整理快速排序代码","categories":[],"tags":[]},{"title":"","slug":"MD/哔哩哔哩/补","date":"2018-05-18T14:14:08.000Z","updated":"2018-05-19T17:54:25.000Z","comments":true,"path":"2018/05/18/MD/哔哩哔哩/补/","link":"","permalink":"http://io.stelawliet.top/2018/05/18/MD/哔哩哔哩/补/","excerpt":"","text":"2017 少女终末旅行 Just Because 学员默示录 噬神者 魔弹之王与战姬","categories":[],"tags":[]},{"title":"","slug":"sql/mysql导入导出","date":"2018-05-18T02:58:08.000Z","updated":"2018-05-18T03:05:51.000Z","comments":true,"path":"2018/05/18/sql/mysql导入导出/","link":"","permalink":"http://io.stelawliet.top/2018/05/18/sql/mysql导入导出/","excerpt":"","text":"backup mysql databases in shelldumpmysqldump -h${IP} -u${username} -p ${password} ${db_name}&gt;${.sql_dir} db_name 多个时用空格分开 1➜ workspace mysqldump -hwww.stelawliet.top -uroot -p society_manage_db&gt; ~/workspace/society_manage_db.sql inputmysql -h${IP} -u${username} -p ${password} ${db_name}&lt;${.sql_dir} 1➜ workspace mysql -hca.stelawliet.top -uroot -p db_test&lt;society_manage_db.sql","categories":[],"tags":[]},{"title":"","slug":"MD/mem/哲学","date":"2018-05-17T18:22:47.000Z","updated":"2018-05-22T17:24:50.000Z","comments":true,"path":"2018/05/18/MD/mem/哲学/","link":"","permalink":"http://io.stelawliet.top/2018/05/18/MD/mem/哲学/","excerpt":"","text":"拥有希望的哲学是唯一的救赎。","categories":[],"tags":[]},{"title":"数据类型大小","slug":"Java/jdk1.8新特性/接口","date":"2018-05-16T10:07:59.000Z","updated":"2018-06-29T13:28:18.000Z","comments":true,"path":"2018/05/16/Java/jdk1.8新特性/接口/","link":"","permalink":"http://io.stelawliet.top/2018/05/16/Java/jdk1.8新特性/接口/","excerpt":"","text":"数据类型 类型 字节x8位 byte 1 short 2 int 4 long 8 float 4 double 8 char 2 boolean 1 面向对象 封装 private 私有只有本对象才能访问 对象的初始化 new 的过程 继承 多态","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/tags/java/"}]},{"title":"","slug":"Vue/Untitled","date":"2018-05-15T16:32:31.000Z","updated":"2018-05-15T16:32:31.000Z","comments":true,"path":"2018/05/16/Vue/Untitled/","link":"","permalink":"http://io.stelawliet.top/2018/05/16/Vue/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"sql/mysql笔记","date":"2018-05-12T15:57:37.000Z","updated":"2018-05-12T15:57:51.000Z","comments":true,"path":"2018/05/12/sql/mysql笔记/","link":"","permalink":"http://io.stelawliet.top/2018/05/12/sql/mysql笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Linux/nginx负载均衡","date":"2018-05-12T14:33:57.000Z","updated":"2018-05-13T15:42:38.000Z","comments":true,"path":"2018/05/12/Linux/nginx负载均衡/","link":"","permalink":"http://io.stelawliet.top/2018/05/12/Linux/nginx负载均衡/","excerpt":"","text":"1234567891011upstream springboot &#123; server 127.0.0.1:7071 weight=1 max_fails=2 fail_timeout=30s; server 127.0.0.1:7072 weight=1 max_fails=2 fail_timeout=30s;&#125; server&#123; listen 7070; access_log /data/wwwlogs/7070_nginx.log combined; location / &#123; proxy_pass http://springboot; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"sql/查询错误","date":"2018-05-12T14:33:36.000Z","updated":"2018-05-19T05:01:15.000Z","comments":true,"path":"2018/05/12/sql/查询错误/","link":"","permalink":"http://io.stelawliet.top/2018/05/12/sql/查询错误/","excerpt":"","text":"mysql语句过长PacketTooBigExceptioncom.mysql.jdbc.PacketTooBigException: Packet for query is too large (3158064） shell进入mysql set global max_allowed_packet = 2*1024*1024*10｀ 然后关闭连接 重新进入运行 show VARIABLES like &#39;%max_allowed_packet%&#39;; 查看下max_allowed_packet是否编辑成功 123456789101112131415mysql&gt; show VARIABLES like &apos;%max_allowed_packet%&apos;;+--------------------------+------------+| Variable_name | Value |+--------------------------+------------+| max_allowed_packet | 20971520 || slave_max_allowed_packet | 1073741824 |+--------------------------+------------+2 rows in set (0.17 sec)","categories":[],"tags":[]},{"title":"","slug":"Vue/Web Storage","date":"2018-05-12T07:19:28.000Z","updated":"2018-05-12T07:19:28.000Z","comments":true,"path":"2018/05/12/Vue/Web Storage/","link":"","permalink":"http://io.stelawliet.top/2018/05/12/Vue/Web Storage/","excerpt":"","text":"Web Storage：浏览器端数据储存机制来自《JavaScript 标准参考教程（alpha）》，by 阮一峰 目录 概述 操作方法 存入/读取数据 清除数据 遍历操作 storage事件 参考链接 概述这个API的作用是，使得网页可以在浏览器端储存数据。它分成两类：sessionStorage和localStorage。 sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的属性和方法完全一样。 它们很像cookie机制的强化版，能够动用大得多的存储空间。目前，每个域名的存储上限视浏览器而定，Chrome是2.5MB，Firefox和Opera是5MB，IE是10MB。其中，Firefox的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，在Firefox中，a.example.com和b.example.com共享5MB的存储空间。另外，与Cookie一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取。 通过检查window对象是否包含sessionStorage和localStorage属性，可以确定浏览器是否支持这两个对象。 12345678910111213141516function checkStorageSupport() &#123; // sessionStorage if (window.sessionStorage) &#123; return true; &#125; else &#123; return false; &#125; // localStorage if (window.localStorage) &#123; return true; &#125; else &#123; return false; &#125;&#125; 操作方法存入/读取数据sessionStorage和localStorage保存的数据，都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。 123sessionStorage.setItem(&quot;key&quot;,&quot;value&quot;);localStorage.setItem(&quot;key&quot;,&quot;value&quot;); 读取数据使用getItem方法。它只有一个参数，就是键名。 123var valueSession = sessionStorage.getItem(&quot;key&quot;);var valueLocal = localStorage.getItem(&quot;key&quot;); 清除数据removeItem方法用于清除某个键名对应的数据。 123sessionStorage.removeItem(&apos;key&apos;);localStorage.removeItem(&apos;key&apos;); clear方法用于清除所有保存的数据。 123sessionStorage.clear();localStorage.clear(); 遍历操作利用length属性和key方法，可以遍历所有的键。 123for(var i = 0; i &lt; localStorage.length; i++)&#123; console.log(localStorage.key(i));&#125; 其中的key方法，根据位置（从0开始）获得键值。 1localStorage.key(1); storage事件当储存的数据发生变化时，会触发storage事件。我们可以指定这个事件的回调函数。 1window.addEventListener(&quot;storage&quot;,onStorageChange); 回调函数接受一个event对象作为参数。这个event对象的key属性，保存发生变化的键名。 123function onStorageChange(e) &#123; console.log(e.key);&#125; 除了key属性，event对象的属性还有三个： oldValue：更新前的值。如果该键为新增加，则这个属性为null。 newValue：更新后的值。如果该键被删除，则这个属性为null。 url：原始触发storage事件的那个网页的网址。 值得特别注意的是，该事件不在导致数据变化的当前页面触发。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变 localStorage 的数据时，其他所有页面的storage事件会被触发，而原始页面并不触发storage事件。可以通过这种机制，实现多个窗口之间的通信。所有浏览器之中，只有 IE 浏览器除外，它会在所有页面触发storage事件。 参考链接 Ryan Stewart，Introducing the HTML5 storage APIs Getting Started with LocalStorage Feross Aboukhadijeh, Introducing the HTML5 Hard Disk Filler™ API Ben Summers, Inter-window messaging using localStorage Stack Overflow, Why does Internet Explorer fire the window “storage” event on the window that stored the data?","categories":[],"tags":[]},{"title":"","slug":"Vue/storage","date":"2018-05-12T07:18:50.000Z","updated":"2018-05-12T07:19:04.000Z","comments":true,"path":"2018/05/12/Vue/storage/","link":"","permalink":"http://io.stelawliet.top/2018/05/12/Vue/storage/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"MD/论文/springboot","date":"2018-05-06T16:50:22.000Z","updated":"2018-05-06T16:50:40.000Z","comments":true,"path":"2018/05/07/MD/论文/springboot/","link":"","permalink":"http://io.stelawliet.top/2018/05/07/MD/论文/springboot/","excerpt":"","text":"Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache License 2.0开源许可协议的形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 Spring框架是一个开源的Java/ Java EE全栈应用程序框架，作为Apache License 2.0开源许可证分发，以及.NET平台的可移植版本。 该框架基于专业一对一Java EE设计和开发代码书（0-7645-4385-7 ISBN），最初由Rod Johnson，Juergen Hoeller开发。 Spring框架提供了一种简单的开发方法。这种开发将避免大量的属性文件和助手类，这可能会导致底层代码变得令人困惑。 Spring中包含的关键特性 强大的基于JavaBeans的采用控制反转（Inversion of Control，IoC）原则的配置管理，使得应用程序的组建更加快捷简易。一个可用于Java EE等运行环境的核心Bean工厂。数据库事务的一般化抽象层，允许声明式（Declarative）事务管理器，简化事务的划分使之与底层无关。内建的针对JTA和单个JDBC数据源的一般化策略，使Spring的事务支持不要求Java EE环境，这与一般的JTA或者EJBCMT相反。JDBC 抽象层提供了有针对性的异常等级（不再从SQL异常中提取原始代码），简化了错误处理，大大减少了程序员的编码量。再次利用JDBC时，你无需再写出另一个’终止’（finally）模块。并且面向JDBC的异常与Spring通用数据访问对象（Data Access Object）异常等级相一致。以资源容器，DAO实现和事务策略等形式与Hibernate，JDO和MyBatis、SQL Maps集成。利用众多的翻转控制方便特性来全面支持，解决了许多典型的Hibernate集成问题。所有这些全部遵从 Spring 通用事务处理和通用数据访问对象异常等级规范。灵活的基于核心 Spring 功能的MVC网页应用程序框架。开发者通过策略接口将拥有对该框架的高度控制，因而该框架将适应于多种呈现（View）技术，例如JSP、FreeMarker、Velocity、Thymeleaf 等。值得注意的是，Spring 中间层可以轻易地结合于任何基于MVC框架的网页层，例如Struts、WebWork或Tapestry。提供诸如事务管理等服务的AOP框架。在设计应用程序 Model 时，MVC模式（例如Struts）通常难于给出一个简洁明了的框架结构。Spring 却具有能够让这部分工作变得简单的能力。程序开发员们可以使用Spring的JDBC抽象层重新设计那些复杂的框架结构。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/api","date":"2018-05-06T15:29:15.000Z","updated":"2018-05-06T15:57:54.000Z","comments":true,"path":"2018/05/06/MD/论文/api/","link":"","permalink":"http://io.stelawliet.top/2018/05/06/MD/论文/api/","excerpt":"","text":"[/society/activity],methods=[POST] [/society/activity],methods=[PUT] [/society/activity/{id}],methods=[DELETE] [/society/activity],methods=[GET] [/society/activity/{id}],methods=[GET] [/society/user/register],methods=[POST] [/society/user/login],methods=[POST] Mapped “{[/society/activity],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyActivityController.add(com.company.project.model.SocietyActivity)2018-05-06 23:28:20.478 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/activity],methods=[PUT]}” onto public com.company.project.core.Result com.company.project.web.SocietyActivityController.update(com.company.project.model.SocietyActivity)2018-05-06 23:28:20.479 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/activity/{id}],methods=[DELETE]}” onto public com.company.project.core.Result com.company.project.web.SocietyActivityController.delete(java.lang.Integer)2018-05-06 23:28:20.479 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/activity],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyActivityController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.480 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/activity/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyActivityController.detail(java.lang.Integer)2018-05-06 23:28:20.483 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/category],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyCategoryController.add(com.company.project.model.SocietyCategory)2018-05-06 23:28:20.483 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/category],methods=[PUT]}” onto public com.company.project.core.Result com.company.project.web.SocietyCategoryController.update(com.company.project.model.SocietyCategory)2018-05-06 23:28:20.483 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/category/{id}],methods=[DELETE]}” onto public com.company.project.core.Result com.company.project.web.SocietyCategoryController.delete(java.lang.Integer)2018-05-06 23:28:20.484 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/category],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyCategoryController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.484 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/category/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyCategoryController.detail(java.lang.Integer)2018-05-06 23:28:20.486 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/comment],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyCommentController.add(com.company.project.model.SocietyComment)2018-05-06 23:28:20.487 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/comment],methods=[PUT]}” onto public com.company.project.core.Result com.company.project.web.SocietyCommentController.update(com.company.project.model.SocietyComment)2018-05-06 23:28:20.487 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/comment/{id}],methods=[DELETE]}” onto public com.company.project.core.Result com.company.project.web.SocietyCommentController.delete(java.lang.Integer)2018-05-06 23:28:20.487 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/comment],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyCommentController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.488 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/comment/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyCommentController.detail(java.lang.Integer)2018-05-06 23:28:20.490 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/societyex/list],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyExController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.491 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/societyex/list/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyExController.list(java.lang.Integer)2018-05-06 23:28:20.491 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/societyex/user/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyExController.users(java.lang.Integer)2018-05-06 23:28:20.492 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/societyex/user],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyExController.users(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.495 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/info],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyInfoController.add(com.company.project.model.SocietyInfo)2018-05-06 23:28:20.495 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/info],methods=[PUT]}” onto public com.company.project.core.Result com.company.project.web.SocietyInfoController.update(com.company.project.model.SocietyInfo)2018-05-06 23:28:20.495 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/info/{id}],methods=[DELETE]}” onto public com.company.project.core.Result com.company.project.web.SocietyInfoController.delete(java.lang.Integer)2018-05-06 23:28:20.496 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/info],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyInfoController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.496 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/info/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyInfoController.detail(java.lang.Integer)2018-05-06 23:28:20.500 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/member],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyMemberController.add(com.company.project.model.SocietyMember)2018-05-06 23:28:20.517 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/member],methods=[PUT]}” onto public com.company.project.core.Result com.company.project.web.SocietyMemberController.update(com.company.project.model.SocietyMember)2018-05-06 23:28:20.518 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/member/{id}],methods=[DELETE]}” onto public com.company.project.core.Result com.company.project.web.SocietyMemberController.delete(java.lang.Integer)2018-05-06 23:28:20.518 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/member],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyMemberController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.519 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/member/{id}],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyMemberController.detail(java.lang.Integer)2018-05-06 23:28:20.529 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/user],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyUserController.add(com.company.project.model.SocietyUser)2018-05-06 23:28:20.529 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/user/register],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.SocietyUserController.register(com.company.project.model.SocietyUser)2018-05-06 23:28:20.530 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/user],methods=[PUT]}” onto public com.company.project.core.Result com.company.project.web.SocietyUserController.update(com.company.project.model.SocietyUser)2018-05-06 23:28:20.530 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/user/{id}],methods=[DELETE]}” onto public com.company.project.core.Result com.company.project.web.SocietyUserController.delete(java.lang.Integer)2018-05-06 23:28:20.531 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/user],methods=[GET]}” onto public com.company.project.core.Result com.company.project.web.SocietyUserController.list(java.lang.Integer,java.lang.Integer)2018-05-06 23:28:20.532 INFO 35837 — [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped “{[/society/user/login],methods=[POST]}” onto public com.company.project.core.Result com.company.project.web.So","categories":[],"tags":[]},{"title":"","slug":"MD/论文/ＥＳ６","date":"2018-05-06T09:25:15.000Z","updated":"2018-05-06T09:32:39.000Z","comments":true,"path":"2018/05/06/MD/论文/ＥＳ６/","link":"","permalink":"http://io.stelawliet.top/2018/05/06/MD/论文/ＥＳ６/","excerpt":"","text":"ECMAScript 的历史ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。 2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。 为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。 2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。 2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。 2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。 2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。 2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。 2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 异步所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 （1）内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1var result = asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。 （2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 （3）更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 （4）返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。 Promise 在 JavaScript 上发布之初就在互联网上流行了起来 — 它们帮开发人员摆脱了回调地狱，解决了在很多地方困扰 JavaScript 开发者的异步问题。但 Promises 也远非完美。它们一直请求回调，在一些复杂的问题上仍会有些杂乱和一些难以置信的冗余。 随着 ES6 的到来（现在被称作 ES2015），除了引入 Promise 的规范，不需要请求那些数不尽的库之外，我们还有了生成器。生成器可在函数内部停止执行，这意味着可把它们封装在一个多用途的函数中，我们可在代码移动到下一行之前等待异步操作完成。突然你的异步代码可能就开始看起来同步了。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/mybatis","date":"2018-05-05T15:03:27.000Z","updated":"2018-05-05T15:06:54.000Z","comments":true,"path":"2018/05/05/MD/论文/mybatis/","link":"","permalink":"http://io.stelawliet.top/2018/05/05/MD/论文/mybatis/","excerpt":"","text":"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。 与其他的对象关系映射框架不同，MyBatis并没有将Java对象)与数据库表关联起来，而是将Java方法与SQL语句关联。MyBatis允许用户充分利用数据库的各种功能，例如存储过程、视图、各种复杂的查询以及某数据库的专有特性。如果要对遗留数据库、不规范的数据库进行操作，或者要完全控制SQL的执行，MyBatis是一个不错的选择。 与JDBC相比，MyBatis简化了相关代码：SQL语句在一行代码中就能执行。MyBatis提供了一个映射引擎，声明式的把SQL语句执行结果与对象树映射起来。通过使用一种内建的类XML表达式语言，或者使用Apache Velocity集成的插件，SQL语句可以被动态的生成。 MyBatis与Spring Framework和Google Guice集成，这使开发者免于依赖性问题。 MyBatis支持声明式数据缓存（declarative data caching）。当一条SQL语句被标记为“可缓存”后，首次执行它时从数据库获取的所有数据会被存储在一段高速缓存中，今后执行这条语句时就会从高速缓存中读取结果，而不是再次命中数据库。MyBatis提供了基于 Java HashMap 的默认缓存实现，以及用于与OSCache、Ehcache、Hazelcast和Memcached连接的默认连接器。MyBatis还提供API供其他缓存实现使用。 https://zh.wikipedia.org/wiki/MyBatis MyBatis[编辑]维基百科，自由的百科全书 原理详解： ​ MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。 MyBatis的优缺点优点：1、简单易学 ​ mybatis本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 2、灵活 ​ mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。 3、解除sql与程序代码的耦合 ​ 通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 4、提供映射标签，支持对象与数据库的orm字段关系映射 5、提供对象关系映射标签，支持对象关系组建维护 6、提供xml标签，支持编写动态sql。 缺点：1、编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。 2、SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。 3、框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 4、二级缓存机制不佳","categories":[],"tags":[]},{"title":"","slug":"MD/论文/springmvc","date":"2018-05-05T15:02:31.000Z","updated":"2018-05-05T15:03:35.000Z","comments":true,"path":"2018/05/05/MD/论文/springmvc/","link":"","permalink":"http://io.stelawliet.top/2018/05/05/MD/论文/springmvc/","excerpt":"","text":"SpringMVC就是通过DispatcherServlet将一堆组件串联起来的Web框架。 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。 Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，可以选择是使用内置的 Spring Web 框架还是 Struts 这样的 Web 框架。通过策略接口，Spring 框架是高度可配置的，而且包含多种视图技术，例如 JavaServer Pages（JSP）技术、Velocity、Tiles、iText 和 POI。Spring MVC 框架并不知道使用的视图，所以不会强迫您只使用 JSP 技术。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制 Spring的MVC框架主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。 SpringMVC原理图[ img](http://7xqch5.com1.z0.glb.clouddn.com/springmvc2_1.jpg) SpringMVC接口解释DispatcherServlet接口：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。 HandlerMapping接口：能够完成客户请求到Controller映射。 Controller接口：需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 ViewResolver接口：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。 SpringMVC运行原理 客户端请求提交到DispatcherServlet 由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller DispatcherServlet将请求提交到Controller Controller调用业务逻辑处理后，返回ModelAndView DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 视图负责将结果显示到客户端 DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： 截获符合特定格式的URL请求。 初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。","categories":[],"tags":[]},{"title":"","slug":"Linux/ssh/mosh","date":"2018-05-05T13:29:40.000Z","updated":"2018-05-05T13:29:40.000Z","comments":true,"path":"2018/05/05/Linux/ssh/mosh/","link":"","permalink":"http://io.stelawliet.top/2018/05/05/Linux/ssh/mosh/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"MD/论文/前后分离","date":"2018-05-04T15:50:08.000Z","updated":"2018-05-04T15:52:19.000Z","comments":true,"path":"2018/05/04/MD/论文/前后分离/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/前后分离/","excerpt":"","text":"实现前后端分离的心得对目前的web来说，前后端分离已经变得越来越流行了，越来越多的企业/网站都开始往这个方向靠拢。那么，为什么要选择前后端分离呢？前后端分离对实际开发有什么好处呢? 为什么选择前后端分离 在以前传统的网站开发中，前端一般扮演的只是切图的工作，只是简单地将UI设计师提供的原型图实现成静态的HTML页面，而具体的页面交互逻辑，比如与后台的数据交互工作等，可能都是由后台的开发人员来实现的，或者是前端是紧紧的耦合后台。比如，以前淘宝的Web基本上都是基于MVC框架webx，架构决定了前端只能依赖后端。所以他们的开发模式依然是，前端写好静态demo，后端翻译成VM模版，这种模式的问题就不说了，被吐槽了很久。 而且更有可能后台人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。前后端工作分配不均。不仅仅开发效率慢，而且代码难以维护。而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。 如何做到前后端分离(以下的内容都是基于我们的电影购票网站来讨论的)前端的技术框架是: vue全家桶+nodejs+express(实现的是单页面(SPA)应用)首先，先分清楚前后端的工作 前端的工作：实现整一个前端页面以及交互逻辑，以及利用ajax与nodejs服务器（中间层)交互 后端的工作：提供API接口，利用redis来管理session,与数据库交互 SPA是什么？ 全称是单页面应用。 一个SPA就是一个WEB应用，它所需的资源(HTML CSS JS等)，在一次请求中就加载完成，也就是不需刷新地动态加载。 用术语“单页”就是因为页面在初始化加载后就永远不会重新加载刷新。 优点 减轻服务器端的压力。 因为服务器先将一份包含了静态资源、JavsScript和模板的静荷数据(payload)发送到了客户端，之后客户端只需要获取渲染页面或视图所需要的数据即可。payload就是起关键作用的资源 提高了页面的渲染效果。 由于移动设备的流行，可以开发提供JSON格式数据的网络服务，然后可以提供不同的客户端使用。 SPA的使用，我们可以使用一个HTTP API，一个HTTP API相比在服务端渲染一个HTML页面有诸多好处，这样就可以很方便的进行单元测试等操作，还可以被其他很多客户端程序所用。 SPA最大的好处就是大量的工作都在浏览器中完成，服务端承担更少的工作，这样就可以处理更多的请求。同时SPA需要额外的请求模版开销，我们可以通过预编译模版、缓存机制和将多个模板拼接成一个大的模板来减少请求数量。 缺点 首屏加载时间会很长。 SEO不友好。 主要是因为SPA利用了hash片段实现路由，而利用hash片段不会作为HTTP请求中的一部分发送给服务器。 而SPA使用hash片段的目的是：当片段的内容发送变化时，浏览器不会像URI发送变化时那样发起新的网络请求。这样就可以只请求页面或视图渲染所需要的数据，而不是为每一个页面获取并解析整份文档。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/vue1","date":"2018-05-04T15:44:12.000Z","updated":"2018-05-04T15:44:56.000Z","comments":true,"path":"2018/05/04/MD/论文/vue1/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/vue1/","excerpt":"","text":"从javascript发展说到vue 收藏;) goodman_fz 发表于 10个月前 阅读 812 收藏 41 点赞 4 评论 3 Vue是基于javascript的一套MVVC前端框架，在介绍vue之前有必要先大体介绍下javascript产生背景及发展的历史痕迹、前端MVVC模式等，以便于大家更好的理解为什么会有vue/react等框架的出现。 1.1 javascript发展概要及MVVC模式 【Web刚起步阶段】 那会，只有可怜的HTML（超文本标记语言（HyerText Markup Language）），浏览器请求某个URL时，web服务器就把对应的html文件返回给浏览器，浏览器做解析后展示给用户。随着时间推移，为了给能不同用户展示不同的页面信息，就慢慢发展出来基于服务器的可动态生成html的语言，比如asp、php、jsp等。 但是，当浏览器接收到一个html后，如果要更新页面的内容，就只能重新向服务器请求获取一份新的html文件，即刷新页面。在那古老的2G的流量珍贵的年代，这种体验是很容易让人奔溃的，而且还浪费流量。 【进入javascript阶段】 还好，聪明的前辈们在1995年底，在浏览器中引入了javascript。Javascript是一种脚本语言，浏览器中带有javascript引擎，用于解析并执行javascript代码，然后就可以在客户端操作到html页面中的DOM，这样就解决了不刷新页面情况，动态的改变用户html页面的内容。再后来，大家发现编写原生的javascript代码太繁琐了，还需要记住各种晦涩难懂的API，最重要还需要考虑各种浏览器的兼容性，其实是因为“懒”，就出现了一个救世主jQuery，并很快的占领了javascript世界，几乎成为前端开发标配。 例如 获取某个元素节点内容 原生写法：document.getElementById(‘name’).innerHTML(); jQuery写法：$(‘name’).html(); 【学习后端MVC模式】 事间万物往往都很难抵抗时间的洗礼，javascript也不例外，她也渐渐显现出各种不和谐：组织代码混乱、业务与操作DOM杂合，所以为她引入并改造了后端的MVC模式。 javascript前端MVC模式，需要服务器端配合，JavaScript可以在前端修改服务器渲染后的数据，简单来说即提交一次反馈一次。 例如：提交表单 填写内容 → 点击提交 →业务逻辑处理 →存入数据库 → 刷新页面→服务器取数据库数据→渲染到客户端页面→ 展示上一次你提交的内容。 MVC概念释疑： 视图（View）：用户界面。控制器（Controller）：业务逻辑模型（Model）：数据保存 View 传送指令到 Controller；Controller 完成业务逻辑后，要求 Model 改变状态；Model 将新的数据发送到 View，用户得到反馈。数据流，如图： img 但可惜，他并不没想象那么美，那么这种模式有哪些缺点？（注：以下缺点网上总结的，说的挺对，引用） 缺点一： ​ 它必须等待服务器端的指示，而且如果是异步模式的话，所有html节点、数据、页面结构都是后端请求过来。 浏览器只作为一个解析显示容器，Model 作用几乎是废x，Model 层面做的很少几乎前端无法控制，你前端几乎是切图仔和做轮播图的工作 缺点二： ​ 因为你前端渲染的页面结构，几乎是后端服务器包扎一堆数据一起发送过来，前端的你只需要用拼接字符串 或者字符串拼接引擎 比如Mustache、Jade、artTemplate、tmpl、kissyTemplate、ejs等来做事，说白了纯苦力和重复工作居多，这也导致了，如果很多人认为前端并不重要，只负责美工 和 动作体验就好了。 缺点三： ​ 一发而动全身。数据、显示不分离！为什么这么说，因为如果业务逻辑要变，比如很简单的需求，你用jsp或者php 拼接出来的ajax数据页面，年龄这个字段我不需要了，把性别字段 区分开，男的单独显示，女的单独显示，以前是一起显示到一个表的 【MVVC阶段】 没错，说那么多缺点，就为了最后的MVVC模式，为何MVVC模式？ MVVC模式是基于数据驱动，她把Model用纯javascript对象来表示，View负责显示，达到两者分离： 1、它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然,model数据的变动，也自动展示给页面显示2、把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。 数据流向变为，如图： img 与之前MVC的主要差别点在于，MVC你需要操作DOM及javascript对象来改变前端数据，MVVC你只需操作javascript对象即可改变前端数据。这也是MVVM的核心思想：关注Model的变化，让MVVM框架利用自己的机制去自动更新DOM，从而把开发者从操作DOM的繁琐中解脱出来！也就是数据-视图分离，数据驱动视图，视图不影响数据。 当今世上常见的MVVC框架有：vuejs、Angularjs、reactjs等等（想了解更多，见教程后面的对比分析） 【那么vue来了】 好了，大家应该对javascript发展及MVVM模式有一个大体的了解，现在转到vue，说下vue是一个什么东西？ ​ 官方文档介绍：是一套构建用户界面的渐进式框架**，**Vue 采用自底向上增量开发的设计，Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 ​ 个人实践后对vue的理解：vue是一套构建前端的MVVM框架，它集合了众多优秀主流框架设计及思想，轻量、数据驱动（默认单向数据绑定，但也提供支持双向数据绑定）、学习成本低，且可与webpack/gulp构建工具结合实现web组件化开发、构建部署等；很庆幸，我们生在开源遍地的时代，vue本身就拥有一套较为成熟的生态系统：vue+vue-router+vuex+webpack+sass/less，不仅满足小的前端项目开发，也完全胜任开发大型的前端应用，包括单页面应用和多页面应用等，它可实现前端页面前后端业务分离、快速开发（因为很多组件供调用）、单元测试、构建优化（结合webpack自动打包构建、优化）、部署等。瞬间提升前端开发人员的逼格，当后端开发再鄙视前端简单时，你就可以让他来试试了。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/json","date":"2018-05-04T15:38:09.000Z","updated":"2018-05-05T15:02:36.000Z","comments":true,"path":"2018/05/04/MD/论文/json/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/json/","excerpt":"","text":"JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 JSON建构于两种结构： “名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。 这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。 JSON具有以下这些形式： 对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。 Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache License 2.0开源许可协议的形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 Spring中包含的关键特性 强大的基于JavaBeans的采用控制反转（Inversion of Control，IoC）原则的配置管理，使得应用程序的组建更加快捷简易。一个可用于Java EE等运行环境的核心Bean工厂。数据库事务的一般化抽象层，允许声明式（Declarative）事务管理器，简化事务的划分使之与底层无关。内建的针对JTA和单个JDBC数据源的一般化策略，使Spring的事务支持不要求Java EE环境，这与一般的JTA或者EJB CMT相反。JDBC 抽象层提供了有针对性的异常等级（不再从SQL异常中提取原始代码），简化了错误处理，大大减少了程序员的编码量。再次利用JDBC时，你无需再写出另一个’终止’（finally）模块。并且面向JDBC的异常与Spring通用数据访问对象（Data Access Object）异常等级相一致。以资源容器，DAO实现和事务策略等形式与Hibernate，JDO和MyBatis、SQL Maps集成。利用众多的翻转控制方便特性来全面支持，解决了许多典型的Hibernate集成问题。所有这些全部遵从 Spring 通用事务处理和通用数据访问对象异常等级规范。灵活的基于核心 Spring 功能的MVC网页应用程序框架。开发者通过策略接口将拥有对该框架的高度控制，因而该框架将适应于多种呈现（View）技术，例如JSP、FreeMarker、Velocity、Thymeleaf 等。值得注意的是，Spring 中间层可以轻易地结合于任何基于MVC框架的网页层，例如Struts、WebWork或Tapestry。提供诸如事务管理等服务的AOP框架。在设计应用程序 Model 时，MVC模式（例如Struts）通常难于给出一个简洁明了的框架结构。Spring 却具有能够让这部分工作变得简单的能力。程序开发员们可以使用Spring的JDBC抽象层重新设计那些复杂的框架结构。 boot 没有比较就没有伤害，让我们先看看传统Spring MVC开发一个简单的Hello World Web应用程序，你应该做什么，我能想到一些基本的需求。 一个项目结构，其中有一个包含必要依赖的Maven或者Gradle构建文件，最起码要有Spring MVC和Servlet API这些依赖。 一个web.xml文件（或者一个WebApplicationInitializer实现），其中声明了Spring的DispatcherServlet。 一个启动了Spring MVC的Spring配置 一控制器类，以“hello World”相应HTTP请求。 一个用于部署应用程序的Web应用服务器，比如Tomcat。 Spring一直是很火的一个开源框架，在过去的一段时间里，Spring Boot在社区中热度一直很高，所以决定花时间来了解和学习，为自己做技术储备。 正文首先声明，Spring Boot不是一门新技术，所以不用紧张。从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar,内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。 Spring Boot精要Spring将很多魔法带入了Spring应用程序的开发之中，其中最重要的是以下四个核心。 自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置 起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。 命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。 Actuator：让你能够深入运行中的Spring Boot应用程序，一探究竟。 详细的我们就不展开，等你爱上后自然会去深入的了解，后续章节我们会一一展开介绍。接下来让我们开搞吧。我已经迫不及待的要尝尝Spring Boot的味道了。 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 IoC和DIDI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/mysql","date":"2018-05-04T15:36:28.000Z","updated":"2018-05-04T18:46:59.000Z","comments":true,"path":"2018/05/04/MD/论文/mysql/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/mysql/","excerpt":"","text":"[ MySQL.svg](https://upload.wikimedia.org/wikipedia/zh/thumb/6/62/MySQL.svg/180px-MySQL.svg.png) 开发者 甲骨文公司 稳定版本 8.0.11 （2018年4月19日，13天前 ） 预览版本 8.0.4 （2018年1月23日，3个月前 ） 操作系统 跨平台 类型 关系数据库 许可协议 GPL或Commercial License 网站 www.mysql.com 源代码库) https://github.com/mysql/mysql-server、git://anongit.gentoo.org/proj/mysql-extras.git img LAMP Squid MySQL（官方发音为/maɪ ˌɛskjuːˈɛl/“My S-Q-L”[1]，但也经常读作/maɪ ˈsiːkwəl/“My Sequel”）原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。 MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用在Internet上的中小型网站中。随着MySQL的不断成熟，它也逐渐用于更多大规模网站和应用，比如维基百科、Google和Facebook等网站。 与其他的大型数据库例如Oracle、IBM DB2、MS SQL等相比，MySQL自有它的不足之处，如规模小、功能有限等，但是这丝毫也没有减少它受欢迎的程度。对于一般的个人用户和中小型企业来说，MySQL提供的功能已经绰绰有余，而且由于MySQL是开放源代码软件，因此可以大大降低总体拥有成本。 2010年以前Internet上流行的网站构架方式是LAMP（Linux Apache MySQL PHP），即是用Linux作为操作系统，Apache作为Web服务器，MySQL作为数据库，PHP（部分网站也使用Perl或Python）作为服务器端脚本解释器。由于这四个软件都是开放源代码软件，因此使用这种方式可以以较低的成本创建起一个稳定、免费的网站系统。MySQL加PHP的配对在互联网上的应用相比LAMP来说更为常见，并获得了“动态配对”（Dynamic Duo）的雅号，大部分Blog网站基于的WordPress系统主要运用MySQL加PHP的配对。除了LAMP之外，用于Solaris、Windows和Mac上的网站构架也分别被称为SAMP、WAMP和MAMP。 维基百科所使用的Mediawiki维基引擎采用PHP语言写成，并以MySQL作为其支持的其中一种数据库管理系统。 MySQL（官方发音为/maɪ ˌɛskjuːˈɛl/“My S-Q-L”[1]，但也经常读作/maɪ ˈsiːkwəl/“My Sequel”）原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。 MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用在Internet上的中小型网站中。随着MySQL的不断成熟，它也逐渐用于更多大规模网站和应用，比如维基百科、Google和Facebook等网站。 与其他的大型数据库例如Oracle、IBM DB2、MS SQL等相比，MySQL自有它的不足之处，如规模小、功能有限等，但是这丝毫也没有减少它受欢迎的程度。对于一般的个人用户和中小型企业来说，MySQL提供的功能已经绰绰有余，而且由于MySQL是开放源代码软件，因此可以大大降低总体拥有成本。 2010年以前Internet上流行的网站构架方式是LAMP（Linux Apache MySQL PHP），即是用Linux作为操作系统，Apache作为Web服务器，MySQL作为数据库，PHP（部分网站也使用Perl或Python）作为服务器端脚本解释器。由于这四个软件都是开放源代码软件，因此使用这种方式可以以较低的成本创建起一个稳定、免费的网站系统。MySQL加PHP的配对在互联网上的应用相比LAMP来说更为常见，并获得了“动态配对”（Dynamic Duo）的雅号，大部分Blog网站基于的WordPress系统主要运用MySQL加PHP的配对。除了LAMP之外，用于Solaris、Windows和Mac上的网站构架也分别被称为SAMP、WAMP和MAMP。 维基百科所使用的Mediawiki维基引擎采用PHP语言写成，并以MySQL作为其支持的其中一种数据库管理系统。 https://zh.wikipedia.org/wiki/MySQL 维基百科，自由的百科全书","categories":[],"tags":[]},{"title":"","slug":"MD/论文/tomcat","date":"2018-05-04T15:32:18.000Z","updated":"2018-05-04T15:35:00.000Z","comments":true,"path":"2018/05/04/MD/论文/tomcat/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/tomcat/","excerpt":"","text":"1234567Tomcat是一个免费的开源的Selvet容器，它是Apache基金会的Jakata项目中的一个核心项目，由Apache，Sun和其它一些公司及个人共同开发而成。由于有了Sun的参与和支持，最新的Sevlet和Jsp规范总能在Tomcat中得到体现。在Tomcat服务器运行的过程中，它占用的系统资源小，并且扩展性能好。与此同时，Tomcat服务器还支持负载平衡与邮件服务等开发应用系统常用的功能。Tomcat服务器使用Tomcat系统，所具有的优点也很鲜明，首先它具有免费的开源代码，其次是Tomcat系统技术先进并且性能也是相当的稳定，最后Tomcat服务器具有良好的扩展性和安全性，很适合一些中小企业使用。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/nginx","date":"2018-05-04T15:30:27.000Z","updated":"2018-05-06T17:38:08.000Z","comments":true,"path":"2018/05/04/MD/论文/nginx/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/nginx/","excerpt":"","text":"Nginx是一个高性能的HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP代理服务器。Nginx的影响力可以同Apache匹敌是有它的实力的：超强的稳定性、丰富的功能集、示例配置文件和低系统资源消耗是让它远近闻名的最大特点。因为它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。选择Nginx做静态资源服务器的几点原因： 1) 更快，请求会得到更快的响应，并发数以万计的请求，Nginx也可以比其他服务器更快地作出响应。2) 高延展性，Nginx的设计极具扩展性，它的设计是由多个不同功能、不同层次、不同类型且耦合度极低的模块组成。这种低耦合度的优秀设计，造就了Nginx庞大的第三方模块，当然，公开的第三方模块也如官方发布的模块一样容易使用。3) 高可靠性：用于反向代理，宕机的概率微乎其微，高可靠性是我们选择Nginx的最基本条件。4) 低内存消耗一般情况下，10 000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存，这是Nginx支持高并发连接的基础。5) 单机支持10万以上的并发连接这是一个非常重要的性能指标。6) 最自由的BSD许可协议，这是Nginx可以快速发展的强大动力。BSD许可协议下用户不仅可以免费的使用Nginx，用户还可以在自己的项目中根据自己的需求来修改Nginx源码，达到不同场景的需求，这许可协议使许多开发者协同开发为Nginx开源项目贡献自己的代码，不断完善Nginx。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/webpack","date":"2018-05-04T15:28:17.000Z","updated":"2018-05-04T15:30:36.000Z","comments":true,"path":"2018/05/04/MD/论文/webpack/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/webpack/","excerpt":"","text":"webpack已经是大部分前端项目打包工具的首选，grunt、glup、browserify等逐渐沦为辅助甚至完全被替代。在grunt、glup、browserify等已经相当火了之后，webpack长江后浪推前浪，把前辈们拍死在沙滩上，实力惊人。 根据GitHub上的迭代发展看来，通过Issues、Release、Commit等看，webpack发展相当不错，已经有2.0的beta版本，最大的更新应该是支持ES6 Modules，根据ES6的特性来做一些Code Splitting等。 wait… 有同学说还有rollup，鉴于他还是小弟，可能还有大部分人都没听说过，官方介绍：A next-generation ES6 module bundler，也是看好他的。 还有brunch，Broccoli等，这里就不列举所有了。 Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。例如，在开发 Web 页面过程中，当你点击按钮，出现一个弹窗的时候，发现弹窗标题没有对齐，这时候你修改 CSS 样式，然后保存，在浏览器没有刷新的前提下，标题样式发生了改变。感觉就像在 Chrome 的开发者工具中直接修改元素样式一样。 近年来，前端技术蓬勃发展，我们想在js更方便的实现html , 社区就出现了jsx,我们觉得原生的css不够好用，社区就提出了scss,less，针对前端项目越来越强的模块化开发需求，社区出现了AMD,CommonJS,ES2015 import等等方案。遗憾的是，这些方案大多并不直接被浏览器支持，往往伴随这些方案而生的还有另外一些，让这些新技术应用于浏览器的方案，我们用babel来转换下一代的js，转换jsx;我们用各种工具转换scss,less为css；我们发现项目越来越复杂，代码体积越来越大，又要开始寻找各种优化，压缩，分割方案。前端工程化这个过程，真是让我们大费精力。我们也大多是在寻找前端模块化解决方案的过程中知晓了webpack。 的确，webpack的流行得益于野性生长的前端，其本质是一种前端模块化打包解决方案，但是更重要的是它又是一个可以融合运用各种前端新技术的平台，明白webpack的使用哲学后，只需要简单的配置,我们就可以随心所欲的在webpack项目中使用jsx/ts,使用babel/postcss等平台提供的众多其它功能，只需通过一条命令由源码构建最终可用文件。可以不夸张的说webpack为前端的工程化开发提供了一套相对容易和完整的解决方案。一些知名的脚手架工具，也大多基于webpack(比如create-react-app)。","categories":[],"tags":[]},{"title":"","slug":"Linux/ssh/ssh scp","date":"2018-05-04T13:17:39.000Z","updated":"2018-05-04T13:18:13.000Z","comments":true,"path":"2018/05/04/Linux/ssh/ssh scp/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/Linux/ssh/ssh scp/","excerpt":"","text":"在linux下一般用scp这个命令来通过ssh传输文件。 从服务器上下载文件 12# 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录）scp root@192.168.0.101:/var/www/test.txt /var/www/local_dir 上传本地文件到服务器 12# 把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/wwwscp /var/www/test.php root@192.168.0.101:/var/www/ 从服务器下载整个目录 1scp -r root@192.168.0.101:/var/www/test /var/www/ 上传目录到服务器 1scp -r local_dir username@servername:remote_dir 注： 目标服务器要开启写入权限。","categories":[],"tags":[]},{"title":"","slug":"MD/论文/Untitled","date":"2018-05-04T13:17:23.000Z","updated":"2018-05-04T13:17:23.000Z","comments":true,"path":"2018/05/04/MD/论文/Untitled/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"MD/论文/tables","date":"2018-05-04T08:36:23.000Z","updated":"2018-05-05T18:40:29.000Z","comments":true,"path":"2018/05/04/MD/论文/tables/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/tables/","excerpt":"","text":"society_activity 名称 a_no int(15) a_society_id int(15) a_name varchar(20) a_address varchar(30) a_status int(10) a_details text a_grade varchar(20) society_category P 名称 category_id int(5) category_name char(20) category_des varchar(20) society_comment P 名称 c_no int(20) c_activity_id int(15) c_user_id int(20) c_date varchar(20) c_desc text c_status int(1) c_uname char(20) society_info 名称 s_id int(15) s_name char(15) s_chairman int(10) s_grade varchar(20) s_desc text s_pic text s_status int(1) society_member 名称 m_no int(20) m_society_id int(15) m_user_id int(20) m_date date m_grade char(2) m_position varchar(20) m_desc text m_status int(1) society_user P u_id int(20) u_name varchar(20) u_password varchar(20) u_role int(1) u_gender char(10) u_academy varchar(20) u_class varchar(10) u_desc text u_email varchar(20) u_birthday date u_phone int(15) 说明部分用户编号，用户名，密码，角色权限值，性别，专业，班级，描述，邮箱，生日，电话号 社团编号，主键ID，社团名，会长编号，分类，描述介绍，社团头像，审核状态 成员编号，社团编号，用户编号，加入日期，分类，职位，加入验证 活动编号，社团编号，活动名，活动地址，审核状态，活动详细，活动分类","categories":[],"tags":[]},{"title":"","slug":"MD/论文/table","date":"2018-05-04T08:35:28.000Z","updated":"2018-05-04T08:36:12.000Z","comments":true,"path":"2018/05/04/MD/论文/table/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/论文/table/","excerpt":"","text":"u_id int(20) u_name varchar(20) u_password varchar(20) u_role int(1) u_gender char(10) u_academy varchar(20) u_class varchar(10) u_desc textu_email varchar(20) u_birthday dateu_phone int(15)","categories":[],"tags":[]},{"title":"mac path backup","slug":"MD/mac path","date":"2018-05-04T08:35:21.000Z","updated":"2018-07-04T11:59:05.000Z","comments":true,"path":"2018/05/04/MD/mac path/","link":"","permalink":"http://io.stelawliet.top/2018/05/04/MD/mac path/","excerpt":"","text":"mac path backup 12345678910111213141516171819PATH=$PATH:/usr/local/mysql/binJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:CLASSPATH=$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATHexport PATH=$PATH:/Users/zhaoziqi/Library/tomcat8/binexport CATALINA_HOME=/Users/zhaoziqi/Library/tomcat8export MAVEN_HOME=/Users/zhaoziqi/Library/apache-maven-3.5.2export PATH=$PATH:$MAVEN_HOME/binexport JETTY_HOME=/Users/zhaoziqi/Library/jetty-9.4.7alias ll='ls -alF'alias la='ls -A'alias l='ls -CF'export PATH=\"$HOME/.cargo/bin:$PATH\" source ~/.bash_profile","categories":[{"name":"note","slug":"note","permalink":"http://io.stelawliet.top/categories/note/"},{"name":"mac config","slug":"note/mac-config","permalink":"http://io.stelawliet.top/categories/note/mac-config/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://io.stelawliet.top/tags/mac/"},{"name":"bash_profile","slug":"bash-profile","permalink":"http://io.stelawliet.top/tags/bash-profile/"},{"name":"path","slug":"path","permalink":"http://io.stelawliet.top/tags/path/"}]},{"title":"","slug":"MD/论文/素格式","date":"2018-05-02T06:14:35.000Z","updated":"2018-05-02T06:15:37.000Z","comments":true,"path":"2018/05/02/MD/论文/素格式/","link":"","permalink":"http://io.stelawliet.top/2018/05/02/MD/论文/素格式/","excerpt":"","text":"国务院.国务院关于基础教育改革与发展的决定[Z]. 2001-05-29. 首先这个属于其他里面，用Z，其次格式】[序号]颁布单位.条例名称.发布日期 【举例】[15]中华人民共和国科学技术委员会.科学技术期刊管理办法[Z].1991—06—05","categories":[],"tags":[]},{"title":"","slug":"Vue/表格Excel","date":"2018-05-02T04:59:20.000Z","updated":"2018-05-02T05:08:50.000Z","comments":true,"path":"2018/05/02/Vue/表格Excel/","link":"","permalink":"http://io.stelawliet.top/2018/05/02/Vue/表格Excel/","excerpt":"","text":"vue2.0 + element UI 中 el-table 数据导出Excel阅读 424 收藏 81 2018-04-28 原文链接：blog.csdn.net 腾讯课堂前端工程师 NEXT 学位限定席位报名中！立即报名！ke.qq.com vue2.0 + element UI 中 el-table 数据导出Excel1、 安装相关依赖 主要是两个依赖 1npm install --save xlsx file-saver 如果想详细看着两个插件使用，请移步github。 github.com/SheetJS/js-…github.com/eligrey/Fil… 2、组件里头引入 12import FileSaver from &apos;file-saver&apos;import XLSX from &apos;xlsx&apos; 3、组件methods里写一个方法 12345678910exportExcel () &#123; /* generate workbook object from table */ var wb = XLSX.utils.table_to_book(document.querySelector(&apos;#out-table&apos;)) /* get binary string as output */ var wbout = XLSX.write(wb, &#123; bookType: &apos;xlsx&apos;, bookSST: true, type: &apos;array&apos; &#125;) try &#123; FileSaver.saveAs(new Blob([wbout], &#123; type: &apos;application/octet-stream&apos; &#125;), &apos;sheetjs.xlsx&apos;) &#125; catch (e) &#123; if (typeof console !== &apos;undefined&apos;) console.log(e, wbout) &#125; return wbout&#125;, 注意：XLSX.uitls.table_to_book( 放入的是table 的DOM 节点 ) ，sheetjs.xlsx 即为导出表格的名字，可修改！ 4、点击导出按钮执行 exportExcel 的方法即可 。 组件里头代码截图： img 实现效果图如下：导出如下表格的数据到excel。 img 导出到excel 表格，结果如下： img 相关链接：该工具的其他使用场景( 如react 、jQ、angular ) sheetjs.com/","categories":[],"tags":[]},{"title":"","slug":"MD/论文/论文","date":"2018-05-02T04:58:26.000Z","updated":"2018-05-03T14:41:58.000Z","comments":true,"path":"2018/05/02/MD/论文/论文/","link":"","permalink":"http://io.stelawliet.top/2018/05/02/MD/论文/论文/","excerpt":"","text":"高校学生社团作为文化生活的重要载体，是大学教育不可缺少的重要组成部分。，学生社团的发展目前存在人员管理困难、社团财务不清、社团活动难以开展等问题。 中共中央，国务院在《关于进一步加强和改进大学生思想政治教育的意见》说到，“加强对大学生社团的领导和管理，帮助大学生社团选聘指导老师，支持和引导大学生社团自主开展活动” 要加强对大学生社团的领导和管理，帮助大学生社团选聘指导教师，支持和引导大学生社团自主开展活动。 摘要近几年来，随着国家政府相关政策的推出，高等教育的逐渐普及高校的逐年扩招，给高校的教学管理、学生信息管理等方面都带来不少的挑战。本文主要介绍了高校学生社团管理系统的设计与实现方案，社团管理系统面对学校社团成员信息的特征以及管理中的需要而设计，达到有效地学生社团成员管理的数字化，网络化，减轻相关的社团管理人员的管理负担。 近几年来，国家政府相关政策的推出，随着高等教育的逐渐普及高校的逐年扩招，给高校的教学管理、学生信息管理等方面都带来不少的挑战。其包含的数据量大，涉及的人员面广，而且需要及时更新，故较为复杂，难以单纯地依赖人工管理，而且传统的人工管理方式既不易于规范化，管理效率也不高，目前我国各类高等院校中还有相当一部分学生档案管理还停留在纸介质的基础上，尤其是中、小学对学生档案的管理更是落后，这样的管理机制已经不能适应时代发展的要求，其管理方法将浪费许多人力和物力。随着科学技术的不断提高，计算机科学与技术日渐成熟，计算机应用的普及已进入人类社会生活的各个领域，并发挥着越来越重要的作用。这种传统的手工管理模式必然被以计算机为物质基础的信息管理方法所取代。 作为计算机应用的一部分，使用计算机对学生档案进行管理，有着手工管理所无法比拟的优点，如：检索迅速、查找方便、可靠性高、存储量大、保密性好、寿命长、成本低等。这些优点能够极大地提高学生档案管理的效率，也是学校向科学化、正规化管理发展的必要条件，更是各个高等院校与世界接轨的重要条件。 社团管理系统面对学校社团成员信息的特征以及管理中的需要而设计，达到有效地学生社团成员管理的信息化，数字化，网络化，减轻相关的社团管理人员的管理负担，高效率、数字化地管理学生社团成员信息，并一定程度上避免人为操作的错误或者不规范行为。 Vue 数据驱动视图 总结一下吧(以下依赖收集器实为Dep)： vue将data初始化为一个Observer并对对象中的每个值，重写了其中的get、set，data中的每个key，都有一个独立的依赖收集器。 在get中，向依赖收集器添加了监听 在mount时，实例了一个Watcher，将收集器的目标指向了当前Watcher 在data值发生变更时，触发set，触发了依赖收集器中的所有监听的更新，来触发Watcher.update","categories":[],"tags":[]},{"title":"","slug":"Linux/TCP连接断开详细","date":"2018-04-24T14:02:54.000Z","updated":"2018-04-24T14:02:56.000Z","comments":true,"path":"2018/04/24/Linux/TCP连接断开详细/","link":"","permalink":"http://io.stelawliet.top/2018/04/24/Linux/TCP连接断开详细/","excerpt":"","text":"TCP的三次握手和四次挥手一，TCP建立连接(Connection Establishment)由以下三个过程： 1）Client给Server发送发送TCP segment：SYN=1，ACK=0，SEQ=x。（这些字段的作用是这样的：通过SYN=1，ACK=0告诉server这是连接请求Connection Requet。SEQ=x表明后面传送数据时的第一个数据字节的序号是x+1） 2）Server给Client发送的TCP segment：SYN=1，ACK=1, SEQ = y, ACK(ackonwlege number)=x+1.(server通过SYN=1，ACK=1告诉client，这是接受请求Connection Accepted。确认你是要从x+1传起了。server也通知client，我要传给你的是从y+1传起的哦！） 3) Client给Server发送发送TCP segment: ACK=1, SEQ=x+1, ACk(acknowledeg number)=y+1(client告诉server，OK，我是要建立连接，你可以建立了） 说明：1）为什么需要第三个步骤呢？Internet是不可靠的，有时候由于网络延迟，Client可能会“重传”第一个请求连接的报文。如果Server每次收到Connetion Request（也就是SYN=1，ACK=0）的报文就建立连接，那Server就亏大了（浪费资源）。所以需要Client再确认一下，免得 Server吃亏。 ​ 2) 在第一个步骤，如果Server拒绝连接，就可以设置RST=1，并回复Client。 ​ 3）如果Client在第一个步骤发送的数据报的时候，源IP随便填写（这并不影响路由过程），这样，Server收到连接请求（SYN=1，ACK= 0），并不会马上为这个连接请求Client建立连接，而是为连接请求建立会话，并放到等待队列中，向源IP主机发送确认数据包，并等待回复。由于 Server收不到第三个步骤的回复确认（当然了，源IP是假的），会一直等待直到超时，当有大量这样的连接时，Server就无法接受新的连接请求了，这就是“DOS（denial of Service）攻击”的原理. 二，TCP连接断开 连接的双方分别为host A和host B. TCP连接是全双工的，当我们可以把它看成两个半双工的，可以分别关闭，过程如下： 1）A =&gt; B: FIN, SEQ=x 2) B =&gt; A: ACK, SEQ=y, ACK=x+1 3) B =&gt; A: FIN, ACK, SEQ = y, ACK = x+1 4) A =&gt; B: ACK, SEQ = x + 1, ACK = x + 1. 说明：2）3）步骤可以合为一个TCP segment。","categories":[],"tags":[]},{"title":"","slug":"MD/mem/just for fun","date":"2018-04-20T17:05:29.000Z","updated":"2018-05-22T16:16:43.000Z","comments":true,"path":"2018/04/21/MD/mem/just for fun/","link":"","permalink":"http://io.stelawliet.top/2018/04/21/MD/mem/just for fun/","excerpt":"","text":"学习Linux心得正如Linux创始人说的，创建Linux操作系统的原因JUST FOR FUN。 如果没有这种理念支撑，所处的环境将左右我们的选择。","categories":[],"tags":[]},{"title":"","slug":"JavaScript/bootstrap3/components","date":"2018-04-11T14:50:28.000Z","updated":"2018-04-11T14:51:32.000Z","comments":true,"path":"2018/04/11/JavaScript/bootstrap3/components/","link":"","permalink":"http://io.stelawliet.top/2018/04/11/JavaScript/bootstrap3/components/","excerpt":"","text":"组件无数可复用的组件，包括字体图标、下拉菜单、导航、警告框、弹出框等更多功能。 Glyphicons 字体图标所有可用的图标包括250多个来自 Glyphicon Halflings 的字体图标。Glyphicons Halflings 一般是收费的，但是他们的作者允许 Bootstrap 免费使用。为了表示感谢，希望你在使用时尽量为 Glyphicons 添加一个友情链接。 ​ 如何使用出于性能的考虑，所有图标都需要一个基类和对应每个图标的类。把下面的代码放在任何地方都可以正常使用。注意，为了设置正确的内补（padding），务必在图标和文本之间添加一个空格。 不要和其他组件混合使用图标类不能和其它组件直接联合使用。它们不能在同一个元素上与其他类共同存在。应该创建一个嵌套的 &lt;span&gt; 标签，并将图标类应用到这个 &lt;span&gt; 标签上。 只对内容为空的元素起作用图标类只能应用在不包含任何文本内容或子元素的元素上。 改变图标字体文件的位置Bootstrap 假定所有的图标字体文件全部位于 ../fonts/ 目录内，相对于预编译版 CSS 文件的目录。如果你修改了图标字体文件的位置，那么，你需要通过下面列出的任何一种方式来更新 CSS 文件： 在 Less 源码文件中修改 @icon-font-path 和/或 @icon-font-name 变量。 利用 Less 编译器提供的 相对 URL 地址选项。 修改预编译 CSS 文件中的 url() 地址。 根据你自身的情况选择一种方式即可。 图标的可访问性现代的辅助技术能够识别并朗读由 CSS 生成的内容和特定的 Unicode 字符。为了避免 屏幕识读设备抓取非故意的和可能产生混淆的输出内容（尤其是当图标纯粹作为装饰用途时），我们为这些图标设置了 aria-hidden=&quot;true&quot; 属性。 如果你使用图标是为了表达某些含义（不仅仅是为了装饰用），请确保你所要表达的意思能够通过被辅助设备识别，例如，包含额外的内容并通过 .sr-only 类让其在视觉上表现出隐藏的效果。 如果你所创建的组件不包含任何文本内容（例如， &lt;button&gt; 内只包含了一个图标），你应当提供其他的内容来表示这个控件的意图，这样就能让使用辅助设备的用户知道其作用了。这种情况下，你可以为控件添加 aria-label 属性。 1&lt;span class=&quot;glyphicon glyphicon-search&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 实例可以把它们应用到按钮、工具条中的按钮组、导航或输入框等地方。 Star Star Star Star 1234567&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; aria-label=&quot;Left Align&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-align-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Star&lt;/button&gt; alert 组件中所包含的图标是用来表示这是一条错误消息的，通过添加额外的 .sr-only 文本就可以让辅助设备知道这条提示所要表达的意思了。 Error:Enter a valid email address 12345&lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-exclamation-sign&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Error:&lt;/span&gt; Enter a valid email address&lt;/div&gt; 下拉菜单用于显示链接列表的可切换、有上下文的菜单。下拉菜单的 JavaScript 插件让它具有了交互性。 实例将下拉菜单触发器和下拉菜单都包裹在 .dropdown 里，或者另一个声明了 position: relative; 的元素。然后加入组成菜单的 HTML 代码。 Action Another action Something else here 12345678910111213&lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-default dropdown-toggle&quot; type=&quot;button&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;true&quot;&gt; Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 通过为下拉菜单的父元素设置 .dropup 类，可以让菜单向上弹出（默认是向下弹出的）。 Dropup 12345678910111213&lt;div class=&quot;dropup&quot;&gt; &lt;button class=&quot;btn btn-default dropdown-toggle&quot; type=&quot;button&quot; id=&quot;dropdownMenu2&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Dropup &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenu2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对齐B默认情况下，下拉菜单自动沿着父元素的上沿和左侧被定位为 100% 宽度。 为 .dropdown-menu 添加 .dropdown-menu-right 类可以让菜单右对齐。 可能需要额外的定位May require additional positioning在正常的文档流中，通过 CSS 为下拉菜单进行定位。这就意味着下拉菜单可能会由于设置了 overflow 属性的父元素而被部分遮挡或超出视口（viewport）的显示范围。如果出现这种问题，请自行解决。 不建议使用 .pull-right从 v3.1.0 版本开始，我们不再建议对下拉菜单使用 .pull-right 类。如需将菜单右对齐，请使用 .dropdown-menu-right类。导航条中如需添加右对齐的导航（nav）组件，请使用 .pull-right 的 mixin 版本，可以自动对齐菜单。如需左对齐，请使用 .dropdown-menu-left 类。 123&lt;ul class=&quot;dropdown-menu dropdown-menu-right&quot; aria-labelledby=&quot;dLabel&quot;&gt; ...&lt;/ul&gt; 标题在任何下拉菜单中均可通过添加标题来标明一组动作。 Dropdown header Action Another action Something else here Dropdown header Separated link 12345&lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenu3&quot;&gt; ... &lt;li class=&quot;dropdown-header&quot;&gt;Dropdown header&lt;/li&gt; ...&lt;/ul&gt; 分割线为下拉菜单添加一条分割线，用于将多个链接分组。 Action Another action Something else here ​ Separated link 12345&lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenuDivider&quot;&gt; ... &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; ...&lt;/ul&gt; 禁用的菜单项为下拉菜单中的 &lt;li&gt; 元素添加 .disabled 类，从而禁用相应的菜单项。 Regular link Disabled link Another link 12345&lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenu4&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Regular link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;Disabled link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another link&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 按钮组通过按钮组容器把一组按钮放在同一行里。通过与按钮插件联合使用，可以设置为单选框或多选框的样式和行为。 按钮组中的工具提示和弹出框需要特别的设置当为 .btn-group 中的元素应用工具提示或弹出框时，必须指定 container: &#39;body&#39; 选项，这样可以避免不必要的副作用（例如工具提示或弹出框触发时，会让页面元素变宽和/或失去圆角）。 确保设置正确的 role 属性并提供一个 label 标签为了向使用辅助技术 - 如屏幕阅读器 - 的用户正确传达一正确的按钮分组，需要提供一个合适的 role 属性。对于按钮组合，应该是 role=&quot;group&quot;，对于toolbar（工具栏）应该是 role=&quot;toolbar&quot;。 一个例外是按钮组合只包含一个单一的控制元素或一个下拉菜单（比如实际情况，&lt;button&gt; 元素组成的两端对齐排列的按钮组）或下拉菜单。 此外，按钮组和工具栏应给定一个明确的label标签，尽管设置了正确的 role 属性，但是大多数辅助技术将不会正确的识读他们。在这里提供的实例中，我们使用 aria-label，但是， aria-labelledby 也可以使用。 基本实例Wrap a series of buttons with .btn in .btn-group. LeftMiddleRight 12345&lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Left&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Middle&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Right&lt;/button&gt;&lt;/div&gt; 按钮工具栏把一组 &lt;div class=&quot;btn-group&quot;&gt; 组合进一个 &lt;div class=&quot;btn-toolbar&quot;&gt; 中就可以做成更复杂的组件。 1234 567 8 12345&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot; aria-label=&quot;...&quot;&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt;&lt;/div&gt; 尺寸只要给 .btn-group 加上 .btn-group-* 类，就省去为按钮组中的每个按钮都赋予尺寸类了，如果包含了多个按钮组时也适用。 LeftMiddleRight LeftMiddleRight LeftMiddleRight LeftMiddleRight 1234&lt;div class=&quot;btn-group btn-group-lg&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;btn-group btn-group-sm&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;btn-group btn-group-xs&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;...&lt;/div&gt; 嵌套想要把下拉菜单混合到一系列按钮中，只须把 .btn-group 放入另一个 .btn-group 中。 Dropdown 123456789101112131415&lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;1&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;2&lt;/button&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Dropdown link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Dropdown link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 垂直排列让一组按钮垂直堆叠排列显示而不是水平排列。分列式按钮下拉菜单不支持这种方式。 Dropdown Dropdown Dropdown Dropdown 123&lt;div class=&quot;btn-group-vertical&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; ...&lt;/div&gt; 两端对齐排列的按钮组让一组按钮拉长为相同的尺寸，填满父元素的宽度。对于按钮组中的按钮式下拉菜单也同样适用。 关于边框的处理由于对两端对齐的按钮组使用了特定的 HTML 和 CSS （即 display: table-cell），两个按钮之间的边框叠加在了一起。在普通的按钮组中，margin-left: -1px 用于将边框重叠，而没有删除任何一个按钮的边框。然而，margin 属性不支持 display: table-cell。因此，根据你对 Bootstrap 的定制，你可以删除或重新为按钮的边框设置颜色。 IE8 和边框Internet Explorer 8 不支持在两端对齐的按钮组中绘制边框，无论是 &lt;a&gt; 或 &lt;button&gt; 元素。为了照顾 IE8，把每个按钮放入另一个 .btn-group 中即可。 参见 #12476 获取详细信息。 关于 &lt;a&gt; 元素只须将一系列 .btn 元素包裹到 .btn-group.btn-group-justified 中即可。 LeftMiddleRight Left Middle Dropdown 123&lt;div class=&quot;btn-group btn-group-justified&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; ...&lt;/div&gt; Links acting as buttonsIf the &lt;a&gt; elements are used to act as buttons – triggering in-page functionality, rather than navigating to another document or section within the current page – they should also be given an appropriate role=&quot;button&quot;. 关于 &lt;button&gt; 元素为了将 &lt;button&gt; 元素用于两端对齐的按钮组中，必须将每个按钮包裹进一个按钮组中you must wrap each button in a button group。大部分的浏览器不能将我们的 CSS 应用到对齐的 &lt;button&gt; 元素上，但是，由于我们支持按钮式下拉菜单，我们可以解决这个问题。 Left Middle Right 1234567891011&lt;div class=&quot;btn-group btn-group-justified&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Left&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Middle&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Right&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 按钮式下拉菜单把任意一个按钮放入 .btn-group 中，然后加入适当的菜单标签，就可以让按钮作为菜单的触发器了。 插件依赖按钮式下拉菜单依赖下拉菜单插件 ，因此需要将此插件包含在你所使用的 Bootstrap 版本中。 单按钮下拉菜单只要改变一些基本的标记，就能把按钮变成下拉菜单的开关。 Default Primary Success Info Warning Danger 12345678910111213&lt;!-- Single button --&gt;&lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 分裂式按钮下拉菜单相似地，分裂式按钮下拉菜单也需要同样的改变一些标记，但只是多一个分开的按钮。 DefaultToggle Dropdown PrimaryToggle Dropdown SuccessToggle Dropdown InfoToggle Dropdown WarningToggle Dropdown DangerToggle Dropdown 123456789101112131415&lt;!-- Split button --&gt;&lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;Action&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle Dropdown&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 尺寸按钮式下拉菜单适用所有尺寸的按钮。 Large button Small button Extra small button 1234567891011121314151617181920212223242526272829&lt;!-- Large button group --&gt;&lt;div class=&quot;btn-group&quot;&gt; &lt;button class=&quot;btn btn-default btn-lg dropdown-toggle&quot; type=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Large button &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; ... &lt;/ul&gt;&lt;/div&gt;&lt;!-- Small button group --&gt;&lt;div class=&quot;btn-group&quot;&gt; &lt;button class=&quot;btn btn-default btn-sm dropdown-toggle&quot; type=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Small button &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; ... &lt;/ul&gt;&lt;/div&gt;&lt;!-- Extra small button group --&gt;&lt;div class=&quot;btn-group&quot;&gt; &lt;button class=&quot;btn btn-default btn-xs dropdown-toggle&quot; type=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Extra small button &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; ... &lt;/ul&gt;&lt;/div&gt; 向上弹出式菜单给父元素添加 .dropup 类就能使触发的下拉菜单朝上方打开。 DropupToggle Dropdown Right dropupToggle Dropdown 12345678910&lt;div class=&quot;btn-group dropup&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Dropup&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle Dropdown&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;!-- Dropdown menu links --&gt; &lt;/ul&gt;&lt;/div&gt; 输入框组通过在文本输入框 &lt;input&gt; 前面、后面或是两边加上文字或按钮，可以实现对表单控件的扩展。为 .input-group 赋予 .input-group-addon 或 .input-group-btn 类，可以给 .form-control 的前面或后面添加额外的元素。 只支持文本输入框 &lt;input&gt;这里请避免使用 &lt;select&gt; 元素，因为 WebKit 浏览器不能完全绘制它的样式。 避免使用 &lt;textarea&gt; 元素，由于它们的 rows 属性在某些情况下不被支持。 输入框组中的工具提示和弹出框需要特别的设置为 .input-group 中所包含的元素应用工具提示（tooltip）或popover（弹出框）时，必须设置 container: &#39;body&#39; 参数，为的是避免意外的副作用（例如，工具提示或弹出框被激活后，可能会让当前元素变得更宽或/和变得失去其圆角）。 不要和其他组件混用不要将表单组或栅格列（column）类直接和输入框组混合使用。而是将输入框组嵌套到表单组或栅格相关元素的内部。 Always add labelsScreen readers will have trouble with your forms if you don’t include a label for every input. For these input groups, ensure that any additional label or functionality is conveyed to assistive technologies. The exact technique to be used (visible &lt;label&gt; elements, &lt;label&gt; elements hidden using the .sr-only class, or use of the aria-label, aria-labelledby, aria-describedby, title or placeholder attribute) and what additional information will need to be conveyed will vary depending on the exact type of interface widget you’re implementing. The examples in this section provide a few suggested, case-specific approaches. 基本实例在输入框的任意一侧添加额外元素或按钮。你还可以在输入框的两侧同时添加额外元素。 我们不支持在输入框的单独一侧添加多个额外元素（.input-group-addon 或 .input-group-btn）。 我们不支持在单个输入框组中添加多个表单控件。 @@example.com$.00Your vanity URLhttps://example.com/users/ 123456789101112131415161718192021&lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot; id=&quot;basic-addon1&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; aria-describedby=&quot;basic-addon1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Recipient&apos;s username&quot; aria-describedby=&quot;basic-addon2&quot;&gt; &lt;span class=&quot;input-group-addon&quot; id=&quot;basic-addon2&quot;&gt;@example.com&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;$&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;Amount (to the nearest dollar)&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt;&lt;/div&gt;&lt;label for=&quot;basic-url&quot;&gt;Your vanity URL&lt;/label&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot; id=&quot;basic-addon3&quot;&gt;https://example.com/users/&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;basic-url&quot; aria-describedby=&quot;basic-addon3&quot;&gt;&lt;/div&gt; 尺寸为 .input-group 添加相应的尺寸类，其内部包含的元素将自动调整自身的尺寸。不需要为输入框组中的每个元素重复地添加控制尺寸的类。 @@@ 1234567891011121314&lt;div class=&quot;input-group input-group-lg&quot;&gt; &lt;span class=&quot;input-group-addon&quot; id=&quot;sizing-addon1&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; aria-describedby=&quot;sizing-addon1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot; id=&quot;sizing-addon2&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; aria-describedby=&quot;sizing-addon2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-group input-group-sm&quot;&gt; &lt;span class=&quot;input-group-addon&quot; id=&quot;sizing-addon3&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; aria-describedby=&quot;sizing-addon3&quot;&gt;&lt;/div&gt; 作为额外元素的多选框和单选框可以将多选框或单选框作为额外元素添加到输入框组中。 123456789101112131415161718&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;input type=&quot;checkbox&quot; aria-label=&quot;...&quot;&gt; &lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;input type=&quot;radio&quot; aria-label=&quot;...&quot;&gt; &lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt;&lt;/div&gt;&lt;!-- /.row --&gt; 作为额外元素的按钮为输入框组添加按钮需要额外添加一层嵌套，不是 .input-group-addon，而是添加 .input-group-btn 来包裹按钮元素。由于不同浏览器的默认样式无法被统一的重新赋值，所以才需要这样做。 Go!Go! 123456789101112131415161718&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot;&gt;Go!&lt;/button&gt; &lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search for...&quot;&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search for...&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot;&gt;Go!&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt;&lt;/div&gt;&lt;!-- /.row --&gt; 作为额外元素的按钮式下拉菜单Action Action 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /btn-group --&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=&quot;dropdown-menu dropdown-menu-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /btn-group --&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt;&lt;/div&gt;&lt;!-- /.row --&gt; 作为额外元素的分裂式按钮下拉菜单Action Toggle DropdownAction Toggle Dropdown 12345678910111213&lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;!-- Button and dropdown menu --&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;!-- Button and dropdown menu --&gt; &lt;/div&gt;&lt;/div&gt; Multiple buttonsWhile you can only have one add-on per side, you can have multiple buttons inside a single .input-group-btn. Action 12345678910111213&lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;!-- Buttons --&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; aria-label=&quot;...&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;!-- Buttons --&gt; &lt;/div&gt;&lt;/div&gt; 导航Bootstrap 中的导航组件都依赖同一个 .nav 类，状态类也是共用的。改变修饰类可以改变样式。 在标签页上使用导航需要依赖 JavaScript 标签页插件由于标签页需要控制内容区的展示，因此，你必须使用 标签页组件的 JavaScript 插件。另外还要添加 role 和 ARIA 属性 – 详细信息请参考该插件的 实例。 确保导航组件的可访问性如果你在使用导航组件实现导航条功能，务必在 &lt;ul&gt; 的最外侧的逻辑父元素上添加 role=&quot;navigation&quot; 属性，或者用一个 &lt;nav&gt; 元素包裹整个导航组件。不要将 role 属性添加到 &lt;ul&gt; 上，因为这样可以被辅助设备（残疾人用的）上被识别为一个真正的列表。 标签页注意 .nav-tabs 类依赖 .nav 基类。 Home Profile Messages 12345&lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;presentation&quot;&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;presentation&quot;&gt;&lt;a href=&quot;#&quot;&gt;Messages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 胶囊式标签页HTML 标记相同，但使用 .nav-pills 类： Home Profile Messages 12345&lt;ul class=&quot;nav nav-pills&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;presentation&quot;&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;presentation&quot;&gt;&lt;a href=&quot;#&quot;&gt;Messages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 胶囊是标签页也是可以垂直方向堆叠排列的。只需添加 .nav-stacked 类。 Home Profile Messages 123&lt;ul class=&quot;nav nav-pills nav-stacked&quot;&gt; ...&lt;/ul&gt; 两端对齐的标签页在大于 768px 的屏幕上，通过 .nav-justified 类可以很容易的让标签页或胶囊式标签呈现出同等宽度。在小屏幕上，导航链接呈现堆叠样式。 两端对齐的导航条导航链接已经被弃用了。 Safari 和响应式两端对齐导航从 v9.1.2 版本开始，Safari 有一个bug：对于两端对齐的导航，水平改变浏览器大小将引起绘制错误。此bug可以在两端对齐的导航实例中得到重现。 Home Profile Messages Home Profile Messages 123456&lt;ul class=&quot;nav nav-tabs nav-justified&quot;&gt; ...&lt;/ul&gt;&lt;ul class=&quot;nav nav-pills nav-justified&quot;&gt; ...&lt;/ul&gt; 禁用的链接对任何导航组件（标签页、胶囊式标签页），都可以添加 .disabled 类，从而实现链接为灰色且没有鼠标悬停效果。 链接功能不受到影响这个类只改变 &lt;a&gt; 的外观，不改变功能。可以自己写 JavaScript 禁用这里的链接。 Clickable link Clickable link Disabled link 12345&lt;ul class=&quot;nav nav-pills&quot;&gt; ... &lt;li role=&quot;presentation&quot; class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;Disabled link&lt;/a&gt;&lt;/li&gt; ...&lt;/ul&gt; 添加下拉菜单用一点点额外 HTML 代码并加入下拉菜单插件的 JavaScript 插件即可。 带下拉菜单的标签页 Home Help Dropdown 123456789101112&lt;ul class=&quot;nav nav-tabs&quot;&gt; ... &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; ... &lt;/ul&gt; &lt;/li&gt; ...&lt;/ul&gt; 带下拉菜单的胶囊式标签页 Home Help Dropdown 123456789101112&lt;ul class=&quot;nav nav-pills&quot;&gt; ... &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; ... &lt;/ul&gt; &lt;/li&gt; ...&lt;/ul&gt; 导航条默认样式的导航条导航条是在您的应用或网站中作为导航页头的响应式基础组件。它们在移动设备上可以折叠（并且可开可关），且在视口（viewport）宽度增加时逐渐变为水平展开模式。 两端对齐的导航条导航链接已经被弃用了。 导航条内所包含元素溢出由于 Bootstrap 并不知道你在导航条内放置的元素需要占据多宽的空间，你可能会遇到导航条中的内容折行的情况（也就是导航条占据两行）。解决办法如下： 减少导航条内所有元素所占据的宽度。 在某些尺寸的屏幕上（利用 响应式工具类）隐藏导航条内的一些元素。 修改导航条在水平排列和折叠排列互相转化时，触发这个转化的最小屏幕宽度值。可以通过修改 @grid-float-breakpoint 变量实现，或者自己重写相关的媒体查询代码，覆盖 Bootstrap 的默认值。 依赖 JavaScript 插件如果 JavaScript 被禁用，并且视口（viewport）足够窄，致使导航条折叠起来，导航条将不能被打开，.navbar-collapse 内所包含的内容也将不可见。 响应式导航条依赖 collapse 插件，定制 Bootstrap 的话时候必将其包含。 修改视口的阈值，从而影响导航条的排列模式当浏览器视口（viewport）的宽度小于 @grid-float-breakpoint 值时，导航条内部的元素变为折叠排列，也就是变现为移动设备展现模式；当浏览器视口（viewport）的宽度大于 @grid-float-breakpoint 值时，导航条内部的元素变为水平排列，也就是变现为非移动设备展现模式。通过调整源码中的这个值，就可以控制导航条何时堆叠排列，何时水平排列。默认值是 768px （小屏幕 – 或者说是平板 –的最小值，或者说是平板）。 导航条的可访问性务必使用 &lt;nav&gt; 元素，或者，如果使用的是通用的 &lt;div&gt; 元素的话，务必为导航条设置 role=&quot;navigation&quot; 属性，这样能够让使用辅助设备的用户明确知道这是一个导航区域。 BrandLink(current)LinkDropdown SubmitLinkDropdown 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 品牌图标将导航条内放置品牌标志的地方替换为 &lt;img&gt; 元素即可展示自己的品牌图标。由于 .navbar-brand 已经被设置了内补（padding）和高度（height），你需要根据自己的情况添加一些 CSS 代码从而覆盖默认设置。 [ Brand](../../../../../../../data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAB+0lEQVR4AcyYg5LkUBhG+1X2PdZGaW3btm3btm3bHttWrPomd1r/2Jn/VJ02TpxcH4CQ/dsuazWgzbIdrm9dZVd4pBz4zx2igTaFHrhvjneVXNHCSqIlFEjiwMyyyOBilRgGSqLNF1jnwNQdIvAt48C3IlBmHCiLQHC2zoHDu6zG1iXn6+y62ScxY9AODO6w0pvAqf23oSE4joOfH6OxfMoRnoGUm+de8wykbFt6wZtA07QwtNOqKh3ZbS3Wzz2F+1c/QJY0UCJ/J3kXWJfv7VhxCRRV1jGw7XI+gcO7rEFFRvdYxydwcPsVsC0bQdKScngt4iUTD4Fy/8p7PoHzRu1DclwmgmiqgUXjD3oTKHbAt869qdJ7l98jNTEblPTkXMwetpvnftA0LLHb4X8kiY9Kx6Q+W7wJtG0HR7fdrtYz+x7iya0vkEtUULIzCjC21wY+W/GYXusRH5kGytWTLxgEEhePPwhKYb7EK3BQuxWwTBuUkd3X8goUn6fMHLyTT+DCsQdAEXNzSMeVPAJHdF2DmH8poCREp3uwm7HsGq9J9q69iuunX6EgrwQVObjpBt8z6rdPfvE8kiiyhsvHnomrQx6BxYUyYiNS8f75H1w4/ISepDZLoDhNJ9cdNUquhRsv+6EP9oNH7Iff2A9g8h8CLt1gH0Qf9NMQAFnO60BJFQe0AAAAAElFTkSuQmCC) 123456789&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt; &lt;img alt=&quot;Brand&quot; src=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 表单将表单放置于 .navbar-form 之内可以呈现很好的垂直对齐，并在较窄的视口（viewport）中呈现折叠状态。 使用对齐选项可以规定其在导航条上出现的位置。 注意，.navbar-form 和 .form-inline 的大部分代码都一样，内部实现使用了 mixin。 某些表单组件，例如输入框组，可能需要设置一个固定宽度，从而在导航条内有合适的展现。 Brand Submit 123456&lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 移动设备上的注意事项在移动设备上，对于在 fixed 定位的元素内使用表单控件的情况有一些注意事项。请参考我们提供的浏览器支持情况相关的文档 。 为输入框添加 label 标签如果你没有为输入框添加 label 标签，屏幕阅读器将会遇到问题。对于导航条内的表单，可以通过添加 .sr-only 类隐藏 label 标签。 按钮对于不包含在 &lt;form&gt; 中的 &lt;button&gt; 元素，加上 .navbar-btn 后，可以让它在导航条里垂直居中。有一些对于为辅助设备提供可识别标签的方法，例如， aria-label、aria-labelledby 或者 title 属性。如果这些方法都没有，屏幕阅读器将使用 placeholder属性（如果这个属性存在的话），但是请注意，使用 placeholder 代替其他识别标签的方式是不推荐的。 BrandSign in 1&lt;button type=&quot;button&quot; class=&quot;btn btn-default navbar-btn&quot;&gt;Sign in&lt;/button&gt; 基于情境的用法就像标准的 按钮类 一样，.navbar-btn 可以被用在 &lt;a&gt; 和 &lt;input&gt; 元素上。然而，在 .navbar-nav 内，.navbar-btn 和标准的按钮类都不应该被用在 &lt;a&gt; 元素上。 文本把文本包裹在 .navbar-text中时，为了有正确的行距和颜色，通常使用 &lt;p&gt; 标签。 BrandSigned in as Mark Otto 1&lt;p class=&quot;navbar-text&quot;&gt;Signed in as Mark Otto&lt;/p&gt; 非导航的链接或许你希望在标准的导航组件之外添加标准链接，那么，使用 .navbar-link 类可以让链接有正确的默认颜色和反色设置。 BrandSigned in as Mark Otto 1&lt;p class=&quot;navbar-text navbar-right&quot;&gt;Signed in as &lt;a href=&quot;#&quot; class=&quot;navbar-link&quot;&gt;Mark Otto&lt;/a&gt;&lt;/p&gt; 组件排列通过添加 .navbar-left 和 .navbar-right 工具类让导航链接、表单、按钮或文本对齐。两个类都会通过 CSS 设置特定方向的浮动样式。例如，要对齐导航链接，就要把它们放在个分开的、应用了工具类的 &lt;ul&gt; 标签里。 这些类是 .pull-left 和 .pull-right 的 mixin 版本，但是他们被限定在了媒体查询（media query）中，这样可以更容易的在各种尺寸的屏幕上处理导航条组件。 向右侧对齐多个组件导航条目前不支持多个 .navbar-right 类。为了让内容之间有合适的空隙，我们为最后一个 .navbar-right 元素使用负边距（margin）。如果有多个元素使用这个类，它们的边距（margin）将不能按照你的预期正常展现。 我们将在 v4 版本中重写这个组件时重新审视这个功能。 固定在顶部添加 .navbar-fixed-top 类可以让导航条固定在顶部，还可包含一个 .container 或 .container-fluid 容器，从而让导航条居中，并在两侧添加内补（padding）。 BrandHomeLinkLink 12345&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot;&gt; &lt;div class=&quot;container&quot;&gt; ... &lt;/div&gt;&lt;/nav&gt; 需要为 body 元素设置内补（padding）这个固定的导航条会遮住页面上的其它内容，除非你给 &lt;body&gt; 元素底部设置了 padding。用你自己的值，或用下面给出的代码都可以。提示：导航条的默认高度是 50px。 1body &#123; padding-top: 70px; &#125; Make sure to include this after the core Bootstrap CSS. 固定在底部添加 .navbar-fixed-bottom 类可以让导航条固定在底部，并且还可以包含一个 .container 或 .container-fluid 容器，从而让导航条居中，并在两侧添加内补（padding）。 BrandHomeLinkLink 12345&lt;nav class=&quot;navbar navbar-default navbar-fixed-bottom&quot;&gt; &lt;div class=&quot;container&quot;&gt; ... &lt;/div&gt;&lt;/nav&gt; 需要为 body 元素设置内补（padding）这个固定的导航条会遮住页面上的其它内容，除非你给 &lt;body&gt; 元素底部设置了 padding。用你自己的值，或用下面给出的代码都可以。提示：导航条的默认高度是 50px。 1body &#123; padding-bottom: 70px; &#125; Make sure to include this after the core Bootstrap CSS. 静止在顶部通过添加 .navbar-static-top 类即可创建一个与页面等宽度的导航条，它会随着页面向下滚动而消失。还可以包含一个 .container或 .container-fluid 容器，用于将导航条居中对齐并在两侧添加内补（padding）。 与 .navbar-fixed-* 类不同的是，你不用给 body 添加任何内补（padding）。 BrandHomeLinkLink 12345&lt;nav class=&quot;navbar navbar-default navbar-static-top&quot;&gt; &lt;div class=&quot;container&quot;&gt; ... &lt;/div&gt;&lt;/nav&gt; 反色的导航条通过添加 .navbar-inverse 类可以改变导航条的外观。 BrandHomeLinkLink 123&lt;nav class=&quot;navbar navbar-inverse&quot;&gt; ...&lt;/nav&gt; 路径导航在一个带有层次的导航结构中标明当前页面的位置。 各路径间的分隔符已经自动通过 CSS 的 :before 和 content 属性添加了。 Home Home Library Home Library Data 12345&lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Library&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;Data&lt;/li&gt;&lt;/ol&gt; 分页为您的网站或应用提供带有展示页码的分页组件，或者可以使用简单的翻页组件。 默认分页受 Rdio 的启发，我们提供了这个简单的分页组件，用在应用或搜索结果中超级棒。组件中的每个部分都很大，优点是容易点击、易缩放、点击区域大。 «12345» 12345678910111213141516171819&lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; Labelling the pagination componentThe pagination component should be wrapped in a &lt;nav&gt; element to identify it as a navigation section to screen readers and other assistive technologies. In addition, as a page is likely to have more than one such navigation section already (such as the primary navigation in the header, or a sidebar navigation), it is advisable to provide a descriptive aria-label for the &lt;nav&gt; which reflects its purpose. For example, if the pagination component is used to navigate between a set of search results, an appropriate label could be aria-label=&quot;Search results pages&quot;. 禁用和激活状态链接在不同情况下可以定制。你可以给不能点击的链接添加 .disabled 类、给当前页添加 .active 类。 «1(current)2345» 1234567&lt;nav aria-label=&quot;...&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;1 &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; ... &lt;/ul&gt;&lt;/nav&gt; 我们建议将 active 或 disabled 状态的链接（即 &lt;a&gt; 标签）替换为 &lt;span&gt; 标签，或者在向前/向后的箭头处省略&lt;a&gt; 标签，这样就可以让其保持需要的样式而不能被点击。 12345678910111213&lt;nav aria-label=&quot;...&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;span&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;active&quot;&gt; &lt;span&gt;1 &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/span&gt; &lt;/li&gt; ... &lt;/ul&gt;&lt;/nav&gt; 尺寸想要更小或更大的分页？.pagination-lg 或 .pagination-sm 类提供了额外可供选择的尺寸。 «12345»«12345»«12345» 123&lt;nav aria-label=&quot;...&quot;&gt;&lt;ul class=&quot;pagination pagination-lg&quot;&gt;...&lt;/ul&gt;&lt;/nav&gt;&lt;nav aria-label=&quot;...&quot;&gt;&lt;ul class=&quot;pagination&quot;&gt;...&lt;/ul&gt;&lt;/nav&gt;&lt;nav aria-label=&quot;...&quot;&gt;&lt;ul class=&quot;pagination pagination-sm&quot;&gt;...&lt;/ul&gt;&lt;/nav&gt; 翻页用简单的标记和样式，就能做个上一页和下一页的简单翻页。用在像博客和杂志这样的简单站点上棒极了。 默认实例在默认的翻页中，链接居中对齐。 Previous Next 123456&lt;nav aria-label=&quot;...&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 对齐链接你还可以把链接向两端对齐： ← OlderNewer → 123456&lt;nav aria-label=&quot;...&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;larr;&lt;/span&gt; Older&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;#&quot;&gt;Newer &lt;span aria-hidden=&quot;true&quot;&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 可选的禁用状态.disabled 类也可用于翻页中的链接。 ← OlderNewer → 123456&lt;nav aria-label=&quot;...&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;larr;&lt;/span&gt; Older&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;#&quot;&gt;Newer &lt;span aria-hidden=&quot;true&quot;&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 标签实例Example heading NewExample heading NewExample heading NewExample heading NewExample heading NewExample heading New1&lt;h3&gt;Example heading &lt;span class=&quot;label label-default&quot;&gt;New&lt;/span&gt;&lt;/h3&gt; 可用的变体用下面的任何一个类即可改变标签的外观。 Default Primary Success Info Warning Danger 123456&lt;span class=&quot;label label-default&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;label label-primary&quot;&gt;Primary&lt;/span&gt;&lt;span class=&quot;label label-success&quot;&gt;Success&lt;/span&gt;&lt;span class=&quot;label label-info&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;label label-warning&quot;&gt;Warning&lt;/span&gt;&lt;span class=&quot;label label-danger&quot;&gt;Danger&lt;/span&gt; 如果标签数量很多怎么办？如果你有大量的设置为 inline 属性的标签全部放在一个较窄的容器元素内，在页面上展示这些标签就会出现问题，每个标签就会有自己的一个 inline-block 元素（就像图标一样）。解决的办法是为每个标签都设置为 display: inline-block; 属性。关于这个问题以及实例，请参考 #13219 。 徽章给链接、导航等元素嵌套 &lt;span class=&quot;badge&quot;&gt; 元素，可以很醒目的展示新的或未读的信息条目。 Inbox 42Messages 4 12345&lt;a href=&quot;#&quot;&gt;Inbox &lt;span class=&quot;badge&quot;&gt;42&lt;/span&gt;&lt;/a&gt;&lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot;&gt; Messages &lt;span class=&quot;badge&quot;&gt;4&lt;/span&gt;&lt;/button&gt; Self collapsing如果没有新的或未读的信息条目，也就是说不包含任何内容，徽章组件能够自动隐藏（通过CSS的 :empty 选择符实现) 。 跨浏览器兼容性徽章组件在 Internet Explorer 8 浏览器中不会自动消失，因为 IE8 不支持 :empty 选择符。 适配导航元素的激活状态Bootstrap 提供了内置的样式，让胶囊式导航内处于激活状态的元素所包含的徽章展示相匹配的样式。 Home 42 Profile Messages 3 12345&lt;ul class=&quot;nav nav-pills&quot; role=&quot;tablist&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home &lt;span class=&quot;badge&quot;&gt;42&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;presentation&quot;&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;presentation&quot;&gt;&lt;a href=&quot;#&quot;&gt;Messages &lt;span class=&quot;badge&quot;&gt;3&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 巨幕这是一个轻量、灵活的组件，它能延伸至整个浏览器视口来展示网站上的关键内容。 Hello, world!This is a simple hero unit, a simple jumbotron-style component for calling extra attention to featured content or information. Learn more 12345&lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;Learn more&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 如果需要让巨幕组件的宽度与浏览器宽度一致并且没有圆角，请把此组件放在所有 .container 元素的外面，并在组件内部添加一个 .container 元素。 12345&lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; ... &lt;/div&gt;&lt;/div&gt; 页头页头组件能够为 h1 标签增加适当的空间，并且与页面的其他部分形成一定的分隔。它支持 h1 标签内内嵌 small 元素的默认效果，还支持大部分其他组件（需要增加一些额外的样式）。 Example page header Subtext for header123&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Example page header &lt;small&gt;Subtext for header&lt;/small&gt;&lt;/h1&gt;&lt;/div&gt; 缩略图通过缩略图组件扩展 Bootstrap 的 栅格系统，可以很容易地展示栅格样式的图像、视频、文本等内容。 如果你想实现一个类似 Pinterest 的页面效果（不同高度和/宽度的缩略图顺序排列）的话，你需要使用一个第三方插件，比如 Masonry、Isotope 或 Salvattore。 默认样式的实例Boostrap 缩略图的默认设计仅需最少的标签就能展示带链接的图片。 [ 100%x180](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTcxIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE3MSAxODAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzEwMCV4MTgwCkNyZWF0ZWQgd2l0aCBIb2xkZXIuanMgMi42LjAuCkxlYXJuIG1vcmUgYXQgaHR0cDovL2hvbGRlcmpzLmNvbQooYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jbwotLT48ZGVmcz48c3R5bGUgdHlwZT0idGV4dC9jc3MiPjwhW0NEQVRBWyNob2xkZXJfMTYyYjUyZjU0NGUgdGV4dCB7IGZpbGw6I0FBQUFBQTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZiwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB0IH0gXV0+PC9zdHlsZT48L2RlZnM+PGcgaWQ9ImhvbGRlcl8xNjJiNTJmNTQ0ZSI+PHJlY3Qgd2lkdGg9IjE3MSIgaGVpZ2h0PSIxODAiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSI1OS41NTQ2ODc1IiB5PSI5NC41Ij4xNzF4MTgwPC90ZXh0PjwvZz48L2c+PC9zdmc+) [ 100%x180](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTcxIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE3MSAxODAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzEwMCV4MTgwCkNyZWF0ZWQgd2l0aCBIb2xkZXIuanMgMi42LjAuCkxlYXJuIG1vcmUgYXQgaHR0cDovL2hvbGRlcmpzLmNvbQooYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jbwotLT48ZGVmcz48c3R5bGUgdHlwZT0idGV4dC9jc3MiPjwhW0NEQVRBWyNob2xkZXJfMTYyYjUyZmEzZjIgdGV4dCB7IGZpbGw6I0FBQUFBQTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZiwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB0IH0gXV0+PC9zdHlsZT48L2RlZnM+PGcgaWQ9ImhvbGRlcl8xNjJiNTJmYTNmMiI+PHJlY3Qgd2lkdGg9IjE3MSIgaGVpZ2h0PSIxODAiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSI1OS41NTQ2ODc1IiB5PSI5NC41Ij4xNzF4MTgwPC90ZXh0PjwvZz48L2c+PC9zdmc+) [ 100%x180](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTcxIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE3MSAxODAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzEwMCV4MTgwCkNyZWF0ZWQgd2l0aCBIb2xkZXIuanMgMi42LjAuCkxlYXJuIG1vcmUgYXQgaHR0cDovL2hvbGRlcmpzLmNvbQooYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jbwotLT48ZGVmcz48c3R5bGUgdHlwZT0idGV4dC9jc3MiPjwhW0NEQVRBWyNob2xkZXJfMTYyYjUyZjhjMTYgdGV4dCB7IGZpbGw6I0FBQUFBQTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZiwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB0IH0gXV0+PC9zdHlsZT48L2RlZnM+PGcgaWQ9ImhvbGRlcl8xNjJiNTJmOGMxNiI+PHJlY3Qgd2lkdGg9IjE3MSIgaGVpZ2h0PSIxODAiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSI1OS41NTQ2ODc1IiB5PSI5NC41Ij4xNzF4MTgwPC90ZXh0PjwvZz48L2c+PC9zdmc+) [ 100%x180](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTcxIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE3MSAxODAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzEwMCV4MTgwCkNyZWF0ZWQgd2l0aCBIb2xkZXIuanMgMi42LjAuCkxlYXJuIG1vcmUgYXQgaHR0cDovL2hvbGRlcmpzLmNvbQooYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jbwotLT48ZGVmcz48c3R5bGUgdHlwZT0idGV4dC9jc3MiPjwhW0NEQVRBWyNob2xkZXJfMTYyYjUyZmFjZGEgdGV4dCB7IGZpbGw6I0FBQUFBQTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZiwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB0IH0gXV0+PC9zdHlsZT48L2RlZnM+PGcgaWQ9ImhvbGRlcl8xNjJiNTJmYWNkYSI+PHJlY3Qgd2lkdGg9IjE3MSIgaGVpZ2h0PSIxODAiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSI1OS41NTQ2ODc1IiB5PSI5NC41Ij4xNzF4MTgwPC90ZXh0PjwvZz48L2c+PC9zdmc+) 12345678&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-md-3&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; ...&lt;/div&gt; 自定义内容添加一点点额外的标签，就可以把任何类型的 HTML 内容，例如标题、段落或按钮，加入缩略图组件内。 Thumbnail labelCras justo odio, dapibus ac facilisis in, egestas eget quam. Donec id elit non mi porta gravida at eget metus. Nullam id dolor id nibh ultricies vehicula ut id elit. Button Button Thumbnail labelCras justo odio, dapibus ac facilisis in, egestas eget quam. Donec id elit non mi porta gravida at eget metus. Nullam id dolor id nibh ultricies vehicula ut id elit. Button Button Thumbnail labelCras justo odio, dapibus ac facilisis in, egestas eget quam. Donec id elit non mi porta gravida at eget metus. Nullam id dolor id nibh ultricies vehicula ut id elit. Button Button 123456789101112&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6 col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h3&gt;Thumbnail label&lt;/h3&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot; role=&quot;button&quot;&gt;Button&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default&quot; role=&quot;button&quot;&gt;Button&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 警告框警告框组件通过提供一些灵活的预定义消息，为常见的用户动作提供反馈消息。 实例将任意文本和一个可选的关闭按钮组合在一起就能组成一个警告框，.alert 类是必须要设置的，另外我们还提供了有特殊意义的4个类（例如，.alert-success），代表不同的警告信息。 没有默认类警告框没有默认类，只有基类和修饰类。默认的灰色警告框并没有多少意义。所以您要使用一种有意义的警告类。目前提供了成功、消息、警告或危险。 Well done! You successfully read this important alert message. Heads up! This alert needs your attention, but it’s not super important. Warning! Better check yourself, you’re not looking too good. Oh snap! Change a few things up and try submitting again. 1234&lt;div class=&quot;alert alert-success&quot; role=&quot;alert&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt;...&lt;/div&gt; 可关闭的警告框为警告框添加一个可选的 .alert-dismissible 类和一个关闭按钮。 依赖警告框 JavaScript 插件如果需要为警告框组件提供关闭功能，请使用 jQuery 警告框插件。 ×Warning! Better check yourself, you’re not looking too good. 1234&lt;div class=&quot;alert alert-warning alert-dismissible&quot; role=&quot;alert&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;strong&gt;Warning!&lt;/strong&gt; Better check yourself, you&apos;re not looking too good.&lt;/div&gt; 确保在所有设备上的正确行为务必给 &lt;button&gt; 元素添加 data-dismiss=&quot;alert&quot; 属性。 警告框中的链接用 .alert-link 工具类，可以为链接设置与当前警告框相符的颜色。 Well done! You successfully read this important alert message. Heads up! This alert needs your attention, but it’s not super important. Warning! Better check yourself, you’re not looking too good. Oh snap! Change a few things up and try submitting again. 123456789101112&lt;div class=&quot;alert alert-success&quot; role=&quot;alert&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;alert-link&quot;&gt;...&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;alert-link&quot;&gt;...&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;alert-link&quot;&gt;...&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;alert-link&quot;&gt;...&lt;/a&gt;&lt;/div&gt; 进度条通过这些简单、灵活的进度条，为当前工作流程或动作提供实时反馈。 跨浏览器兼容性进度条组件使用了 CSS3 的 transition 和 animation 属性来完成一些特效。这些特性在 Internet Explorer 9 或以下版本中、Firefox 的老版本中没有被支持。Opera 12 不支持 animation 属性。 Content Security Policy (CSP) compatibilityIf your website has a Content Security Policy (CSP) which doesn’t allow style-src &#39;unsafe-inline&#39;, then you won’t be able to use inline style attributes to set progress bar widths as shown in our examples below. Alternative methods for setting the widths that are compatible with strict CSPs include using a little custom JavaScript (that sets element.style.width) or using custom CSS classes. 基本实例默认样式的进度条 60% Complete 12345&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 60%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;60% Complete&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 带有提示标签的进度条将设置了 .sr-only 类的 &lt;span&gt; 标签从进度条组件中移除 类，从而让当前进度显示出来。 60% 12345&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 60%;&quot;&gt; 60% &lt;/div&gt;&lt;/div&gt; 在展示很低的百分比时，如果需要让文本提示能够清晰可见，可以为进度条设置 min-width 属性。 0% 2% 12345678910&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;0&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;min-width: 2em;&quot;&gt; 0% &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;2&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;min-width: 2em; width: 2%;&quot;&gt; 2% &lt;/div&gt;&lt;/div&gt; 根据情境变化效果进度条组件使用与按钮和警告框相同的类，根据不同情境展现相应的效果。 40% Complete (success) 20% Complete 60% Complete (warning) 80% Complete (danger) 1234567891011121314151617181920&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;40&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 40%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;40% Complete (success)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-info&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;20&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 20%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;20% Complete&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-warning&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 60%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;60% Complete (warning)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-danger&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;80&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 80%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;80% Complete (danger)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 条纹效果通过渐变可以为进度条创建条纹效果，IE9 及更低版本不支持。 40% Complete (success) 20% Complete 60% Complete (warning) 80% Complete (danger) 1234567891011121314151617181920&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-success progress-bar-striped&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;40&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 40%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;40% Complete (success)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-info progress-bar-striped&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;20&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 20%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;20% Complete&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-warning progress-bar-striped&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 60%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;60% Complete (warning)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-danger progress-bar-striped&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;80&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 80%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;80% Complete (danger)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 动画效果为 .progress-bar-striped 添加 .active 类，使其呈现出由右向左运动的动画效果。IE9 及更低版本的浏览器不支持。 45% Complete 12345&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-striped active&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;45&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 45%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;45% Complete&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 堆叠效果把多个进度条放入同一个 .progress 中，使它们呈现堆叠的效果。 35% Complete (success) 20% Complete (warning) 10% Complete (danger) 1234567891011&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-success&quot; style=&quot;width: 35%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;35% Complete (success)&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;progress-bar progress-bar-warning progress-bar-striped&quot; style=&quot;width: 20%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;20% Complete (warning)&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;progress-bar progress-bar-danger&quot; style=&quot;width: 10%&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;10% Complete (danger)&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 媒体对象这是一个抽象的样式，用以构建不同类型的组件，这些组件都具有在文本内容的左或右侧对齐的图片（就像博客评论或 Twitter 消息等）。 默认样式默认样式的媒体对象组件允许在一个内容块的左边或右边展示一个多媒体内容（图像、视频、音频）。 [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmYTdkOSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmZhN2Q5Ij48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Media heading[ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNTRmNCB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY1NGY0Ij48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Media heading[ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmN2Q3ZSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY3ZDdlIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Nested media headingMedia heading[ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNGJlYyB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY0YmVjIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNDBiYyB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY0MGJjIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Media heading[ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNDkzMSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY0OTMxIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) 1234567891011&lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img class=&quot;media-object&quot; src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;Media heading&lt;/h4&gt; ... &lt;/div&gt;&lt;/div&gt; .pull-left 和 .pull-right 这两个类以前也曾经被用在了媒体组件上，但是，从 v3.3.0 版本开始，他们就不再被建议使用了。.media-left 和 .media-right 替代了他们，不同之处是，在 html 结构中， .media-right 应当放在 .media-body 的后面。 对齐图片或其他媒体类型可以顶部、中部或底部对齐。默认是顶部对齐。 [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmOGY0YSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY4ZjRhIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Top aligned mediaCras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. Donec sed odio dui. Nullam quis risus eget urna mollis ornare vel eu leo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmOGU0OSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY4ZTQ5Ij48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Middle aligned mediaCras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. Donec sed odio dui. Nullam quis risus eget urna mollis ornare vel eu leo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmODYxOSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY4NjE5Ij48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Bottom aligned mediaCras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. Donec sed odio dui. Nullam quis risus eget urna mollis ornare vel eu leo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. 1234567891011&lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-left media-middle&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img class=&quot;media-object&quot; src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;Middle aligned media&lt;/h4&gt; ... &lt;/div&gt;&lt;/div&gt; 媒体对象列表用一点点额外的标记，就能在列表内使用媒体对象组件（对评论或文章列表很有用）。 [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNDgzYSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY0ODNhIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Media headingCras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. [ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNzA2YiB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY3MDZiIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Nested media heading[ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmNTQ3NCB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmY1NDc0Ij48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Nested media heading[ 64x64](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+PCEtLQpTb3VyY2UgVVJMOiBob2xkZXIuanMvNjR4NjQKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJmYWNlMiB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmZhY2UyIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNFRUVFRUUiLz48Zz48dGV4dCB4PSIxMy40Njg3NSIgeT0iMzYuNSI+NjR4NjQ8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) Nested media heading 12345678910111213&lt;ul class=&quot;media-list&quot;&gt; &lt;li class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img class=&quot;media-object&quot; src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;Media heading&lt;/h4&gt; ... &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 列表组列表组是灵活又强大的组件，不仅能用于显示一组简单的元素，还能用于复杂的定制的内容。 基本实例最简单的列表组仅仅是一个带有多个列表条目的无序列表，另外还需要设置适当的类。我们提供了一些预定义的样式，你可以根据自身的需求通过 CSS 自己定制。 Cras justo odio Dapibus ac facilisis in Morbi leo risus Porta ac consectetur ac Vestibulum at eros 1234567&lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;Cras justo odio&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Dapibus ac facilisis in&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Morbi leo risus&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Porta ac consectetur ac&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Vestibulum at eros&lt;/li&gt;&lt;/ul&gt; 徽章给列表组加入徽章组件，它会自动被放在右边。 14Cras justo odio 2Dapibus ac facilisis in 1Morbi leo risus 123456&lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt; &lt;span class=&quot;badge&quot;&gt;14&lt;/span&gt; Cras justo odio &lt;/li&gt;&lt;/ul&gt; 链接用 &lt;a&gt; 标签代替 &lt;li&gt; 标签可以组成一个全部是链接的列表组（还要注意的是，我们需要将 &lt;ul&gt; 标签替换为 &lt;div&gt; 标签）。没必要给列表组中的每个元素都加一个父元素。 Cras justo odioDapibus ac facilisis inMorbi leo risusPorta ac consectetur acVestibulum at eros 123456789&lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item active&quot;&gt; Cras justo odio &lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Dapibus ac facilisis in&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Morbi leo risus&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Vestibulum at eros&lt;/a&gt;&lt;/div&gt; 按钮列表组中的元素也可以直接就是按钮（也同时意味着父元素必须是 &lt;div&gt; 而不能用 &lt;ul&gt; 了），并且无需为每个按钮单独包裹一个父元素。注意不要使用标准的 .btn 类！ Cras justo odioDapibus ac facilisis inMorbi leo risusPorta ac consectetur acVestibulum at eros 1234567&lt;div class=&quot;list-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;list-group-item&quot;&gt;Cras justo odio&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;list-group-item&quot;&gt;Dapibus ac facilisis in&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;list-group-item&quot;&gt;Morbi leo risus&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;list-group-item&quot;&gt;Porta ac consectetur ac&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;list-group-item&quot;&gt;Vestibulum at eros&lt;/button&gt;&lt;/div&gt; 被禁用的条目为 .list-group-item 添加 .disabled 类可以让单个条目显示为灰色，表现出被禁用的效果。 Cras justo odioDapibus ac facilisis inMorbi leo risusPorta ac consectetur acVestibulum at eros 123456789&lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item disabled&quot;&gt; Cras justo odio &lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Dapibus ac facilisis in&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Morbi leo risus&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;Vestibulum at eros&lt;/a&gt;&lt;/div&gt; 情境类为列表中的条目添加情境类，默认样式或链接列表都可以。还可以为列表中的条目设置 .active 状态。 Dapibus ac facilisis in Cras sit amet nibh libero Porta ac consectetur ac Vestibulum at eros Dapibus ac facilisis inCras sit amet nibh liberoPorta ac consectetur acVestibulum at eros 123456789101112&lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item list-group-item-success&quot;&gt;Dapibus ac facilisis in&lt;/li&gt; &lt;li class=&quot;list-group-item list-group-item-info&quot;&gt;Cras sit amet nibh libero&lt;/li&gt; &lt;li class=&quot;list-group-item list-group-item-warning&quot;&gt;Porta ac consectetur ac&lt;/li&gt; &lt;li class=&quot;list-group-item list-group-item-danger&quot;&gt;Vestibulum at eros&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-success&quot;&gt;Dapibus ac facilisis in&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-info&quot;&gt;Cras sit amet nibh libero&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-warning&quot;&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-danger&quot;&gt;Vestibulum at eros&lt;/a&gt;&lt;/div&gt; 定制内容列表组中的每个元素都可以是任何 HTML 内容，甚至是像下面的带链接的列表组。 List group item headingDonec id elit non mi porta gravida at eget metus. Maecenas sed diam eget risus varius blandit.List group item headingDonec id elit non mi porta gravida at eget metus. Maecenas sed diam eget risus varius blandit.List group item headingDonec id elit non mi porta gravida at eget metus. Maecenas sed diam eget risus varius blandit. 123456&lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item active&quot;&gt; &lt;h4 class=&quot;list-group-item-heading&quot;&gt;List group item heading&lt;/h4&gt; &lt;p class=&quot;list-group-item-text&quot;&gt;...&lt;/p&gt; &lt;/a&gt;&lt;/div&gt; 面版虽然不总是必须，但是某些时候你可能需要将某些 DOM 内容放到一个盒子里。对于这种情况，可以试试面板组件。 基本实例默认的 .panel 组件所做的只是设置基本的边框（border）和内补（padding）来包含内容。 Basic panel example 12345&lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; Basic panel example &lt;/div&gt;&lt;/div&gt; 带标题的面版通过 .panel-heading 可以很简单地为面板加入一个标题容器。你也可以通过添加设置了 .panel-title 类的 &lt;h1&gt;-&lt;h6&gt; 标签，添加一个预定义样式的标题。不过，&lt;h1&gt;-&lt;h6&gt; 标签的字体大小将被 .panel-heading 的样式所覆盖。 为了给链接设置合适的颜色，务必将链接放到带有 .panel-title 类的标题标签内。 Panel heading without title Panel content Panel titlePanel content 123456789101112131415&lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt;Panel heading without title&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; Panel content &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;Panel title&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; Panel content &lt;/div&gt;&lt;/div&gt; 带脚注的面版把按钮或次要的文本放入 .panel-footer 容器内。注意面版的脚注不会从情境效果中继承颜色，因为他们并不是主要内容。 Panel content Panel footer 123456&lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; Panel content &lt;/div&gt; &lt;div class=&quot;panel-footer&quot;&gt;Panel footer&lt;/div&gt;&lt;/div&gt; 情境效果像其他组件一样，可以简单地通过加入有情境效果的状态类，给特定的内容使用更针对特定情境的面版。 Panel titlePanel content Panel titlePanel content Panel titlePanel content Panel titlePanel content Panel titlePanel content 12345&lt;div class=&quot;panel panel-primary&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;panel panel-success&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;panel panel-info&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;panel panel-warning&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;panel panel-danger&quot;&gt;...&lt;/div&gt; 带表格的面版为面板中不需要边框的表格添加 .table 类，是整个面板看上去更像是一个整体设计。如果是带有 .panel-body 的面板，我们为表格的上方添加一个边框，看上去有分隔效果。 Panel heading Some default panel content here. Nulla vitae elit libero, a pharetra augue. Aenean lacinia bibendum nulla sed consectetur. Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Nullam id dolor id nibh ultricies vehicula ut id elit. # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123456789101112&lt;div class=&quot;panel panel-default&quot;&gt; &lt;!-- Default panel contents --&gt; &lt;div class=&quot;panel-heading&quot;&gt;Panel heading&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; &lt;!-- Table --&gt; &lt;table class=&quot;table&quot;&gt; ... &lt;/table&gt;&lt;/div&gt; 如果没有 .panel-body ，面版标题会和表格连接起来，没有空隙。 Panel heading # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123456789&lt;div class=&quot;panel panel-default&quot;&gt; &lt;!-- Default panel contents --&gt; &lt;div class=&quot;panel-heading&quot;&gt;Panel heading&lt;/div&gt; &lt;!-- Table --&gt; &lt;table class=&quot;table&quot;&gt; ... &lt;/table&gt;&lt;/div&gt; 带列表组的面版可以简单地在任何面版中加入具有最大宽度的列表组。 Panel heading Some default panel content here. Nulla vitae elit libero, a pharetra augue. Aenean lacinia bibendum nulla sed consectetur. Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Nullam id dolor id nibh ultricies vehicula ut id elit. Cras justo odio Dapibus ac facilisis in Morbi leo risus Porta ac consectetur ac Vestibulum at eros 12345678910111213141516&lt;div class=&quot;panel panel-default&quot;&gt; &lt;!-- Default panel contents --&gt; &lt;div class=&quot;panel-heading&quot;&gt;Panel heading&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; &lt;!-- List group --&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;Cras justo odio&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Dapibus ac facilisis in&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Morbi leo risus&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Porta ac consectetur ac&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Vestibulum at eros&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 具有响应式特性的嵌入内容根据被嵌入内容的外部容器的宽度，自动创建一个固定的比例，从而让浏览器自动确定视频或 slideshow 的尺寸，能够在各种设备上缩放。 这些规则被直接应用在 &lt;iframe&gt;、&lt;embed&gt;、&lt;video&gt; 和 &lt;object&gt; 元素上。如果你希望让最终样式与其他属性相匹配，还可以明确地使用一个派生出来的 .embed-responsive-item 类。 超级提示： 不需要为 &lt;iframe&gt; 元素设置 frameborder=&quot;0&quot; 属性，因为我们已经替你这样做了！ 123456789&lt;!-- 16:9 aspect ratio --&gt;&lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt; &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;...&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;!-- 4:3 aspect ratio --&gt;&lt;div class=&quot;embed-responsive embed-responsive-4by3&quot;&gt; &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;...&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; Well默认效果把 Well 用在元素上，就能有嵌入（inset）的简单效果。 Look, I’m in a well! 1&lt;div class=&quot;well&quot;&gt;...&lt;/div&gt; 可选类/样式通过这两种可选修饰类，可以控制此组件的内补（padding）和圆角的设置。 Look, I’m in a large well! 1&lt;div class=&quot;well well-lg&quot;&gt;...&lt;/div&gt; Look, I’m in a small well! 1&lt;div class=&quot;well well-sm&quot;&gt;...&lt;/div&gt;","categories":[],"tags":[]},{"title":"","slug":"JavaScript/bootstrap3/全局样式","date":"2018-04-11T14:48:05.000Z","updated":"2018-04-11T14:48:59.000Z","comments":true,"path":"2018/04/11/JavaScript/bootstrap3/全局样式/","link":"","permalink":"http://io.stelawliet.top/2018/04/11/JavaScript/bootstrap3/全局样式/","excerpt":"","text":"全局 CSS 样式设置全局 CSS 样式；基本的 HTML 元素均可以通过 class 设置样式并得到增强效果；还有先进的栅格系统。 概览深入了解 Bootstrap 底层结构的关键部分，包括我们让 web 开发变得更好、更快、更强壮的最佳实践。 HTML5 文档类型Bootstrap 使用到的某些 HTML 元素和 CSS 属性需要将页面设置为 HTML5 文档类型。在你项目中的每个页面都要参照下面的格式进行设置。 1234&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; ...&lt;/html&gt; 移动设备优先在 Bootstrap 2 中，我们对框架中的某些关键部分增加了对移动设备友好的样式。而在 Bootstrap 3 中，我们重写了整个框架，使其一开始就是对移动设备友好的。这次不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。也就是说，Bootstrap 是移动设备优先的。针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。 为了确保适当的绘制和触屏缩放，需要在 &lt;head&gt; 之中添加 viewport 元数据标签。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 user-scalable=no 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！ 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; 排版与链接Bootstrap 排版、链接样式设置了基本的全局样式。分别是： 为 body 元素设置 background-color: #fff; 使用 @font-family-base、@font-size-base 和 @line-height-base 变量作为排版的基本参数 为所有链接设置了基本颜色 @link-color ，并且当链接处于 :hover 状态时才添加下划线 这些样式都能在 scaffolding.less 文件中找到对应的源码。 Normalize.css为了增强跨浏览器表现的一致性，我们使用了 Normalize.css，这是由 Nicolas Gallagher 和 Jonathan Neal 维护的一个CSS 重置样式库。 布局容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。 .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 栅格系统Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。 简介栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-*栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-*不存在， 也影响大屏幕设备。 通过研究后面的实例，可以将这些原理应用到你的代码中。 媒体查询在栅格系统中，我们在 Less 文件中使用以下媒体查询（media query）来创建关键的分界点阈值。 1234567891011/* 超小屏幕（手机，小于 768px） *//* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） *//* 小屏幕（平板，大于等于 768px） */@media (min-width: @screen-sm-min) &#123; ... &#125;/* 中等屏幕（桌面显示器，大于等于 992px） */@media (min-width: @screen-md-min) &#123; ... &#125;/* 大屏幕（大桌面显示器，大于等于 1200px） */@media (min-width: @screen-lg-min) &#123; ... &#125; 我们偶尔也会在媒体查询代码中包含 max-width 从而将 CSS 的影响限制在更小范围的屏幕大小之内。 1234@media (max-width: @screen-xs-max) &#123; ... &#125;@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) &#123; ... &#125;@media (min-width: @screen-md-min) and (max-width: @screen-md-max) &#123; ... &#125;@media (min-width: @screen-lg-min) &#123; ... &#125; 栅格参数通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None （自动） 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 最大列（column）宽 自动 ~62px ~81px ~97px 槽（gutter）宽 30px （每列左右均有 15px） 可嵌套 是 偏移（Offsets） 是 列排序 是 实例：从堆叠到水平排列使用单一的一组 .col-md-* 栅格类，就可以创建一个基本的栅格系统，在手机和平板设备上一开始是堆叠在一起的（超小屏幕到小屏幕这一范围），在桌面（中等）屏幕设备上变为水平排列。所有“列（column）必须放在 ” .row 内。 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-1 .col-md-8 .col-md-4 .col-md-4 .col-md-4 .col-md-4 .col-md-6 .col-md-6 123456789101112131415161718192021222324252627&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;&lt;/div&gt; 实例：流式布局容器将最外面的布局元素 .container 修改为 .container-fluid，就可以将固定宽度的栅格布局转换为 100% 宽度的布局。 12345&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; ... &lt;/div&gt;&lt;/div&gt; 实例：移动设备和桌面屏幕是否不希望在小屏幕设备上所有列都堆叠在一起？那就使用针对超小屏幕和中等屏幕设备所定义的类吧，即 .col-xs-* 和 .col-md-*。请看下面的实例，研究一下这些是如何工作的。 .col-xs-12 .col-md-8 .col-xs-6 .col-md-4 .col-xs-6 .col-md-4 .col-xs-6 .col-md-4 .col-xs-6 .col-md-4 .col-xs-6 .col-xs-6 123456789101112131415161718&lt;!-- Stack the columns on mobile by making one full-width and the other half-width --&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-md-8&quot;&gt;.col-xs-12 .col-md-8&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns are always 50% wide, on mobile and desktop --&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt; &lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; 实例：手机、平板、桌面在上面案例的基础上，通过使用针对平板设备的 .col-sm-* 类，我们来创建更加动态和强大的布局吧。 .col-xs-12 .col-sm-6 .col-md-8 .col-xs-6 .col-md-4 .col-xs-6 .col-sm-4 .col-xs-6 .col-sm-4 .col-xs-6 .col-sm-4 1234567891011&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-sm-6 col-md-8&quot;&gt;.col-xs-12 .col-sm-6 .col-md-8&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt;.col-xs-6 .col-sm-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt;.col-xs-6 .col-sm-4&lt;/div&gt; &lt;!-- Optional: clear the XS cols if their content doesn&apos;t match in height --&gt; &lt;div class=&quot;clearfix visible-xs-block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt;.col-xs-6 .col-sm-4&lt;/div&gt;&lt;/div&gt; 实例：多余的列（column）将另起一行排列如果在一个 .row 内包含的列（column）大于12个，包含多余列（column）的元素将作为一个整体单元被另起一行排列。 .col-xs-9 .col-xs-4Since 9 + 4 = 13 &gt; 12, this 4-column-wide div gets wrapped onto a new line as one contiguous unit. .col-xs-6Subsequent columns continue along the new line. 12345&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-9&quot;&gt;.col-xs-9&lt;/div&gt; &lt;div class=&quot;col-xs-4&quot;&gt;.col-xs-4&lt;br&gt;Since 9 + 4 = 13 &amp;gt; 12, this 4-column-wide div gets wrapped onto a new line as one contiguous unit.&lt;/div&gt; &lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;br&gt;Subsequent columns continue along the new line.&lt;/div&gt;&lt;/div&gt; 响应式列重置即便有上面给出的四组栅格class，你也不免会碰到一些问题，例如，在某些阈值时，某些列可能会出现比别的列高的情况。为了克服这一问题，建议联合使用 .clearfix 和 响应式工具类。 .col-xs-6 .col-sm-3Resize your viewport or check it out on your phone for an example. .col-xs-6 .col-sm-3 .col-xs-6 .col-sm-3 .col-xs-6 .col-sm-3 12345678910&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;!-- Add the extra clearfix for only the required viewport --&gt; &lt;div class=&quot;clearfix visible-xs-block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt;&lt;/div&gt; 除了列在分界点清除响应， 您可能需要 重置偏移, 后推或前拉某个列。请看此栅格实例。 123456789&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-5 col-md-6&quot;&gt;.col-sm-5 .col-md-6&lt;/div&gt; &lt;div class=&quot;col-sm-5 col-sm-offset-2 col-md-6 col-md-offset-0&quot;&gt;.col-sm-5 .col-sm-offset-2 .col-md-6 .col-md-offset-0&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6 col-md-5 col-lg-6&quot;&gt;.col-sm-6 .col-md-5 .col-lg-6&lt;/div&gt; &lt;div class=&quot;col-sm-6 col-md-5 col-md-offset-2 col-lg-6 col-lg-offset-0&quot;&gt;.col-sm-6 .col-md-5 .col-md-offset-2 .col-lg-6 .col-lg-offset-0&lt;/div&gt;&lt;/div&gt; 列偏移使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距（margin）。例如，.col-md-offset-4 类将 .col-md-4 元素向右侧偏移了4个列（column）的宽度。 .col-md-4 .col-md-4 .col-md-offset-4 .col-md-3 .col-md-offset-3 .col-md-3 .col-md-offset-3 .col-md-6 .col-md-offset-3 1234567891011&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3 col-md-offset-3&quot;&gt;.col-md-3 .col-md-offset-3&lt;/div&gt; &lt;div class=&quot;col-md-3 col-md-offset-3&quot;&gt;.col-md-3 .col-md-offset-3&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;.col-md-6 .col-md-offset-3&lt;/div&gt;&lt;/div&gt; You can also override offsets from lower grid tiers with .col-*-offset-0 classes. 12345678&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-xs-offset-3 col-sm-4 col-sm-offset-0&quot;&gt; &lt;/div&gt;&lt;/div&gt; 嵌套列为了使用内置的栅格系统将内容再次嵌套，可以通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-* 元素内。被嵌套的行（row）所包含的列（column）的个数不能超过12（其实，没有要求你必须占满12列）。 Level 2: .col-xs-8 .col-sm-6 Level 2: .col-xs-4 .col-sm-6 12345678910111213&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; Level 1: .col-sm-9 &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-8 col-sm-6&quot;&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class=&quot;col-xs-4 col-sm-6&quot;&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。 .col-md-9 .col-md-push-3 .col-md-3 .col-md-pull-9 1234&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-9 col-md-push-3&quot;&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class=&quot;col-md-3 col-md-pull-9&quot;&gt;.col-md-3 .col-md-pull-9&lt;/div&gt;&lt;/div&gt; Less mixin 和变量除了用于快速布局的预定义栅格类，Bootstrap 还包含了一组 Less 变量和 mixin 用于帮你生成简单、语义化的布局。 变量通过变量来定义列数、槽（gutter）宽、媒体查询阈值（用于确定合适让列浮动）。我们使用这些变量生成预定义的栅格类，如上所示，还有如下所示的定制 mixin。 123@grid-columns: 12;@grid-gutter-width: 30px;@grid-float-breakpoint: 768px; mixinmixin 用来和栅格变量一同使用，为每个列（column）生成语义化的 CSS 代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// Creates a wrapper for a series of columns.make-row(@gutter: @grid-gutter-width) &#123; // Then clear the floated columns .clearfix(); @media (min-width: @screen-sm-min) &#123; margin-left: (@gutter / -2); margin-right: (@gutter / -2); &#125; // Negative margin nested rows out to align the content of columns .row &#123; margin-left: (@gutter / -2); margin-right: (@gutter / -2); &#125;&#125;// Generate the extra small columns.make-xs-column(@columns; @gutter: @grid-gutter-width) &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: (@gutter / 2); padding-right: (@gutter / 2); // Calculate width based on number of columns available @media (min-width: @grid-float-breakpoint) &#123; float: left; width: percentage((@columns / @grid-columns)); &#125;&#125;// Generate the small columns.make-sm-column(@columns; @gutter: @grid-gutter-width) &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: (@gutter / 2); padding-right: (@gutter / 2); // Calculate width based on number of columns available @media (min-width: @screen-sm-min) &#123; float: left; width: percentage((@columns / @grid-columns)); &#125;&#125;// Generate the small column offsets.make-sm-column-offset(@columns) &#123; @media (min-width: @screen-sm-min) &#123; margin-left: percentage((@columns / @grid-columns)); &#125;&#125;.make-sm-column-push(@columns) &#123; @media (min-width: @screen-sm-min) &#123; left: percentage((@columns / @grid-columns)); &#125;&#125;.make-sm-column-pull(@columns) &#123; @media (min-width: @screen-sm-min) &#123; right: percentage((@columns / @grid-columns)); &#125;&#125;// Generate the medium columns.make-md-column(@columns; @gutter: @grid-gutter-width) &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: (@gutter / 2); padding-right: (@gutter / 2); // Calculate width based on number of columns available @media (min-width: @screen-md-min) &#123; float: left; width: percentage((@columns / @grid-columns)); &#125;&#125;// Generate the medium column offsets.make-md-column-offset(@columns) &#123; @media (min-width: @screen-md-min) &#123; margin-left: percentage((@columns / @grid-columns)); &#125;&#125;.make-md-column-push(@columns) &#123; @media (min-width: @screen-md-min) &#123; left: percentage((@columns / @grid-columns)); &#125;&#125;.make-md-column-pull(@columns) &#123; @media (min-width: @screen-md-min) &#123; right: percentage((@columns / @grid-columns)); &#125;&#125;// Generate the large columns.make-lg-column(@columns; @gutter: @grid-gutter-width) &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: (@gutter / 2); padding-right: (@gutter / 2); // Calculate width based on number of columns available @media (min-width: @screen-lg-min) &#123; float: left; width: percentage((@columns / @grid-columns)); &#125;&#125;// Generate the large column offsets.make-lg-column-offset(@columns) &#123; @media (min-width: @screen-lg-min) &#123; margin-left: percentage((@columns / @grid-columns)); &#125;&#125;.make-lg-column-push(@columns) &#123; @media (min-width: @screen-lg-min) &#123; left: percentage((@columns / @grid-columns)); &#125;&#125;.make-lg-column-pull(@columns) &#123; @media (min-width: @screen-lg-min) &#123; right: percentage((@columns / @grid-columns)); &#125;&#125; 实例展示你可以重新修改这些变量的值，或者用默认值调用这些 mixin。下面就是一个利用默认设置生成两列布局（列之间有间隔）的案例。 12345678910.wrapper &#123; .make-row();&#125;.content-main &#123; .make-lg-column(8);&#125;.content-secondary &#123; .make-lg-column(3); .make-lg-column-offset(1);&#125; 1234&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content-main&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;content-secondary&quot;&gt;...&lt;/div&gt;&lt;/div&gt; 排版标题HTML 中的所有标题标签，&lt;h1&gt; 到 &lt;h6&gt; 均可使用。另外，还提供了 .h1 到 .h6 类，为的是给内联（inline）属性的文本赋予标题的样式。 h1. Bootstrap heading Semibold 36px h2. Bootstrap heading Semibold 30px h3. Bootstrap heading Semibold 24px h4. Bootstrap heading Semibold 18px h5. Bootstrap heading Semibold 14px h6. Bootstrap heading Semibold 12px 123456&lt;h1&gt;h1. Bootstrap heading&lt;/h1&gt;&lt;h2&gt;h2. Bootstrap heading&lt;/h2&gt;&lt;h3&gt;h3. Bootstrap heading&lt;/h3&gt;&lt;h4&gt;h4. Bootstrap heading&lt;/h4&gt;&lt;h5&gt;h5. Bootstrap heading&lt;/h5&gt;&lt;h6&gt;h6. Bootstrap heading&lt;/h6&gt; 在标题内还可以包含 &lt;small&gt; 标签或赋予 .small 类的元素，可以用来标记副标题。 h1. Bootstrap heading Secondary text h2. Bootstrap heading Secondary text h3. Bootstrap heading Secondary text h4. Bootstrap heading Secondary text h5. Bootstrap heading Secondary text h6. Bootstrap heading Secondary text 123456&lt;h1&gt;h1. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h1&gt;&lt;h2&gt;h2. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h2&gt;&lt;h3&gt;h3. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h3&gt;&lt;h4&gt;h4. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h4&gt;&lt;h5&gt;h5. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h5&gt;&lt;h6&gt;h6. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h6&gt; 页面主体Bootstrap 将全局 font-size 设置为 14px，line-height 设置为 1.428。这些属性直接赋予 &lt;body&gt; 元素和所有段落元素。另外，&lt;p&gt; （段落）元素还被设置了等于 1/2 行高（即 10px）的底部外边距（margin）。 Nullam quis risus eget urna mollis ornare vel eu leo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nullam id dolor id nibh ultricies vehicula. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec ullamcorper nulla non metus auctor fringilla. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Donec ullamcorper nulla non metus auctor fringilla. Maecenas sed diam eget risus varius blandit sit amet non magna. Donec id elit non mi porta gravida at eget metus. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. 1&lt;p&gt;...&lt;/p&gt; 中心内容通过添加 .lead 类可以让段落突出显示。 Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus. 1&lt;p class=&quot;lead&quot;&gt;...&lt;/p&gt; 使用 Less 工具构建variables.less 文件中定义的两个 Less 变量决定了排版尺寸：@font-size-base 和 @line-height-base。第一个变量定义了全局 font-size 基准，第二个变量是 line-height 基准。我们使用这些变量和一些简单的公式计算出其它所有页面元素的 margin、 padding 和 line-height。自定义这些变量即可改变 Bootstrap 的默认样式。 内联文本元素Marked textFor highlighting a run of text due to its relevance in another context, use the &lt;mark&gt; tag. You can use the mark tag to highlight text. 1You can use the mark tag to &lt;mark&gt;highlight&lt;/mark&gt; text. 被删除的文本对于被删除的文本使用 &lt;del&gt; 标签。 This line of text is meant to be treated as deleted text. 1&lt;del&gt;This line of text is meant to be treated as deleted text.&lt;/del&gt; 无用文本对于没用的文本使用 &lt;s&gt; 标签。 This line of text is meant to be treated as no longer accurate. 1&lt;s&gt;This line of text is meant to be treated as no longer accurate.&lt;/s&gt; 插入文本额外插入的文本使用 &lt;ins&gt; 标签。 This line of text is meant to be treated as an addition to the document. 1&lt;ins&gt;This line of text is meant to be treated as an addition to the document.&lt;/ins&gt; 带下划线的文本为文本添加下划线，使用 &lt;u&gt; 标签。 This line of text will render as underlined 1&lt;u&gt;This line of text will render as underlined&lt;/u&gt; 利用 HTML 自带的表示强调意味的标签来为文本增添少量样式。 小号文本对于不需要强调的inline或block类型的文本，使用 &lt;small&gt; 标签包裹，其内的文本将被设置为父容器字体大小的 85%。标题元素中嵌套的 &lt;small&gt; 元素被设置不同的 font-size 。 你还可以为行内元素赋予 .small 类以代替任何 &lt;small&gt; 元素。 This line of text is meant to be treated as fine print. 1&lt;small&gt;This line of text is meant to be treated as fine print.&lt;/small&gt; 着重通过增加 font-weight 值强调一段文本。 The following snippet of text is rendered as bold text. 1&lt;strong&gt;rendered as bold text&lt;/strong&gt; 斜体用斜体强调一段文本。 The following snippet of text is rendered as italicized text. 1&lt;em&gt;rendered as italicized text&lt;/em&gt; Alternate elements在 HTML5 中可以放心使用 &lt;b&gt; 和 &lt;i&gt; 标签。&lt;b&gt; 用于高亮单词或短语，不带有任何着重的意味；而 &lt;i&gt; 标签主要用于发言、技术词汇等。 对齐通过文本对齐类，可以简单方便的将文字重新对齐。 Left aligned text. Center aligned text. Right aligned text. Justified text. No wrap text. 12345&lt;p class=&quot;text-left&quot;&gt;Left aligned text.&lt;/p&gt;&lt;p class=&quot;text-center&quot;&gt;Center aligned text.&lt;/p&gt;&lt;p class=&quot;text-right&quot;&gt;Right aligned text.&lt;/p&gt;&lt;p class=&quot;text-justify&quot;&gt;Justified text.&lt;/p&gt;&lt;p class=&quot;text-nowrap&quot;&gt;No wrap text.&lt;/p&gt; 改变大小写通过这几个类可以改变文本的大小写。 lowercased text. UPPERCASED TEXT. Capitalized Text. 123&lt;p class=&quot;text-lowercase&quot;&gt;Lowercased text.&lt;/p&gt;&lt;p class=&quot;text-uppercase&quot;&gt;Uppercased text.&lt;/p&gt;&lt;p class=&quot;text-capitalize&quot;&gt;Capitalized text.&lt;/p&gt; 缩略语当鼠标悬停在缩写和缩写词上时就会显示完整内容，Bootstrap 实现了对 HTML 的 &lt;abbr&gt; 元素的增强样式。缩略语元素带有 title 属性，外观表现为带有较浅的虚线框，鼠标移至上面时会变成带有“问号”的指针。如想看完整的内容可把鼠标悬停在缩略语上（对使用辅助技术的用户也可见）, 但需要包含 title 属性。 基本缩略语An abbreviation of the word attribute is attr. 1&lt;abbr title=&quot;attribute&quot;&gt;attr&lt;/abbr&gt; 首字母缩略语为缩略语添加 .initialism 类，可以让 font-size 变得稍微小些。 HTML is the best thing since sliced bread. 1&lt;abbr title=&quot;HyperText Markup Language&quot; class=&quot;initialism&quot;&gt;HTML&lt;/abbr&gt; 地址让联系信息以最接近日常使用的格式呈现。在每行结尾添加 &lt;br&gt; 可以保留需要的样式。 Twitter, Inc.1355 Market Street, Suite 900San Francisco, CA 94103P: (123) 456-7890Full Namefirst.last@example.com 1234567891011&lt;address&gt; &lt;strong&gt;Twitter, Inc.&lt;/strong&gt;&lt;br&gt; 1355 Market Street, Suite 900&lt;br&gt; San Francisco, CA 94103&lt;br&gt; &lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt; (123) 456-7890&lt;/address&gt;&lt;address&gt; &lt;strong&gt;Full Name&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;mailto:#&quot;&gt;first.last@example.com&lt;/a&gt;&lt;/address&gt; 引用在你的文档中引用其他来源的内容。 默认样式的引用将任何 HTML 元素包裹在 &lt;blockquote&gt; 中即可表现为引用样式。对于直接引用，我们建议用 &lt;p&gt; 标签。 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. 123&lt;blockquote&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt;&lt;/blockquote&gt; 多种引用样式对于标准样式的 &lt;blockquote&gt;，可以通过几个简单的变体就能改变风格和内容。 命名来源添加 &lt;footer&gt; 用于标明引用来源。来源的名称可以包裹进 &lt;cite&gt;标签中。 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Someone famous in Source Title 1234&lt;blockquote&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer&gt;Someone famous in &lt;cite title=&quot;Source Title&quot;&gt;Source Title&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt; 另一种展示风格通过赋予 .blockquote-reverse 类可以让引用呈现内容右对齐的效果。 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Someone famous in Source Title 123&lt;blockquote class=&quot;blockquote-reverse&quot;&gt; ...&lt;/blockquote&gt; 列表无序列表排列顺序无关紧要的一列元素。 Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 123&lt;ul&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt; 有序列表顺序至关重要的一组元素。 Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 123&lt;ol&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ol&gt; 无样式列表移除了默认的 list-style 样式和左侧外边距的一组元素（只针对直接子元素）。这是针对直接子元素的，也就是说，你需要对所有嵌套的列表都添加这个类才能具有同样的样式。 Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 123&lt;ul class=&quot;list-unstyled&quot;&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt; 内联列表通过设置 display: inline-block; 并添加少量的内补（padding），将所有元素放置于同一行。 Lorem ipsum Phasellus iaculis Nulla volutpat 123&lt;ul class=&quot;list-inline&quot;&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt; 描述带有描述的短语列表。 Description lists A description list is perfect for defining terms. Euismod Vestibulum id ligula porta felis euismod semper eget lacinia odio sem nec elit. Donec id elit non mi porta gravida at eget metus. Malesuada porta Etiam porta sem malesuada magna mollis euismod. 1234&lt;dl&gt; &lt;dt&gt;...&lt;/dt&gt; &lt;dd&gt;...&lt;/dd&gt;&lt;/dl&gt; 水平排列的描述.dl-horizontal 可以让 &lt;dl&gt; 内的短语及其描述排在一行。开始是像 &lt;dl&gt; 的默认样式堆叠在一起，随着导航条逐渐展开而排列在一行。 Description lists A description list is perfect for defining terms. Euismod Vestibulum id ligula porta felis euismod semper eget lacinia odio sem nec elit. Donec id elit non mi porta gravida at eget metus. Malesuada porta Etiam porta sem malesuada magna mollis euismod. Felis euismod semper eget lacinia Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus. 1234&lt;dl class=&quot;dl-horizontal&quot;&gt; &lt;dt&gt;...&lt;/dt&gt; &lt;dd&gt;...&lt;/dd&gt;&lt;/dl&gt; 自动截断通过 text-overflow 属性，水平排列的描述列表将会截断左侧太长的短语。在较窄的视口（viewport）内，列表将变为默认堆叠排列的布局方式。 代码内联代码通过 &lt;code&gt; 标签包裹内联样式的代码片段。 For example, &lt;section&gt; should be wrapped as inline. 1For example, &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; should be wrapped as inline. 用户输入通过 &lt;kbd&gt; 标签标记用户通过键盘输入的内容。 To switch directories, type cd followed by the name of the directory.To edit settings, press ctrl + , 12To switch directories, type &lt;kbd&gt;cd&lt;/kbd&gt; followed by the name of the directory.&lt;br&gt;To edit settings, press &lt;kbd&gt;&lt;kbd&gt;ctrl&lt;/kbd&gt; + &lt;kbd&gt;,&lt;/kbd&gt;&lt;/kbd&gt; 代码块多行代码可以使用 &lt;pre&gt; 标签。为了正确的展示代码，注意将尖括号做转义处理。 1&lt;p&gt;Sample text here...&lt;/p&gt; 1&lt;pre&gt;&amp;lt;p&amp;gt;Sample text here...&amp;lt;/p&amp;gt;&lt;/pre&gt; 还可以使用 .pre-scrollable 类，其作用是设置 max-height 为 350px ，并在垂直方向展示滚动条。 变量通过 &lt;var&gt; 标签标记变量。 y = mx + b 1&lt;var&gt;y&lt;/var&gt; = &lt;var&gt;m&lt;/var&gt;&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;b&lt;/var&gt; 程序输出通过 &lt;samp&gt; 标签来标记程序输出的内容。 This text is meant to be treated as sample output from a computer program. 1&lt;samp&gt;This text is meant to be treated as sample output from a computer program.&lt;/samp&gt; 表格基本实例为任意 &lt;table&gt; 标签添加 .table 类可以为其赋予基本的样式 — 少量的内补（padding）和水平方向的分隔线。这种方式看起来很多余！？但是我们觉得，表格元素使用的很广泛，如果我们为其赋予默认样式可能会影响例如日历和日期选择之类的插件，所以我们选择将此样式独立出来。 # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123&lt;table class=&quot;table&quot;&gt; ...&lt;/table&gt; 条纹状表格通过 .table-striped 类可以给 &lt;tbody&gt; 之内的每一行增加斑马条纹样式。 跨浏览器兼容性条纹状表格是依赖 :nth-child CSS 选择器实现的，而这一功能不被 Internet Explorer 8 支持。 # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123&lt;table class=&quot;table table-striped&quot;&gt; ...&lt;/table&gt; 带边框的表格添加 .table-bordered 类为表格和其中的每个单元格增加边框。 # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123&lt;table class=&quot;table table-bordered&quot;&gt; ...&lt;/table&gt; 鼠标悬停通过添加 .table-hover 类可以让 &lt;tbody&gt; 中的每一行对鼠标悬停状态作出响应。 # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123&lt;table class=&quot;table table-hover&quot;&gt; ...&lt;/table&gt; 紧缩表格通过添加 .table-condensed 类可以让表格更加紧凑，单元格中的内补（padding）均会减半。 # First Name Last Name Username 1 Mark Otto @mdo 2 Jacob Thornton @fat 3 Larry the Bird @twitter 123&lt;table class=&quot;table table-condensed&quot;&gt; ...&lt;/table&gt; 状态类通过这些状态类可以为行或单元格设置颜色。 Class 描述 .active 鼠标悬停在行或单元格上时所设置的颜色 .success 标识成功或积极的动作 .info 标识普通的提示信息或动作 .warning 标识警告或需要用户注意 .danger 标识危险或潜在的带来负面影响的动作 # Column heading Column heading Column heading 1 Column content Column content Column content 2 Column content Column content Column content 3 Column content Column content Column content 4 Column content Column content Column content 5 Column content Column content Column content 6 Column content Column content Column content 7 Column content Column content Column content 8 Column content Column content Column content 9 Column content Column content Column content 123456789101112131415&lt;!-- On rows --&gt;&lt;tr class=&quot;active&quot;&gt;...&lt;/tr&gt;&lt;tr class=&quot;success&quot;&gt;...&lt;/tr&gt;&lt;tr class=&quot;warning&quot;&gt;...&lt;/tr&gt;&lt;tr class=&quot;danger&quot;&gt;...&lt;/tr&gt;&lt;tr class=&quot;info&quot;&gt;...&lt;/tr&gt;&lt;!-- On cells (`td` or `th`) --&gt;&lt;tr&gt; &lt;td class=&quot;active&quot;&gt;...&lt;/td&gt; &lt;td class=&quot;success&quot;&gt;...&lt;/td&gt; &lt;td class=&quot;warning&quot;&gt;...&lt;/td&gt; &lt;td class=&quot;danger&quot;&gt;...&lt;/td&gt; &lt;td class=&quot;info&quot;&gt;...&lt;/td&gt;&lt;/tr&gt; 向使用辅助技术的用户传达用意通过为表格中的一行或一个单元格添加颜色而赋予不同的意义只是提供了一种视觉上的表现，并不能为使用辅助技术 – 例如屏幕阅读器 – 浏览网页的用户提供更多信息。因此，请确保通过颜色而赋予的不同意义可以通过内容本身来表达（即在相应行或单元格中的可见的文本内容）；或者通过包含额外的方式 – 例如应用了 .sr-only 类而隐藏的文本 – 来表达出来。 响应式表格将任何 .table 元素包裹在 .table-responsive 元素内，即可创建响应式表格，其会在小屏幕设备上（小于768px）水平滚动。当屏幕大于 768px 宽度时，水平滚动条消失。 垂直方向的内容截断响应式表格使用了 overflow-y: hidden 属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件。 Firefox 和 fieldset 元素Firefox 浏览器对 fieldset 元素设置了一些影响 width 属性的样式，导致响应式表格出现问题。可以使用下面提供的针对 Firefox 的 hack 代码解决，但是以下代码并未集成在 Bootstrap 中： 123@-moz-document url-prefix() &#123; fieldset &#123; display: table-cell; &#125;&#125; 更多信息请参考 this Stack Overflow answer. # Table heading Table heading Table heading Table heading Table heading Table heading 1 Table cell Table cell Table cell Table cell Table cell Table cell 2 Table cell Table cell Table cell Table cell Table cell Table cell 3 Table cell Table cell Table cell Table cell Table cell Table cell # Table heading Table heading Table heading Table heading Table heading Table heading 1 Table cell Table cell Table cell Table cell Table cell Table cell 2 Table cell Table cell Table cell Table cell Table cell Table cell 3 Table cell Table cell Table cell Table cell Table cell Table cell 12345&lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table&quot;&gt; ... &lt;/table&gt;&lt;/div&gt; 表单基本实例单独的表单控件会被自动赋予一些全局样式。所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;。 将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。 Email addressPasswordFile inputExample block-level help text here.Check me outSubmit 123456789101112131415161718192021&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;File input&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;exampleInputFile&quot;&gt; &lt;p class=&quot;help-block&quot;&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 不要将表单组和输入框组混合使用不要将表单组直接和输入框组混合使用。建议将输入框组嵌套到表单组中使用。 内联表单为 &lt;form&gt; 元素添加 .form-inline 类可使其内容左对齐并且表现为 inline-block 级别的控件。只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）。 可能需要手动设置宽度在 Bootstrap 中，输入框和单选/多选框控件默认被设置为 width: 100%; 宽度。在内联表单，我们将这些元素的宽度设置为 width: auto;，因此，多个控件可以排列在同一行。根据你的布局需求，可能需要一些额外的定制化组件。 一定要添加 label 标签如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 label 设置 .sr-only 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 aria-label、aria-labelledby 或 title 属性。如果这些都不存在，屏幕阅读器可能会采取使用 placeholder 属性，如果存在的话，使用占位符来替代其他的标记，但要注意，这种方法是不妥当的。 Name Email Send invitation 1234567891011&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; placeholder=&quot;Jane Doe&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; placeholder=&quot;jane.doe@example.com&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Send invitation&lt;/button&gt;&lt;/form&gt; Email address Password Remember me Sign in 12345678910111213141516&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputEmail3&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputPassword3&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt;&lt;/form&gt; Amount (in dollars)$.00 Transfer cash 1234567891011&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;Amount (in dollars)&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;$&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;exampleInputAmount&quot; placeholder=&quot;Amount&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Transfer cash&lt;/button&gt;&lt;/form&gt; 水平排列的表单通过为表单添加 .form-horizontal 类，并联合使用 Bootstrap 预置的栅格类，可以将 label 标签和控件组水平并排布局。这样做将改变 .form-group 的行为，使其表现为栅格系统中的行（row），因此就无需再额外添加 .row 了。 EmailPasswordRemember meSign in 12345678910111213141516171819202122232425262728&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 被支持的控件表单布局实例中展示了其所支持的标准表单控件。 输入框包括大部分表单控件、文本输入域控件，还支持所有 HTML5 类型的输入控件： text、password、datetime、datetime-local、date、month、time、week、number、email、url、search、tel 和 color。 必须添加类型声明只有正确设置了 type 属性的输入控件才能被赋予正确的样式。 1&lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Text input&quot;&gt; 输入控件组如需在文本输入域 &lt;input&gt; 前面或后面添加文本内容或按钮控件，请参考输入控件组。 文本域支持多行文本的表单控件。可根据需要改变 rows 属性。 1&lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; 多选和单选框多选框（checkbox）用于选择列表中的一个或多个选项，而单选框（radio）用于从多个选项中只选择一个。 Disabled checkboxes and radios are supported, but to provide a “not-allowed” cursor on hover of the parent &lt;label&gt;, you’ll need to add the .disabled class to the parent .radio, .radio-inline, .checkbox, or .checkbox-inline. 默认外观（堆叠在一起）Option one is this and that—be sure to include why it’s greatOption two is disabledOption one is this and that—be sure to include why it’s greatOption two can be something else and selecting it will deselect option oneOption three is disabled 12345678910111213141516171819202122232425262728293031&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;&quot;&gt; Option one is this and that&amp;mdash;be sure to include why it&apos;s great &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;checkbox disabled&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;&quot; disabled&gt; Option two is disabled &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;optionsRadios&quot; id=&quot;optionsRadios1&quot; value=&quot;option1&quot; checked&gt; Option one is this and that&amp;mdash;be sure to include why it&apos;s great &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;optionsRadios&quot; id=&quot;optionsRadios2&quot; value=&quot;option2&quot;&gt; Option two can be something else and selecting it will deselect option one &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio disabled&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;optionsRadios&quot; id=&quot;optionsRadios3&quot; value=&quot;option3&quot; disabled&gt; Option three is disabled &lt;/label&gt;&lt;/div&gt; 内联单选和多选框通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。 1 2 31 2 3 12345678910111213141516171819&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt; 不带label文本的Checkbox 和 radio如果需要 &lt;label&gt; 内没有文字，输入框（input）正是你所期望的。 目前只适用于非内联的 checkbox 和 radio。 请记住，仍然需要为使用辅助技术的用户提供某种形式的 label（例如，使用 aria-label）。 12345678910&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;blankCheckbox&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;blankRadio&quot; id=&quot;blankRadio1&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt; 下拉列表（select）注意，很多原生选择菜单 - 即在 Safari 和 Chrome 中 - 的圆角是无法通过修改 border-radius 属性来改变的。 ​ 1 2 3 4 5 1234567&lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 对于标记了 multiple 属性的 &lt;select&gt; 控件来说，默认显示多选项。 ​ 1 2 3 4 5 1234567&lt;select multiple class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 静态控件如果需要在表单中将一行纯文本和 label 元素放置于同一行，为 &lt;p&gt; 元素添加 .form-control-static 类即可。 Emailemail@example.comPassword 1234567891011121314&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;p class=&quot;form-control-static&quot;&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; Emailemail@example.com Password Confirm identity 1234567891011&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot;&gt;Email&lt;/label&gt; &lt;p class=&quot;form-control-static&quot;&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword2&quot; class=&quot;sr-only&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword2&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Confirm identity&lt;/button&gt;&lt;/form&gt; 焦点状态我们将某些表单控件的默认 outline 样式移除，然后对 :focus 状态赋予 box-shadow 属性。 演示:focus 状态在本文档中，我们为上面实例中的输入框赋予了自定义的样式，用于演示 .form-control 元素的 :focus 状态。 禁用状态为输入框设置 disabled 属性可以禁止其与用户有任何交互（焦点、输入等）。被禁用的输入框颜色更浅，并且还添加了 not-allowed鼠标状态。 1&lt;input class=&quot;form-control&quot; id=&quot;disabledInput&quot; type=&quot;text&quot; placeholder=&quot;Disabled input here...&quot; disabled&gt; 被禁用的 fieldset为&lt;fieldset&gt; 设置 disabled 属性,可以禁用 &lt;fieldset&gt; 中包含的所有控件。 &lt;a&gt; 标签的链接功能不受影响默认情况下，浏览器会将 &lt;fieldset disabled&gt; 内所有的原生的表单控件（&lt;input&gt;、&lt;select&gt; 和 &lt;button&gt; 元素）设置为禁用状态，防止键盘和鼠标与他们交互。然而，如果表单中还包含 &lt;a ... class=&quot;btn btn-*&quot;&gt; 元素，这些元素将只被赋予 pointer-events: none 属性。正如在关于 禁用状态的按钮 章节中（尤其是关于锚点元素的子章节中）所描述的那样，该 CSS 属性尚不规范，并且在 Opera 18 及更低版本的浏览器或 Internet Explorer 11 总没有得到全面支持，并且不会阻止键盘用户能够获取焦点或激活这些链接。所以为了安全起见，建议使用自定义 JavaScript 来禁用这些链接。 跨浏览器兼容性虽然 Bootstrap 会将这些样式应用到所有浏览器上，Internet Explorer 11 及以下浏览器中的 &lt;fieldset&gt; 元素并不完全支持 disabled 属性。因此建议在这些浏览器上通过 JavaScript 代码来禁用 &lt;fieldset&gt;。 Disabled inputDisabled select menu Disabled select Can’t check thisSubmit 1234567891011121314151617181920&lt;form&gt; &lt;fieldset disabled&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledTextInput&quot;&gt;Disabled input&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;disabledTextInput&quot; class=&quot;form-control&quot; placeholder=&quot;Disabled input&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledSelect&quot;&gt;Disabled select menu&lt;/label&gt; &lt;select id=&quot;disabledSelect&quot; class=&quot;form-control&quot;&gt; &lt;option&gt;Disabled select&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Can&apos;t check this &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt; 只读状态为输入框设置 readonly 属性可以禁止用户修改输入框中的内容。处于只读状态的输入框颜色更浅（就像被禁用的输入框一样），但是仍然保留标准的鼠标状态。 1&lt;input class=&quot;form-control&quot; type=&quot;text&quot; placeholder=&quot;Readonly input here…&quot; readonly&gt; Help textBlock level help text for form controls. Associating help text with form controlsHelp text should be explicitly associated with the form control it relates to using the aria-describedby attribute. This will ensure that assistive technologies – such as screen readers – will announce this help text when the user focuses or enters the control. Input with help textA block of help text that breaks onto a new line and may extend beyond one line. 1234&lt;label class=&quot;sr-only&quot; for=&quot;inputHelpBlock&quot;&gt;Input with help text&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;inputHelpBlock&quot; class=&quot;form-control&quot; aria-describedby=&quot;helpBlock&quot;&gt;...&lt;span id=&quot;helpBlock&quot; class=&quot;help-block&quot;&gt;A block of help text that breaks onto a new line and may extend beyond one line.&lt;/span&gt; 校验状态Bootstrap 对表单控件的校验状态，如 error、warning 和 success 状态，都定义了样式。使用时，添加 .has-warning、.has-error或 .has-success 类到这些控件的父元素即可。任何包含在此元素之内的 .control-label、.form-control 和 .help-block 元素都将接受这些校验状态的样式。 将验证状态传达给辅助设备和盲人用户使用这些校验样式只是为表单控件提供一个可视的、基于色彩的提示，但是并不能将这种提示信息传达给使用辅助设备的用户 - 例如屏幕阅读器 - 或者色盲用户。 为了确保所有用户都能获取正确信息，Bootstrap 还提供了另一种提示方式。例如，你可以在表单控件的 &lt;label&gt; 标签上以文本的形式显示提示信息（就像下面代码中所展示的）；包含一个 Glyphicon 字体图标 （还有赋予 .sr-only 类的文本信息 - 参考Glyphicon 字体图标实例）；或者提供一个额外的 辅助信息 块。另外，对于使用辅助设备的用户，无效的表单控件还可以赋予一个 aria-invalid=&quot;true&quot; 属性。 Input with successA block of help text that breaks onto a new line and may extend beyond one line.Input with warningInput with errorCheckbox with successCheckbox with warningCheckbox with error 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=&quot;form-group has-success&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputSuccess1&quot;&gt;Input with success&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputSuccess1&quot; aria-describedby=&quot;helpBlock2&quot;&gt; &lt;span id=&quot;helpBlock2&quot; class=&quot;help-block&quot;&gt;A block of help text that breaks onto a new line and may extend beyond one line.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;form-group has-warning&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputWarning1&quot;&gt;Input with warning&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputWarning1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;form-group has-error&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputError1&quot;&gt;Input with error&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputError1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;has-success&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkboxSuccess&quot; value=&quot;option1&quot;&gt; Checkbox with success &lt;/label&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;has-warning&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkboxWarning&quot; value=&quot;option1&quot;&gt; Checkbox with warning &lt;/label&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;has-error&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkboxError&quot; value=&quot;option1&quot;&gt; Checkbox with error &lt;/label&gt; &lt;/div&gt;&lt;/div&gt; 添加额外的图标你还可以针对校验状态为输入框添加额外的图标。只需设置相应的 .has-feedback 类并添加正确的图标即可。 反馈图标（feedback icon）只能使用在文本输入框 元素上。 图标、label 和输入控件组对于不带有 label 标签的输入框以及右侧带有附加组件的输入框组，需要手动为其图标定位。为了让所有用户都能访问你的网站，我们强烈建议为所有输入框添加 label 标签。如果你不希望将 label 标签展示出来，可以通过添加 .sr-only 类来实现。如果的确不能添加 label 标签，请调整图标的 top 值。对于输入框组，请根据你的实际情况调整 right 值。 向辅助技术设备传递图标的含义为了确保辅助技术- 如屏幕阅读器 - 正确传达一个图标的含义，额外的隐藏的文本应包含在 .sr-only 类中，并明确关联使用了 aria-describedby 的表单控件。或者，以某些其他形式（例如，文本输入字段有一个特定的警告信息）传达含义，例如改变与表单控件实际相关联的 &lt;label&gt; 的文本。 虽然下面的例子已经提到各自表单控件本身的 &lt;label&gt; 文本的验证状态，上述技术（使用 .sr-only 文本 和 aria-describedby) ）已经包括了需要说明的目的。 Input with success(success)Input with warning(warning)Input with error(error)Input group with success@(success) 123456789101112131415161718192021222324252627&lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputSuccess2&quot;&gt;Input with success&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputSuccess2&quot; aria-describedby=&quot;inputSuccess2Status&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputSuccess2Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;form-group has-warning has-feedback&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputWarning2&quot;&gt;Input with warning&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputWarning2&quot; aria-describedby=&quot;inputWarning2Status&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-warning-sign form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputWarning2Status&quot; class=&quot;sr-only&quot;&gt;(warning)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;form-group has-error has-feedback&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputError2&quot;&gt;Input with error&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputError2&quot; aria-describedby=&quot;inputError2Status&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-remove form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputError2Status&quot; class=&quot;sr-only&quot;&gt;(error)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputGroupSuccess1&quot;&gt;Input group with success&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputGroupSuccess1&quot; aria-describedby=&quot;inputGroupSuccess1Status&quot;&gt; &lt;/div&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputGroupSuccess1Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt;&lt;/div&gt; 为水平排列的表单和内联表单设置可选的图标Input with success(success)Input group with success@(success) 123456789101112131415161718192021&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label col-sm-3&quot; for=&quot;inputSuccess3&quot;&gt;Input with success&lt;/label&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputSuccess3&quot; aria-describedby=&quot;inputSuccess3Status&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputSuccess3Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label col-sm-3&quot; for=&quot;inputGroupSuccess2&quot;&gt;Input group with success&lt;/label&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputGroupSuccess2&quot; aria-describedby=&quot;inputGroupSuccess2Status&quot;&gt; &lt;/div&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputGroupSuccess2Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; Input with success (success)Input group with success @(success) 12345678910111213141516171819&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputSuccess4&quot;&gt;Input with success&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputSuccess4&quot; aria-describedby=&quot;inputSuccess4Status&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputSuccess4Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt; &lt;/div&gt;&lt;/form&gt;&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;inputGroupSuccess3&quot;&gt;Input group with success&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputGroupSuccess3&quot; aria-describedby=&quot;inputGroupSuccess3Status&quot;&gt; &lt;/div&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputGroupSuccess3Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 可选的图标与设置 .sr-only 类的 label如果你使用 .sr-only 类来隐藏表单控件的 &lt;label&gt; （而不是使用其它标签选项，如 aria-label 属性）， 一旦它被添加，Bootstrap 会自动调整图标的位置。 Hidden label(success) Input group with success @ (success) 123456789101112131415&lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label sr-only&quot; for=&quot;inputSuccess5&quot;&gt;Hidden label&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputSuccess5&quot; aria-describedby=&quot;inputSuccess5Status&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputSuccess5Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;form-group has-success has-feedback&quot;&gt; &lt;label class=&quot;control-label sr-only&quot; for=&quot;inputGroupSuccess4&quot;&gt;Input group with success&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputGroupSuccess4&quot; aria-describedby=&quot;inputGroupSuccess4Status&quot;&gt; &lt;/div&gt; &lt;span class=&quot;glyphicon glyphicon-ok form-control-feedback&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span id=&quot;inputGroupSuccess4Status&quot; class=&quot;sr-only&quot;&gt;(success)&lt;/span&gt;&lt;/div&gt; 控件尺寸通过 .input-lg 类似的类可以为控件设置高度，通过 .col-lg-* 类似的类可以为控件设置宽度。 高度尺寸创建大一些或小一些的表单控件以匹配按钮尺寸。 ​ .input-lg Default select .input-sm 1234567&lt;input class=&quot;form-control input-lg&quot; type=&quot;text&quot; placeholder=&quot;.input-lg&quot;&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot; placeholder=&quot;Default input&quot;&gt;&lt;input class=&quot;form-control input-sm&quot; type=&quot;text&quot; placeholder=&quot;.input-sm&quot;&gt;&lt;select class=&quot;form-control input-lg&quot;&gt;...&lt;/select&gt;&lt;select class=&quot;form-control&quot;&gt;...&lt;/select&gt;&lt;select class=&quot;form-control input-sm&quot;&gt;...&lt;/select&gt; 水平排列的表单组的尺寸通过添加 .form-group-lg 或 .form-group-sm 类，为 .form-horizontal 包裹的 label 元素和表单控件快速设置尺寸。 Large labelSmall label 1234567891011121314&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group form-group-lg&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot; for=&quot;formGroupInputLarge&quot;&gt;Large label&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; id=&quot;formGroupInputLarge&quot; placeholder=&quot;Large input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-group-sm&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot; for=&quot;formGroupInputSmall&quot;&gt;Small label&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; id=&quot;formGroupInputSmall&quot; placeholder=&quot;Small input&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 调整列（column）尺寸用栅格系统中的列（column）包裹输入框或其任何父元素，都可很容易的为其设置宽度。 1234567891011&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-2&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;.col-xs-2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-3&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;.col-xs-3&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-4&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;.col-xs-4&quot;&gt; &lt;/div&gt;&lt;/div&gt; 按钮可作为按钮使用的标签或元素为 &lt;a&gt;、&lt;button&gt; 或 &lt;input&gt; 元素添加按钮类（button class）即可使用 Bootstrap 提供的样式。 Link Button 1234&lt;a class=&quot;btn btn-default&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;Link&lt;/a&gt;&lt;button class=&quot;btn btn-default&quot; type=&quot;submit&quot;&gt;Button&lt;/button&gt;&lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; value=&quot;Input&quot;&gt;&lt;input class=&quot;btn btn-default&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt; 针对组件的注意事项虽然按钮类可以应用到 &lt;a&gt; 和 &lt;button&gt; 元素上，但是，导航和导航条组件只支持 &lt;button&gt; 元素。 链接被作为按钮使用时的注意事项如果 &lt;a&gt; 元素被作为按钮使用 – 并用于在当前页面触发某些功能 – 而不是用于链接其他页面或链接当前页面中的其他部分，那么，务必为其设置 role=&quot;button&quot; 属性。 跨浏览器展现我们总结的最佳实践是：强烈建议尽可能使用 元素来获得在各个浏览器上获得相匹配的绘制效果。 另外，我们还发现了 Firefox &lt;30 版本的浏览器上出现的一个 bug，其表现是：阻止我们为基于 &lt;input&gt; 元素所创建的按钮设置 line-height 属性，这就导致在 Firefox 浏览器上不能完全和其他按钮保持一致的高度。 预定义样式使用下面列出的类可以快速创建一个带有预定义样式的按钮。 （默认样式）Default （首选项）Primary （成功）Success （一般信息）Info （警告）Warning（危险）Danger （链接）Link 1234567891011121314151617181920&lt;!-- Standard button --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;（默认样式）Default&lt;/button&gt;&lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（首选项）Primary&lt;/button&gt;&lt;!-- Indicates a successful or positive action --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;（成功）Success&lt;/button&gt;&lt;!-- Contextual button for informational alert messages --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;（一般信息）Info&lt;/button&gt;&lt;!-- Indicates caution should be taken with this action --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;（警告）Warning&lt;/button&gt;&lt;!-- Indicates a dangerous or potentially negative action --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;（危险）Danger&lt;/button&gt;&lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;（链接）Link&lt;/button&gt; Conveying meaning to assistive technologies为按钮添加不同的颜色只是一种视觉上的信息表达方式，但是，对于使用辅助技术 – 例如屏幕阅读器 – 的用户来说，颜色是不可见的。建议，确保通过颜色表达的信息或者通过内容自身表达出来（按钮上的文字），或者通过其他方式 – 例如通过 .sr-only类隐藏的额外文本 – 表达出来。 尺寸需要让按钮具有不同尺寸吗？使用 .btn-lg、.btn-sm 或 .btn-xs 就可以获得不同尺寸的按钮。 （大按钮）Large button （大按钮）Large button （默认尺寸）Default button （默认尺寸）Default button （小按钮）Small button （小按钮）Small button （超小尺寸）Extra small button （超小尺寸）Extra small button 12345678910111213141516&lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;（大按钮）Large button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg&quot;&gt;（大按钮）Large button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（默认尺寸）Default button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;（默认尺寸）Default button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;（小按钮）Small button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-sm&quot;&gt;（小按钮）Small button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-xs&quot;&gt;（超小尺寸）Extra small button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot;&gt;（超小尺寸）Extra small button&lt;/button&gt;&lt;/p&gt; 通过给按钮添加 .btn-block 类可以将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素。 （块级元素）Block level button（块级元素）Block level button 12&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg btn-block&quot;&gt;（块级元素）Block level button&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg btn-block&quot;&gt;（块级元素）Block level button&lt;/button&gt; 激活状态当按钮处于激活状态时，其表现为被按压下去（底色更深、边框夜色更深、向内投射阴影）。对于 &lt;button&gt; 元素，是通过 :active 状态实现的。对于 &lt;a&gt; 元素，是通过 .active 类实现的。然而，你还可以将 .active 应用到 &lt;button&gt; 上（包含 aria-pressed=&quot;true&quot; 属性)），并通过编程的方式使其处于激活状态。 button 元素由于 :active 是伪状态，因此无需额外添加，但是在需要让其表现出同样外观的时候可以添加 .active 类。 Primary button Button 12&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg active&quot;&gt;Primary button&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg active&quot;&gt;Button&lt;/button&gt; 链接（&lt;a&gt;）元素可以为基于 &lt;a&gt; 元素创建的按钮添加 .active 类。 Primary link Link 12&lt;a href=&quot;#&quot; class=&quot;btn btn-primary btn-lg active&quot; role=&quot;button&quot;&gt;Primary link&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;btn btn-default btn-lg active&quot; role=&quot;button&quot;&gt;Link&lt;/a&gt; 禁用状态通过为按钮的背景设置 opacity 属性就可以呈现出无法点击的效果。 button 元素为 &lt;button&gt; 元素添加 disabled 属性，使其表现出禁用状态。 Primary button Button 12&lt;button type=&quot;button&quot; class=&quot;btn btn-lg btn-primary&quot; disabled=&quot;disabled&quot;&gt;Primary button&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg&quot; disabled=&quot;disabled&quot;&gt;Button&lt;/button&gt; 跨浏览器兼容性如果为 &lt;button&gt; 元素添加 disabled 属性，Internet Explorer 9 及更低版本的浏览器将会把按钮中的文本绘制为灰色，并带有恶心的阴影，目前我们还没有解决办法。 链接（&lt;a&gt;）元素为基于 &lt;a&gt; 元素创建的按钮添加 .disabled 类。 Primary link Link 12&lt;a href=&quot;#&quot; class=&quot;btn btn-primary btn-lg disabled&quot; role=&quot;button&quot;&gt;Primary link&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;btn btn-default btn-lg disabled&quot; role=&quot;button&quot;&gt;Link&lt;/a&gt; 我们把 .disabled 作为工具类使用，就像 .active 类一样，因此不需要增加前缀。 链接的原始功能不受影响上面提到的类只是通过设置 pointer-events: none 来禁止 &lt;a&gt; 元素作为链接的原始功能，但是，这一 CSS 属性并没有被标准化，并且 Opera 18 及更低版本的浏览器并没有完全支持这一属性，同样，Internet Explorer 11 也不支持。In addition, even in browsers that do support pointer-events: none, keyboard navigation remains unaffected, meaning that sighted keyboard users and users of assistive technologies will still be able to activate these links. 因此，为了安全起见，建议通过 JavaScript 代码来禁止链接的原始功能。 图片响应式图片在 Bootstrap 版本 3 中，通过为图片添加 .img-responsive 类可以让图片支持响应式布局。其实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性，从而让图片在其父元素中更好的缩放。 如果需要让使用了 .img-responsive 类的图片水平居中，请使用 .center-block 类，不要用 .text-center。 请参考助手类章节 了解更多关于 .center-block 的用法。 SVG 图像和 IE 8-10在 Internet Explorer 8-10 中，设置为 .img-responsive 的 SVG 图像显示出的尺寸不匀称。为了解决这个问题，在出问题的地方添加 width: 100% \\9; 即可。Bootstrap 并没有自动为所有图像元素设置这一属性，因为这会导致其他图像格式出现错乱。 1&lt;img src=&quot;...&quot; class=&quot;img-responsive&quot; alt=&quot;Responsive image&quot;&gt; 图片形状通过为 &lt;img&gt; 元素添加以下相应的类，可以让图片呈现不同的形状。 跨浏览器兼容性请时刻牢记：Internet Explorer 8 不支持 CSS3 中的圆角属性。 140x140](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgdmlld0JveD0iMCAwIDE0MCAxNDAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzE0MHgxNDAKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJjYWRkZSB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmNhZGRlIj48cmVjdCB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgZmlsbD0iI0VFRUVFRSIvPjxnPjx0ZXh0IHg9IjQ0LjA1NDY4NzUiIHk9Ijc0LjUiPjE0MHgxNDA8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) ![140x140](../../../../../../../data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgdmlld0JveD0iMCAwIDE0MCAxNDAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjwhLS0KU291cmNlIFVSTDogaG9sZGVyLmpzLzE0MHgxNDAKQ3JlYXRlZCB3aXRoIEhvbGRlci5qcyAyLjYuMC4KTGVhcm4gbW9yZSBhdCBodHRwOi8vaG9sZGVyanMuY29tCihjKSAyMDEyLTIwMTUgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvCi0tPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PCFbQ0RBVEFbI2hvbGRlcl8xNjJiNTJjZTM5YiB0ZXh0IHsgZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQgfSBdXT48L3N0eWxlPjwvZGVmcz48ZyBpZD0iaG9sZGVyXzE2MmI1MmNlMzliIj48cmVjdCB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgZmlsbD0iI0VFRUVFRSIvPjxnPjx0ZXh0IHg9IjQ0LjA1NDY4NzUiIHk9Ijc0LjUiPjE0MHgxNDA8L3RleHQ+PC9nPjwvZz48L3N2Zz4=) ![140x140 123&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; 辅助类情境文本颜色通过颜色来展示意图，Bootstrap 提供了一组工具类。这些类可以应用于链接，并且在鼠标经过时颜色可以还可以加深，就像默认的链接一样。 Fusce dapibus, tellus ac cursus commodo, tortor mauris nibh. Nullam id dolor id nibh ultricies vehicula ut id elit. Duis mollis, est non commodo luctus, nisi erat porttitor ligula. Maecenas sed diam eget risus varius blandit sit amet non magna. Etiam porta sem malesuada magna mollis euismod. Donec ullamcorper nulla non metus auctor fringilla. 123456&lt;p class=&quot;text-muted&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;text-primary&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;text-success&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;text-info&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;text-warning&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;text-danger&quot;&gt;...&lt;/p&gt; 处理差异Sometimes emphasis classes cannot be applied due to the specificity of another selector. In most cases, a sufficient workaround is to wrap your text in a &lt;span&gt; with the class. Conveying meaning to assistive technologiesUsing color to add meaning only provides a visual indication, which will not be conveyed to users of assistive technologies – such as screen readers. Ensure that information denoted by the color is either obvious from the content itself (the contextual colors are only used to reinforce meaning that is already present in the text/markup), or is included through alternative means, such as additional text hidden with the .sr-only class. 情境背景色和情境文本颜色类一样，使用任意情境背景色类就可以设置元素的背景。链接组件在鼠标经过时颜色会加深，就像上面所讲的情境文本颜色类一样。 Nullam id dolor id nibh ultricies vehicula ut id elit. Duis mollis, est non commodo luctus, nisi erat porttitor ligula. Maecenas sed diam eget risus varius blandit sit amet non magna. Etiam porta sem malesuada magna mollis euismod. Donec ullamcorper nulla non metus auctor fringilla. 12345&lt;p class=&quot;bg-primary&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;bg-success&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;bg-info&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;bg-warning&quot;&gt;...&lt;/p&gt;&lt;p class=&quot;bg-danger&quot;&gt;...&lt;/p&gt; 处理差异Sometimes contextual background classes cannot be applied due to the specificity of another selector. In some cases, a sufficient workaround is to wrap your element’s content in a &lt;div&gt; with the class. Conveying meaning to assistive technologiesAs with contextual colors, ensure that any meaning conveyed through color is also conveyed in a format that is not purely presentational. 关闭按钮通过使用一个象征关闭的图标，可以让模态框和警告框消失。 × 1&lt;button type=&quot;button&quot; class=&quot;close&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; 三角符号通过使用三角符号可以指示某个元素具有下拉菜单的功能。注意，向上弹出式菜单中的三角符号是反方向的。 1&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; 快速浮动通过添加一个类，可以将任意元素向左或向右浮动。!important 被用来明确 CSS 样式的优先级。这些类还可以作为 mixin（参见 less 文档） 使用。 12&lt;div class=&quot;pull-left&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;pull-right&quot;&gt;...&lt;/div&gt; 123456789101112131415// Classes.pull-left &#123; float: left !important;&#125;.pull-right &#123; float: right !important;&#125;// Usage as mixins.element &#123; .pull-left();&#125;.another-element &#123; .pull-right();&#125; 不能用于导航条组件中排列导航条中的组件时可以使用这些工具类：.navbar-left 或 .navbar-right 。 参见导航条文档以获取更多信息。 让内容块居中为任意元素设置 display: block 属性并通过 margin 属性让其中的内容居中。下面列出的类还可以作为 mixin 使用。 1&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt; 1234567891011// Class.center-block &#123; display: block; margin-left: auto; margin-right: auto;&#125;// Usage as a mixin.element &#123; .center-block();&#125; 清除浮动通过为父元素添加 .clearfix 类可以很容易地清除浮动（float）。这里所使用的是 Nicolas Gallagher 创造的 micro clearfix 方式。此类还可以作为 mixin 使用。 12&lt;!-- Usage as a class --&gt;&lt;div class=&quot;clearfix&quot;&gt;...&lt;/div&gt; 12345678910111213141516// Mixin itself.clearfix() &#123; &amp;:before, &amp;:after &#123; content: &quot; &quot;; display: table; &#125; &amp;:after &#123; clear: both; &#125;&#125;// Usage as a mixin.element &#123; .clearfix();&#125; 显示或隐藏内容.show 和 .hidden 类可以强制任意元素显示或隐藏(对于屏幕阅读器也能起效)。这些类通过 !important 来避免 CSS 样式优先级问题，就像 quick floats 一样的做法。注意，这些类只对块级元素起作用，另外，还可以作为 mixin 使用。 .hide 类仍然可用，但是它不能对屏幕阅读器起作用，并且从 v3.0.1 版本开始就不建议使用了。请使用 .hidden 或 .sr-only 。 另外，.invisible 类可以被用来仅仅影响元素的可见性，也就是说，元素的 display 属性不被改变，并且这个元素仍然能够影响文档流的排布。 12&lt;div class=&quot;show&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;hidden&quot;&gt;...&lt;/div&gt; 123456789101112131415161718// Classes.show &#123; display: block !important;&#125;.hidden &#123; display: none !important;&#125;.invisible &#123; visibility: hidden;&#125;// Usage as mixins.element &#123; .show();&#125;.another-element &#123; .hidden();&#125; 屏幕阅读器和键盘导航.sr-only 类可以对屏幕阅读器以外的设备隐藏内容。.sr-only 和 .sr-only-focusable 联合使用的话可以在元素有焦点的时候再次显示出来（例如，使用键盘导航的用户）。对于遵循 可访问性的最佳实践 很有必要。这个类也可以作为 mixin 使用。 1&lt;a class=&quot;sr-only sr-only-focusable&quot; href=&quot;#content&quot;&gt;Skip to main content&lt;/a&gt; 12345// Usage as a mixin.skip-navigation &#123; .sr-only(); .sr-only-focusable();&#125; 图片替换使用 .text-hide 类或对应的 mixin 可以用来将元素的文本内容替换为一张背景图。 1&lt;h1 class=&quot;text-hide&quot;&gt;Custom heading&lt;/h1&gt; 1234// Usage as a mixin.heading &#123; .text-hide();&#125; 响应式工具为了加快对移动设备友好的页面开发工作，利用媒体查询功能并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。另外还包含了针对打印机显示或隐藏内容的工具类。 有针对性的使用这类工具类，从而避免为同一个网站创建完全不同的版本。相反，通过使用这些工具类可以在不同设备上提供不同的展现形式。 可用的类通过单独或联合使用以下列出的类，可以针对不同屏幕尺寸隐藏或显示页面内容。 超小屏幕手机 (&lt;768px) 小屏幕平板 (≥768px) 中等屏幕桌面 (≥992px) 大屏幕桌面 (≥1200px) .visible-xs-* 可见 隐藏 隐藏 隐藏 .visible-sm-* 隐藏 可见 隐藏 隐藏 .visible-md-* 隐藏 隐藏 可见 隐藏 .visible-lg-* 隐藏 隐藏 隐藏 可见 .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 从 v3.2.0 版本起，形如 .visible-*-* 的类针对每种屏幕大小都有了三种变体，每个针对 CSS 中不同的 display 属性，列表如下： 类组 CSS display .visible-*-block display: block; .visible-*-inline display: inline; .visible-*-inline-block display: inline-block; 因此，以超小屏幕（xs）为例，可用的 .visible-*-* 类是：.visible-xs-block、.visible-xs-inline 和 .visible-xs-inline-block。 .visible-xs、.visible-sm、.visible-md 和 .visible-lg 类也同时存在。但是从 v3.2.0 版本开始不再建议使用。除了 &lt;table&gt; 相关的元素的特殊情况外，它们与 .visible-*-block 大体相同。 打印类和常规的响应式类一样，使用下面的类可以针对打印机隐藏或显示某些内容。 class 浏览器 打印机 .visible-print-block`.visible-print-inline.visible-print-inline-block` 隐藏 可见 .hidden-print 可见 隐藏 .visible-print 类也是存在的，但是从 v3.2.0 版本开始不建议使用。它与 .visible-print-block 类大致相同，除了 &lt;table&gt; 相关元素的特殊情况外。 测试用例调整你的浏览器大小，或者用其他设备打开页面，都可以测试这些响应式工具类。 在…上可见带有绿色标记的元素表示其在当前浏览器视口（viewport）中是可见的。 超小屏幕 小屏幕 中等屏幕 ✔ 在大屏幕上可见 超小屏幕和小屏幕 ✔ 在中等屏幕和大屏幕上可见 超小屏幕和中等屏幕 ✔ 在小屏幕和大屏幕上可见 ✔ 在超小屏幕和大屏幕上可见 小屏幕和中等屏幕 在…上隐藏带有绿色标记的元素表示其在当前浏览器视口（viewport）中是隐藏的。 超小屏幕 小屏幕 中等屏幕 ✔ 在大屏幕上隐藏 超小屏幕与小屏幕 ✔ 在 medium 和 large 上隐藏 超小屏幕和中等屏幕 ✔ 在小屏幕和大屏幕上隐藏 ✔ 在超小屏幕和大屏幕上隐藏 小屏幕和中等屏幕 使用 LessBootstrap 的 CSS 文件是通过 Less 源码编译而来的。Less 是一门预处理语言，支持变量、mixin、函数等额外功能。对于希望使用 Less 源码而非编译而来的 CSS 文件的用户，Bootstrap 框架中包含的大量变量、mixin 将非常有价值。 针对栅格系统的变量和 mixin 包含在栅格系统章节。 编译 Bootstrap可以通过两种方式使用 Bootstrap ：使用编译后的 CSS 文件或者使用 Less 源码文件。若要编译 Less 文件，请参考“起步”章节的内容以了解如何设置开发环境并运行必须的编译指令。 变量整个 Bootstrap 项目中使用了大量的变量，这些变量被用来代表颜色、空白（内部、边距）、字体等。详细内容请参考定制工具。 颜色Bootstrap 使用了两种颜色模式：灰度颜色和语义颜色。灰度颜色用于快速获取常用的黑色色调；语义颜色包含了各种赋予语义的颜色值。 12345@gray-darker: lighten(#000, 13.5%); // #222@gray-dark: lighten(#000, 20%); // #333@gray: lighten(#000, 33.5%); // #555@gray-light: lighten(#000, 46.7%); // #777@gray-lighter: lighten(#000, 93.5%); // #eee 12345@brand-primary: darken(#428bca, 6.5%); // #337ab7@brand-success: #5cb85c;@brand-info: #5bc0de;@brand-warning: #f0ad4e;@brand-danger: #d9534f; 你在项目中可以使用这些预定义的颜色变量，或者重新为其赋予别名，使其更有语义。 12345678910// Use as-is.masthead &#123; background-color: @brand-primary;&#125;// Reassigned variables in Less@alert-message-background: @brand-info;.alert &#123; background-color: @alert-message-background;&#125; Scaffolding某几个变量是改变网站外观的关键要素。 123// Scaffolding@body-bg: #fff;@text-color: @black-50; 链接仅仅通过改变一个变量，可以很容易地为链接赋予正确的颜色。 1234567891011121314// Variables@link-color: @brand-primary;@link-hover-color: darken(@link-color, 15%);// Usagea &#123; color: @link-color; text-decoration: none; &amp;:hover &#123; color: @link-hover-color; text-decoration: underline; &#125;&#125; 注意：@link-hover-color 使用了 Less 提供的一个内置函数，用于自动为鼠标悬停设置合适的颜色。你还可以使用 darken、lighten、saturate 和 desaturate 等 Less 内置的函数。 排版通过几个变量就能轻松的设置字体、字号、行距等。Bootstrap 利用这些变量提供了简单地定制排版的功能。 1234567891011121314151617181920212223@font-family-sans-serif: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;@font-family-serif: Georgia, &quot;Times New Roman&quot;, Times, serif;@font-family-monospace: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;@font-family-base: @font-family-sans-serif;@font-size-base: 14px;@font-size-large: ceil((@font-size-base * 1.25)); // ~18px@font-size-small: ceil((@font-size-base * 0.85)); // ~12px@font-size-h1: floor((@font-size-base * 2.6)); // ~36px@font-size-h2: floor((@font-size-base * 2.15)); // ~30px@font-size-h3: ceil((@font-size-base * 1.7)); // ~24px@font-size-h4: ceil((@font-size-base * 1.25)); // ~18px@font-size-h5: @font-size-base;@font-size-h6: ceil((@font-size-base * 0.85)); // ~12px@line-height-base: 1.428571429; // 20/14@line-height-computed: floor((@font-size-base * @line-height-base)); // ~20px@headings-font-family: inherit;@headings-font-weight: 500;@headings-line-height: 1.1;@headings-color: inherit; 图标以下两个变量用于设置图标文件的位置和文件名。 12@icon-font-path: &quot;../fonts/&quot;;@icon-font-name: &quot;glyphicons-halflings-regular&quot;; 组件组件贯穿整个 Bootstrap 框架，他们通过一些变量来设置默认值。下面列出的是常用的几个。 123456789101112131415161718192021222324@padding-base-vertical: 6px;@padding-base-horizontal: 12px;@padding-large-vertical: 10px;@padding-large-horizontal: 16px;@padding-small-vertical: 5px;@padding-small-horizontal: 10px;@padding-xs-vertical: 1px;@padding-xs-horizontal: 5px;@line-height-large: 1.33;@line-height-small: 1.5;@border-radius-base: 4px;@border-radius-large: 6px;@border-radius-small: 3px;@component-active-color: #fff;@component-active-bg: @brand-primary;@caret-width-base: 4px;@caret-width-large: 5px; 特定浏览器厂商的 mixin特定浏览器厂商的 mixin 用于为不同厂商的浏览器使用相应的 CSS 属性前缀来支持各厂商的浏览器。 Box-sizing通过这一个 mixin 来为所有组件设置盒模型。请参考这篇 来自 Mozilla 的文章。 此 mixin 从 v3.2.0 版本开始就被列为 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。 12345.box-sizing(@box-model) &#123; -webkit-box-sizing: @box-model; // Safari &lt;= 5 -moz-box-sizing: @box-model; // Firefox &lt;= 19 box-sizing: @box-model;&#125; 圆角现在，所有现代浏览器都支持不带厂商前缀的 border-radius 属性了。有鉴于此，我们没有提供 .border-radius() mixin，但是，Bootstrap does 提供了用于快速设置同一侧圆角的 mixin 。 12345678910111213141516.border-top-radius(@radius) &#123; border-top-right-radius: @radius; border-top-left-radius: @radius;&#125;.border-right-radius(@radius) &#123; border-bottom-right-radius: @radius; border-top-right-radius: @radius;&#125;.border-bottom-radius(@radius) &#123; border-bottom-right-radius: @radius; border-bottom-left-radius: @radius;&#125;.border-left-radius(@radius) &#123; border-bottom-left-radius: @radius; border-top-left-radius: @radius;&#125; Box (Drop) 隐形如果你的目标用户使用的是最新版本和更高级的浏览器和设备，只需单独使用 box-shadow 属性即可。如果你需要兼容较老的 Android (低于 v4) 和 iOS 设备 (低于 iOS 5)，可以使用下面这个 不建议使用 的 mixin，便于帮你添加 -webkit 前缀。 由于 Bootstrap 并未官方提供对过时（不支持标准属性）平台的支持，此 mixin 从 v3.1.0 版本期就 不建议使用 了。为了保持向后兼容，Bootstrap 将继续在内部使用此 mixin， 直到 Bootstrap v4。 在设置 box 阴影时务必使用 rgba() 颜色，这样可以使他们尽可能地与背景无缝融入。 1234.box-shadow(@shadow: 0 1px 3px rgba(0,0,0,.25)) &#123; -webkit-box-shadow: @shadow; // iOS &lt;4.3 &amp; Android &lt;4.1 box-shadow: @shadow;&#125; 过渡效果有多个 mixin 供你灵活使用。可以一次性设置所有的过渡效果的属性，或者根据需要只是指定延时和持续时间。 此 mixin 从 v3.2.0 版本开始就被列为 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。 1234567891011121314151617181920212223242526.transition(@transition) &#123; -webkit-transition: @transition; transition: @transition;&#125;.transition-property(@transition-property) &#123; -webkit-transition-property: @transition-property; transition-property: @transition-property;&#125;.transition-delay(@transition-delay) &#123; -webkit-transition-delay: @transition-delay; transition-delay: @transition-delay;&#125;.transition-duration(@transition-duration) &#123; -webkit-transition-duration: @transition-duration; transition-duration: @transition-duration;&#125;.transition-timing-function(@timing-function) &#123; -webkit-transition-timing-function: @timing-function; transition-timing-function: @timing-function;&#125;.transition-transform(@transition) &#123; -webkit-transition: -webkit-transform @transition; -moz-transition: -moz-transform @transition; -o-transition: -o-transform @transition; transition: transform @transition;&#125; 变形旋转、缩放、平移（移动）或倾斜任何对象。 此 mixin 从 v3.2.0 版本开始就被列为 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.rotate(@degrees) &#123; -webkit-transform: rotate(@degrees); -ms-transform: rotate(@degrees); // IE9 only transform: rotate(@degrees);&#125;.scale(@ratio; @ratio-y...) &#123; -webkit-transform: scale(@ratio, @ratio-y); -ms-transform: scale(@ratio, @ratio-y); // IE9 only transform: scale(@ratio, @ratio-y);&#125;.translate(@x; @y) &#123; -webkit-transform: translate(@x, @y); -ms-transform: translate(@x, @y); // IE9 only transform: translate(@x, @y);&#125;.skew(@x; @y) &#123; -webkit-transform: skew(@x, @y); -ms-transform: skewX(@x) skewY(@y); // See https://github.com/twbs/bootstrap/issues/4885; IE9+ transform: skew(@x, @y);&#125;.translate3d(@x; @y; @z) &#123; -webkit-transform: translate3d(@x, @y, @z); transform: translate3d(@x, @y, @z);&#125;.rotateX(@degrees) &#123; -webkit-transform: rotateX(@degrees); -ms-transform: rotateX(@degrees); // IE9 only transform: rotateX(@degrees);&#125;.rotateY(@degrees) &#123; -webkit-transform: rotateY(@degrees); -ms-transform: rotateY(@degrees); // IE9 only transform: rotateY(@degrees);&#125;.perspective(@perspective) &#123; -webkit-perspective: @perspective; -moz-perspective: @perspective; perspective: @perspective;&#125;.perspective-origin(@perspective) &#123; -webkit-perspective-origin: @perspective; -moz-perspective-origin: @perspective; perspective-origin: @perspective;&#125;.transform-origin(@origin) &#123; -webkit-transform-origin: @origin; -moz-transform-origin: @origin; -ms-transform-origin: @origin; // IE9 only transform-origin: @origin;&#125; 动画仅适用一个 mixin 就可以在一个声明中使用所有 CSS3 所提供的动画属性，其他 mixin 用于设置单个属性。 T此 mixin 从 v3.2.0 版本开始就 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。 12345678910111213141516171819202122232425262728.animation(@animation) &#123; -webkit-animation: @animation; animation: @animation;&#125;.animation-name(@name) &#123; -webkit-animation-name: @name; animation-name: @name;&#125;.animation-duration(@duration) &#123; -webkit-animation-duration: @duration; animation-duration: @duration;&#125;.animation-timing-function(@timing-function) &#123; -webkit-animation-timing-function: @timing-function; animation-timing-function: @timing-function;&#125;.animation-delay(@delay) &#123; -webkit-animation-delay: @delay; animation-delay: @delay;&#125;.animation-iteration-count(@iteration-count) &#123; -webkit-animation-iteration-count: @iteration-count; animation-iteration-count: @iteration-count;&#125;.animation-direction(@direction) &#123; -webkit-animation-direction: @direction; animation-direction: @direction;&#125; 透明度为所有浏览器设置透明度，并为IE8提供 filter 备用滤镜。 123456.opacity(@opacity) &#123; opacity: @opacity; // IE8 filter @opacity-ie: (@opacity * 100); filter: ~&quot;alpha(opacity=@&#123;opacity-ie&#125;)&quot;;&#125; 占位符文本为表单控件中每个文本域提供占位符（Placeholder）文本的颜色。 12345.placeholder(@color: @input-color-placeholder) &#123; &amp;::-moz-placeholder &#123; color: @color; &#125; // Firefox &amp;:-ms-input-placeholder &#123; color: @color; &#125; // Internet Explorer 10+ &amp;::-webkit-input-placeholder &#123; color: @color; &#125; // Safari and Chrome&#125; 列通过CSS在一个单独的元素中生成列。 1234567891011.content-columns(@width; @count; @gap) &#123; -webkit-column-width: @width; -moz-column-width: @width; column-width: @width; -webkit-column-count: @count; -moz-column-count: @count; column-count: @count; -webkit-column-gap: @gap; -moz-column-gap: @gap; column-gap: @gap;&#125; 渐变便于把任何两种颜色变成背景渐变色。想要使他更高级些，可以设置一个direction（方向），使用三种颜色，也可以使用径向（radial）渐变。使用一个mixin（混入），你就可以得到所有需要的前缀语法。 123#gradient &gt; .vertical(#333; #000);#gradient &gt; .horizontal(#333; #000);#gradient &gt; .radial(#333; #000); 你也可以为标准的里两颜色线性渐变指定角度： 1#gradient &gt; .directional(#333; #000; 45deg); 如果你需要一个条纹风格的渐变，这也很容易。只要指定一个颜色，我们将该颜色半透明的条纹覆盖其上。 1#gradient &gt; .striped(#333; 45deg); 再来试试三种颜色。利用此 mixin ，并为其设置第一种颜色、第二种颜色、第二种颜色的色标（例如 25%），还有第三种颜色： 12#gradient &gt; .vertical-three-colors(#777; #333; 25%; #000);#gradient &gt; .horizontal-three-colors(#777; #333; 25%; #000); 当心！ 如果你想删除某个渐变，确保将你所添加的针对 IE 的 filter 一并删除。你可以通过使用 .reset-filter() mixin 和 background-image: none; 达到目的。 实用工具 mixin实用工具 mixin 用于与不相关的 CSS 结合以达到特定目的或任务。 Clearfix – 清除浮动建议为需要清除浮动的元素使用 .clearfix() mixin ，尽量不要直接添加 class=&quot;clearfix&quot; 类。基于 Nicolas Gallagher 的 micro clearfix 代码。 12345678910111213141516// Mixin.clearfix() &#123; &amp;:before, &amp;:after &#123; content: &quot; &quot;; display: table; &#125; &amp;:after &#123; clear: both; &#125;&#125;// Usage.container &#123; .clearfix();&#125; 水平居中让元素在其父元素中水平居中。需要设置 width 或 max-width 属性。 123456789101112// Mixin.center-block() &#123; display: block; margin-left: auto; margin-right: auto;&#125;// Usage.container &#123; width: 940px; .center-block();&#125; 尺寸助手 mixin用于方便的指定对象的尺寸。 123456789101112// Mixins.size(@width; @height) &#123; width: @width; height: @height;&#125;.square(@size) &#123; .size(@size; @size);&#125;// Usage.image &#123; .size(400px; 300px); &#125;.avatar &#123; .square(48px); &#125; 可调整大小的文本域方便设置任何文本域或其他元素的尺寸可调整。默认依循浏览器默认行为 (both)，即垂直、水平都可以调整。 123456.resizable(@direction: both) &#123; // Options: horizontal, vertical, both resize: @direction; // Safari fix overflow: auto;&#125; 截断文本此 mixin 用来以省略号代替被截断的文本。元素必须是 block 或 inline-block 级。 12345678910111213// Mixin.text-overflow() &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;// Usage.branch-name &#123; display: inline-block; max-width: 200px; .text-overflow();&#125; 视网膜屏幕（Retina）下的图片通过指定两个图片路径和 @1x 图片尺寸，Bootstrap 还提供了对 @2x 媒体查询的支持。 如果你的页面上有很多图片，建议在一个单独的媒体查询中手工编写针对视网膜屏幕的 CSS 代码。 12345678910111213141516171819.img-retina(@file-1x; @file-2x; @width-1x; @height-1x) &#123; background-image: url(&quot;@&#123;file-1x&#125;&quot;); @media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and ( min--moz-device-pixel-ratio: 2), only screen and ( -o-min-device-pixel-ratio: 2/1), only screen and ( min-device-pixel-ratio: 2), only screen and ( min-resolution: 192dpi), only screen and ( min-resolution: 2dppx) &#123; background-image: url(&quot;@&#123;file-2x&#125;&quot;); background-size: @width-1x @height-1x; &#125;&#125;// Usage.jumbotron &#123; .img-retina(&quot;/img/bg-1x.png&quot;, &quot;/img/bg-2x.png&quot;, 100px, 100px);&#125; ===","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/Spring跨域","date":"2018-04-11T10:59:21.000Z","updated":"2018-04-11T11:00:23.000Z","comments":true,"path":"2018/04/11/Java/JavaEE/Java框架/spring/Spring跨域/","link":"","permalink":"http://io.stelawliet.top/2018/04/11/Java/JavaEE/Java框架/spring/Spring跨域/","excerpt":"","text":"CORS support in Spring FrameworkENGINEERING SÉBASTIEN DELEUZE JUNE 08, 2015 56 COMMENTS For security reasons, browsers prohibit AJAX calls to resources residing outside the current origin. For example, as you’re checking your bank account in one tab, you could have the evil.com website in another tab. The scripts from evil.com shouldn’t be able to make AJAX requests to your bank API (withdrawing money from your account!) using your credentials. Cross-origin resource sharing (CORS) is a W3C specification implemented by most browsersthat allows you to specify in a flexible way what kind of cross domain requests are authorized, instead of using some less secured and less powerful hacks like IFrame or JSONP. Spring Framework 4.2 GA provides first class support for CORS out-of-the-box, giving you an easier and more powerful way to configure it than typical filter based solutions. Spring MVC provides high-level configuration facilities, described bellow. Controller method CORS configurationYou can add to your @RequestMapping annotated handler method a @CrossOriginannotation in order to enable CORS on it (by default @CrossOrigin allows all origins and the HTTP methods specified in the @RequestMapping annotation): 123456789101112131415@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123; @CrossOrigin @GetMapping(&quot;/&#123;id&#125;&quot;) public Account retrieve(@PathVariable Long id) &#123; // ... &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public void remove(@PathVariable Long id) &#123; // ... &#125;&#125; It is also possible to enable CORS for the whole controller: 123456789101112131415@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123; @GetMapping(&quot;/&#123;id&#125;&quot;) public Account retrieve(@PathVariable Long id) &#123; // ... &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public void remove(@PathVariable Long id) &#123; // ... &#125;&#125; In this example CORS support is enabled for both retrieve() and remove() handler methods, and you can also see how you can customize the CORS configuration using @CrossOrigin attributes. You can even use both controller and method level CORS configurations, Spring will then combine both annotation attributes to create a merged CORS configuration. 12345678910111213141516@CrossOrigin(maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123; @CrossOrigin(origins = &quot;http://domain2.com&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public Account retrieve(@PathVariable Long id) &#123; // ... &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public void remove(@PathVariable Long id) &#123; // ... &#125;&#125; If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. 12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and()... &#125;&#125; Global CORS configurationIn addition to fine-grained, annotation-based configuration you’ll probably want to define some global CORS configuration as well. This is similar to using filters but can be declared withing Spring MVC and combined with fine-grained @CrossOrigin configuration. By default all origins and GET, HEAD and POST methods are allowed. JavaConfigEnabling CORS for the whole application is as simple as: 123456789@Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;); &#125;&#125; If you are using Spring Boot, it is recommended to just declare a WebMvcConfigurer bean as following: 12345678910111213@Configurationpublic class MyConfiguration &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;); &#125; &#125;; &#125;&#125; You can easily change any properties, as well as only apply this CORS configuration to a specific path pattern: 123456789@Overridepublic void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/api/**&quot;) .allowedOrigins(&quot;http://domain2.com&quot;) .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;) .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;) .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;) .allowCredentials(false).maxAge(3600);&#125; If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. XML namespaceIt is also possible to configure CORS with the mvc XML namespace. This minimal XML configuration enable CORS on /** path pattern with the same default properties than the JavaConfig one: 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt;&lt;/mvc:cors&gt; It is also possible to declare several CORS mappings with customized properties: 12345678910111213&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/**&quot; allowed-origins=&quot;http://domain1.com, http://domain2.com&quot; allowed-methods=&quot;GET, PUT&quot; allowed-headers=&quot;header1, header2, header3&quot; exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;false&quot; max-age=&quot;123&quot; /&gt; &lt;mvc:mapping path=&quot;/resources/**&quot; allowed-origins=&quot;http://domain1.com&quot; /&gt;&lt;/mvc:cors&gt; If you are using Spring Security, don’t forget to enable CORS at Spring Security level as well: 12345&lt;http&gt; &lt;!-- Default to Spring MVC&apos;s CORS configuration --&gt; &lt;cors /&gt; ...&lt;/http&gt; How does it work?CORS requests (including preflight ones with an OPTIONS method) are automatically dispatched to the various HandlerMappings registered. They handle CORS preflight requests and intercept CORS simple and actual requests thanks to a CorsProcessor implementation (DefaultCorsProcessor by default) in order to add the relevant CORS response headers (like Access-Control-Allow-Origin). CorsConfiguration allows you to specify how the CORS requests should be processed: allowed origins, headers, methods, etc. It can be provided in various ways: AbstractHandlerMapping#setCorsConfiguration() allows to specify a Map with several CorsConfiguration mapped on path patterns like /api/** Subclasses can provide their own CorsConfiguration by overriding AbstractHandlerMapping#getCorsConfiguration(Object, HttpServletRequest)method Handlers can implement CorsConfigurationSource interface (like ResourceHttpRequestHandler now does) in order to provide a CorsConfiguration for each request. Filter based CORS supportAs an alternative to other methods presented above, Spring Framework also provides a CorsFilter. In that case, instead of using @CrossOrigin or WebMvcConfigurer#addCorsMappings(CorsRegistry), you can for example declare the filter as following in your Spring Boot application: 1234567891011121314151617@Configurationpublic class MyConfiguration &#123; @Bean public FilterRegistrationBean corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin(&quot;http://domain1.com&quot;); config.addAllowedHeader(&quot;*&quot;); config.addAllowedMethod(&quot;*&quot;); source.registerCorsConfiguration(&quot;/**&quot;, config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"JavaScript/Vue.js/生命周期","date":"2018-04-10T13:53:42.000Z","updated":"2018-04-10T14:16:44.000Z","comments":true,"path":"2018/04/10/JavaScript/Vue.js/生命周期/","link":"","permalink":"http://io.stelawliet.top/2018/04/10/JavaScript/Vue.js/生命周期/","excerpt":"","text":"Vue生命周期钩子（函数）beforeCreate 类型：Function 详细： 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 无法取到el和data中的数据 ​ ​ created 类型：Function 详细： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 可以访问data中的数据。 没有mount(挂载)。拿不到el 可以用来请求数据赋值给data ​ beforeMount 类型：Function 详细： 在挂载开始之前被调用：相关的 render 函数首次被调用。 render的用法用指定的vue文件来渲染模版 main.js入口来引入app.vue 获取的el元素还是。没有渲染数据到dom上 ​ mounted 类型：Function 详细： el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted： 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 ​ beforeUpdate 类型：Function 详细： 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 该钩子在服务器端渲染期间不被调用。 ​ updated 类型：Function 详细： 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated： 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 ​ activated 类型：Function 详细： keep-alive 组件激活时调用。 该钩子在服务器端渲染期间不被调用。 ​ deactivated 类型：Function 详细： keep-alive 组件停用时调用。 该钩子在服务器端渲染期间不被调用。 参考： 构建组件 - keep-alive 动态组件 - keep-alive beforeDestroy 类型：Function 详细： 实例销毁之前调用。在这一步，实例仍然完全可用。 该钩子在服务器端渲染期间不被调用。 ​ destroyed 类型：Function 详细： Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 ​","categories":[],"tags":[]},{"title":"yaml study","slug":"yaml","date":"2018-04-09T14:36:15.000Z","updated":"2018-07-04T11:53:43.000Z","comments":true,"path":"2018/04/09/yaml/","link":"","permalink":"http://io.stelawliet.top/2018/04/09/yaml/","excerpt":"","text":"yaml study YamlBeans makes it easy to serialize and deserialize Java object graphs to and from YAML, a human-friendly data format. Replace XML and properties files with YAML for more expressive power (lists, maps, anchors, etc) and easier hand-editing. Basic deserialization The YamlReader class is used to deserialize YAML to Java objects. The following YAML defines a Map with four entries. The “phone numbers” entry is a List of two items, each of which is a Map. 12345678name: Nathan Sweetage: 28address: 4011 16th Ave Sphone numbers: - name: Home number: 206-555-5138 - name: Work number: 425-555-2306 The “read” method reads the next YAML document and deserializes it into HashMaps, ArrayLists, and Strings. Since we know the root object defined in the YAML of our example is a Map, we can cast the object and make use of it. 12345YamlReader reader = new YamlReader(new FileReader(&quot;contact.yml&quot;));Object object = reader.read();System.out.println(object);Map map = (Map)object;System.out.println(map.get(&quot;address&quot;)); Multiple objects A stream of YAML can contain more than one YAML document. Each call to YamlReader#read() deserializes the next document into an object. YAML documents are delimited by “—“ (this is optional for the first document). 12345name: Nathan Sweetage: 28---name: Jenny Alarcoage: 25 This prints the String “28” then “25”: 123456YamlReader reader = new YamlReader(new FileReader(&quot;contact.yml&quot;));while (true) &#123; Map contact = reader.read(); if (contact == null) break; System.out.println(contact.get(&quot;age&quot;));&#125; Deserializing other classes There are two ways to deserialize something other than HashMaps, ArrayLists, and Strings. Imagine this YAML document and Java class: 1234567name: Nathan Sweetage: 28public class Contact &#123; public String name; public int age;&#125; The “read” method can be passed a class, so the YamlReader knows what it is deserializing: 123YamlReader reader = new YamlReader(new FileReader(&quot;contact.yml&quot;));Contact contact = reader.read(Contact.class);System.out.println(contact.age); The YamlReader creates an instance of the Contact class and sets the “name” and “age” fields. The YamlReader determines the “age” value in the YAML needs to be converted into a int. Deserialization would have failed if the age was not a valid int. The YamlReader can set public fields and bean setter methods. Instead of telling the YamlReader what type to deserialize, the type can alternatively be specified in the YAML using a tag: 123!com.example.Contactname: Nathan Sweetage: 28 Serializing objects The YamlWriter class is used to serialize Java objects to YAML. The “write” method automatically handles this by recognizing public fields and bean getter methods. 123456Contact contact = new Contact();contact.name = &quot;Nathan Sweet&quot;;contact.age = 28;YamlWriter writer = new YamlWriter(new FileWriter(&quot;output.yml&quot;));writer.write(contact);writer.close(); This outputs: 123!com.example.Contactname: Nathan Sweetage: 28 The tags are automatically output as needed so that the YamlReader class will be able to reconstruct the object graph. For example, serializing this ArrayList does not output any tag for the list because YamlReader uses an ArrayList by default. 123456List list = new ArrayList();list.add(&quot;moo&quot;);list.add(&quot;cow&quot;);- moo- cow If the list was a LinkedList, then YamlWriter knows that a tag is needed and outputs: 1234567List list = new LinkedList();list.add(&quot;moo&quot;);list.add(&quot;cow&quot;);!java.util.LinkedList- moo- cow Complex graphs YamlBeans can serialize any object graph. 1234567891011121314151617181920212223242526272829303132333435public class Contact &#123; public String name; public int age; public List phoneNumbers;&#125;public class Phone &#123; public String name; public String number;&#125;friends: - !com.example.Contact name: Bob age: 29 phoneNumbers: - !com.example.Phone name: Home number: 206-555-1234 - !com.example.Phone name: Work number: 206-555-5678 - !com.example.Contact name: Mike age: 31 phoneNumbers: - !com.example.Phone number: 206-555-4321enemies: - !com.example.Contact name: Bill phoneNumbers: - !com.example.Phone name: Cell number: 206-555-1234 This is a map of lists of contacts, each with a list of phone numbers. Again, the public fields could also have been bean properties. Tag shortcuts Tags can be lengthy sometimes and can clutter up the YAML. Alternate tags can be defined for a class and will be used instead of the full class name. 1234YamlWriter writer = new YamlWriter(new FileWriter(&quot;output.yml&quot;));writer.getConfig().setClassTag(&quot;contact&quot;, Contact.class);writer.write(contact);writer.close(); The output no longer contains the full classname for the Contact class. 123!contactname: Nathan Sweetage: 28 Lists and maps When reading or writing a List or Map, YamlBeans cannot know what type of objects are supposed to be in the List or Map, so it will write out a tag. 123456789!com.example.Contactname: Bill phoneNumbers: - !com.example.Phone number: 206-555-1234 - !com.example.Phone number: 206-555-5678 - !com.example.Phone number: 206-555-7654 This can make the YAML less readable. To improve this, you may define what element type should be expected for a List or Map field on your object. 1234YamlWriter writer = new YamlWriter(new FileWriter(&quot;output.yml&quot;));writer.getConfig().setPropertyElementType(Contact.class, &quot;phoneNumbers&quot;, Phone.class);writer.write(contact);writer.close(); Now YamlBeans knows what to expect for elements of the “phoneNumbers” field, so extra tags will not be output. 123456!com.example.Contactname: Bill phoneNumbers: - number: 206-555-1234 - number: 206-555-5678 - number: 206-555-7654 Setting the element type for a Map field tells YamlBeans what to expect for values in the Map. Keys in a Map are always Strings. Anchors When an object graph contains multiple references to the same object, an anchor may be used so that the object only needs to be defined once in the YAML. 12345oldest friend: &amp;1 !contact name: Bob age: 29best friend: *1 In this map, the “oldest friend” and “best friend” keys reference the same object. The YamlReader automatically handles the anchors in the YAML when rebuilding the object graph. By default, the YamlWriter automatically outputs anchors when writing objects. 123456Contact contact = new Contact();contact.name = &quot;Bob&quot;;contact.age = 29;Map map = new HashMap();map.put(&quot;oldest friend&quot;, contact);map.put(&quot;best friend&quot;, contact); Architecture The YAML tokenizer, parser, and emitter are based on those from the JvYAML project. They have been heavily refactored, bugs fixed, etc. The rest of the JvYAML project was not used because of its complexity. YamlBeans strives for the simplest possible thing that works, with the goal being to make it easy to use the YAML data format with Java. YamlBeans supports YAML version 1.0 and 1.1. More info Various other features are available on the YamlConfig class and should be pretty self explanatory. First release date: 2008-08-14 Website: http://sourceforge.net/projects/yamlbeans/","categories":[{"name":"标记语言","slug":"标记语言","permalink":"http://io.stelawliet.top/categories/标记语言/"},{"name":"yaml","slug":"标记语言/yaml","permalink":"http://io.stelawliet.top/categories/标记语言/yaml/"}],"tags":[{"name":"yaml","slug":"yaml","permalink":"http://io.stelawliet.top/tags/yaml/"}]},{"title":"Java学习大纲参考 I","slug":"Java/JavaEE/java学习之路","date":"2018-04-05T05:52:17.000Z","updated":"2018-07-04T11:39:58.000Z","comments":true,"path":"2018/04/05/Java/JavaEE/java学习之路/","link":"","permalink":"http://io.stelawliet.top/2018/04/05/Java/JavaEE/java学习之路/","excerpt":"","text":"[TOC] Java工程师成神之路（2018修订版） 主要版本 更新时间 备注 v1.0 2015-08-01 首次发布 v1.1 2018-03-12 增加新技术知识、完善知识体系 一、基础篇JVMJVM内存结构堆、栈、方法区、直接内存、堆和栈区别 Java内存模型内存可见性、重排序、顺序一致性、volatile、锁、final 垃圾回收内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定 JVM参数及调优Java对象模型oop-klass、对象头 HotSpot即时编译器、编译优化 类加载机制classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 虚拟机性能监控与故障处理工具jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler 编译与反编译javac 、javap 、jad 、CRF Java基础知识阅读源代码String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet Java中各种变量类型熟悉Java String的使用，熟悉String的各种函数JDK 6和JDK 7中substring的原理及区别、 replaceFirst、replaceAll、replace区别、 String对“+”的重载、 String.valueOf和Integer.toString的区别、 字符串的不可变性 自动拆装箱Integer的缓存机制 熟悉Java中各种关键字transient、instanceof、volatile、synchronized、final、static、const 原理及用法。 集合类常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因 枚举枚举的用法、枚举与单例、Enum类 Java IO&amp;Java NIO，并学会使用bio、nio和aio的区别、三种IO的用法与原理、netty Java反射与javassist反射与工厂模式、 java.lang.reflect.* Java序列化什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全 注解元注解、自定义注解、Java中常用注解使用、注解与反射的结合 JMS什么是Java消息服务、JMS消息传送模型 JMXjava.lang.management.*、 javax.management.* 泛型泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法 单元测试junit、mock、mockito、内存数据库（h2） 正则表达式java.lang.util.regex.* 常用的Java工具库commons.lang, commons.*... guava-libraries netty 什么是API&amp;SPI异常异常类型、正确处理异常、自定义异常 时间处理时区、时令、Java中时间API 编码方式解决乱码问题、常用编码方式 语法糖Java中语法糖原理、解语法糖 Java并发编程什么是线程，与进程的区别阅读源代码，并学会使用Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors 线程池自己设计线程池、submit() 和 execute() 线程安全死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系 锁CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 死锁volatilehappens-before、编译器指令重排和CPU指令重 synchronizedsynchronized是如何实现的？synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例 sleep 和 waitwait 和 notifynotify 和 notifyAllThreadLocal写一个死锁的程序写代码来解决生产者消费者问题守护线程守护线程和非守护线程的区别以及用法 二、 进阶篇Java底层知识字节码、class文件格式CPU缓存，L1，L2，L3和伪共享尾递归位运算用位运算实现加、减、乘、除、取余 设计模式了解23种设计模式会使用常用设计模式单例、策略、工厂、适配器、责任链。 实现AOP实现IOC不用synchronized和lock，实现线程安全的单例模式nio和reactor设计模式网络编程知识tcp、udp、http、https等常用协议三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包 http/1.0 http/1.1 http/2之前的区别Java RMI，Socket，HttpClientcookie 与 sessioncookie被禁用，如何实现session 用Java写一个简单的静态文件的HTTP服务器 实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则” 了解nginx和apache服务器的特性并搭建一个对应的服务器用Java实现FTP、SMTP协议进程间通讯的方式什么是CDN？如果实现？什么是DNS？反向代理框架知识Servlet线程安全问题Servlet中的filter和listenerHibernate的缓存机制Hiberate的懒加载Spring Bean的初始化Spring的AOP原理自己实现Spring的IOCSpring MVCSpring Boot2.0Spring Boot的starter原理，自己实现一个starter Spring Security应用服务器知识JBosstomcatjettyWeblogic工具git &amp; svnmaven &amp; gradle三、 高级篇新技术Java 8lambda表达式、Stream API、 Java 9Jigsaw、Jshell、Reactive Streams Java 10局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制 Spring 5响应式编程 Spring Boot 2.0性能优化使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 线上问题分析dump获取线程Dump、内存Dump、gc情况 dump分析分析死锁、分析内存泄露 自己编写各种outofmemory，stackoverflow程序HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow 常见问题解决思路内存溢出、线程死锁、类加载冲突 使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题、 当一个Java程序频繁FullGC时如何解决问题、 如何查看垃圾回收日志、 当一个Java应用发生OutOfMemory时该如何解决、 如何判断是否出现死锁、 如何判断是否存在内存泄露 编译原理知识编译与反编译Java代码的编译与反编译Java的反编译工具词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化操作系统知识Linux的常用命令进程同步缓冲区溢出分段和分页虚拟内存与主存数据库知识MySql 执行引擎MySQL 执行计划如何查看执行计划，如何根据执行计划进行SQL优化 SQL优化事务事务的隔离级别、事务能不能实现锁的功能 数据库锁行锁、表锁、使用数据库锁实现乐观锁、 数据库主备搭建binlog内存数据库h2 常用的nosql数据库redis、memcached 分别使用数据库锁、NoSql实现分布式锁性能调优数据结构与算法知识简单的数据结构栈、队列、链表、数组、哈希表、 树二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树 排序算法各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列、贪心算法、KMP算法、hash算法、海量数据处理 大数据知识Zookeeper基本概念、常见用法 Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引 Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。 Hadoop，离线计算HDFS、MapReduce 分布式日志收集flume，kafka，logstash数据挖掘，mahout网络安全知识什么是XSSXSS的防御 什么是CSRF什么是注入攻击SQL注入、XML注入、CRLF注入 什么是文件上传漏洞加密与解密MD5，SHA1、DES、AES、RSA、DSA 什么是DOS攻击和DDOS攻击memcached为什么可以导致DDos攻击、什么是反射型DDoS SSL、TLS，HTTPS如何通过Hash碰撞进行DOS攻击用openssl签一个证书部署到apache或nginx四、架构篇分布式数据一致性、服务治理、服务降级 分布式事务2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC Dubbo服务注册、服务发现，服务治理 分布式数据库怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase 分布式文件系统mfs、fastdfs 分布式缓存缓存一致性、缓存命中率、缓存冗余 微服务SOA、康威定律 ServiceMeshDocker &amp; KubernetsSpring BootSpring Cloud高并发分库分表CDN技术消息队列ActiveMQ 监控监控什么CPU、内存、磁盘I/O、网络I/O等 监控手段进程监控、语义监控、机器资源监控、数据波动 监控数据采集日志、埋点 Dapper负载均衡tomcat负载均衡、Nginx负载均衡 DNSDNS原理、DNS的设计 CDN数据一致性 五、 扩展篇云计算IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess 搜索引擎Solr、Lucene、Nutch、Elasticsearch 权限管理Shiro 区块链哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名 比特币挖矿、共识机制、闪电网络、侧链、热点问题、分叉 以太坊超级账本人工智能数学基础、机器学习、人工神经网络、深度学习、应用场景。 常用框架TensorFlow、DeepLearning4J 其他语言Groovy、Python、Go、NodeJs、Swift、Rust 六、 推荐书籍《深入理解Java虚拟机》 《Effective Java》 《深入分析Java Web技术内幕》 《大型网站技术架构》 《代码整洁之道》 《Head First设计模式》 《maven实战》 《区块链原理、设计与应用》 《Java并发编程实战》 《鸟哥的Linux私房菜》 《从Paxos到Zookeeper》 《架构即未来》","categories":[{"name":"Java","slug":"Java","permalink":"http://io.stelawliet.top/categories/Java/"},{"name":"学习路线","slug":"Java/学习路线","permalink":"http://io.stelawliet.top/categories/Java/学习路线/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://io.stelawliet.top/tags/Java/"}]},{"title":"","slug":"MD/studyo/java面试要点","date":"2018-04-03T08:40:56.000Z","updated":"2018-04-03T09:07:29.000Z","comments":true,"path":"2018/04/03/MD/studyo/java面试要点/","link":"","permalink":"http://io.stelawliet.top/2018/04/03/MD/studyo/java面试要点/","excerpt":"","text":"1. Spring MVC 如何接受并处理一个请求的? 首先我们会在web.xml中注册一个DispatcherServlet，并令这个servlet接收所有的请求，项目启动后Spring会扫描配置文件，根据配置加载和实例化类，其中扫描到的带有@Controller或者@RestController注解的类则是请求要映射到的类，Spring MVC扫描里面所有和请求映射有关的注解， 如@RequestMapping、@ResponseBody、@RequestParam等。当接收到一个请求时，它会根据请求的url映射到对应的controler，并根据返回值判断是渲染jsp页面还是返回普通文本，亦或是返回json。 2. AOP实现原理。 AOP是通过动态代理来实现的，有两种常用的技术，一是JDK的动态代理，二是CGLIB，而无论是前者还是后者，都是生成动态生成类的字节码来实现的。JDK的动态代理只能处理接口实现的方法，而CGLIB则没有这个限制。因为字节码是动态生成的，所以可以在生成的字节码当中，在目标方法前后插入定义好的方法的调用。 3. 注解是怎么用的?为什么要使用注解? 当在一个类、方法或者字段上标上注解后，可以通过obj.getClass().isAnnotationPresent(..)来判断一个目标是否被特定的注解标识，通过obj.getClass().getAnnotation(..)来获取标志是注解，以此获得注解上的信息。使用注解可以帮助我们在项目的编译期或运行时给类、方法或对象添加一个额外的信息，给编程增加了很大的灵活性。比如用@Override来标志这是重写父类的方法，那么编译器就可以在编译期检查该方法是否真的是重写父类的方法，将错误扼杀在编译器。 4. 线程有几种状态?生命周期是怎样的? 线程有五种状态:创建、就绪、运行、阻塞、死亡。调用start方法时，线程就会进入就绪状态。在线程得到cpu时间片时进入运行状态。线程调用yield方法可以让出cpu时间回到就绪状态。线程运行时可能由于IO、调用sleep、wait、join方法或者无法获得同步锁等原因进入阻塞状态。当线程获得到等待的资源资源或者引起阻塞的条件得到满足时(调用notify或notifyAll)，会从阻塞状态进入就绪状态。当线程的run方法执行结束或者调用interrupt方法时，线程就进入死亡状态。 5. Java中如何实现同步。 Java实现同步的方法有: 使用synchronized关键字为方法或代码块加锁。 使用volatile修饰变量，但是volatile不保证原子性。 使用ReentrantLock或者ReentrantReadWriteLock， 这种方法比synchronized更灵活。 使用Semaphore，允许最多n个线程同时访问资源。 6. HashMap与Hashtable的区别。 HashMap是线程不安全的，Hashtable是线程安全的。 HashMap的key和value接受null，Hashtable不接受。 HashMap继承自AbstractMap，Hashtable继承自Directory。 7. JVM是否了解?这里我回答了最近正在看《深入理解Java虚拟机》一书，本想着这方面的问题能答上一些的，没想到面试官直接说那看样子还不是很了解，就不问这块的问题了= =.. 心塞但是我估摸着大概如果问的话会问: 7.1. JVM的内存模型。 JVM的内存一共分为5个部分: 程序计数器: 里面存放着线程执行的指令。 方法区: 存放类的信息，如:类名、方法、成员变量等，也存放着常量池。 虚拟机栈: 存放着局部变量表、操作数栈、方法出口信息等方法执行所需信息。 本地方法栈: 存放程序调用native方法的信息。 堆: 这五个部分中最大的，对象的内存分配都是在堆内存中。 7.2. 常用的虚拟机参数。 -Xmx: 指定最大堆内存 -Xms: 指定初始化堆内存大小。 -Xmn: 指定年轻代内存初始内存大小，同时也是最大内存大小。 -XX:NewSize: 指定年轻代内存大小。 -XX:NewRatio: 指定年轻代和老年代的内存比例。 -XX:MaxHeapSize: 指定程序最大内存。 -XX:+PrintGC: 打印GC日志。 -XX:+PrintGCDetails: 打印详细的GC日志。 -Xloggc: 打印GC日志保存位置。 7.3. 垃圾回收算法。 引用计数算法: 该算法对每一个对象都有一个引用计数，没增加一次引用就+1，减少一次引用-1，在回收时将引用计数为0的对象清理掉。这种算法简单，但是无法解决循环引用的问题(比如: A引用B， B也引用A，但是A和B都没有被其它任何对象引用)。 标记-清除算法: 该算法分为两个阶段， 第一阶段遍历找出所有需要被回收的对象，并做上标记，第二阶段对清理所有被标记的对象，这种算法效率比较低，并且会产生较多的内存碎片。 标记-整理算法: 该算法的第一阶段和标记-清除算法是一样的，而第二阶段它不是直接清理掉垃圾对象，而且将存活的对象往同一侧移动，移动完成后清理掉另一侧所有的对象。这种算法不会产生内存碎片，但是效率低下。 复制算法: 该算法将内存分为两个区域，进行垃圾回收时，就将还活着的对象复制到另一块内存区域中，然后再将整片内存区域清空。这种算法简单快速，而且不会产生内存碎片，但是因为将内存分成两块，所以可用的内存会少很多。 分代收集算法: 将内存细分为多个区域，不同区域GC的频率，并对不同的区域采用适当的收集算法。如JVM将内存分为年轻代和老年代，普通对象最开始分配在年轻代(大对象会直接分配到老年代)，同一个对象在经过几次GC后还存活着，就认为这个对象的生命周期会比较长，将其移入老年代，GC主要发生在年轻代。 7.4 类加载机制。 Java中主要有Bootstrap类加载器、ExtClassLoader、AppClassLoader，其中Bootstrap类加载器主要加载JAVA_HOME/lib目录下的类库，ExtClassLoader加载JAVA_HOME/lib/ext目录下的类库，AppClassLoader加载classpath指向目录下的类库。 Java的类加载器使用双亲委派模型，除了顶层的Bootstrap类加载器外，其余的类加载器都有父类加载器，当一个类加载器要加载一个类时，它不会直接去加载，而是委托父类加载器尝试加载，父类加载器如果无法完成，则继续委托其父类加载器加载，如果在期间有某一个类加载器发现已经加载过这个类，则会将已经加载的类返回，子类不再加载。若所有的类加载器都未加载过这个类，那么最开始尝试加载的加载器才会去加载这个类。使用这样的加载机制的好处是: 对于同一个类，如: java.lang.String，能保证整个程序中都是使用的这一个类，否则如果用户在自己的项目中也写了一个java.lang.String类，那么项目中将存在两个String类，一个是java提供的String类，一个是用户自定义的String类，不仅使项目变得混乱，而且不安全。 8. MyBatis和Hibernate各有什么优缺点?我个人因为只简单接触过而没有实际应用过Hibernate，所以没能从比较好的角度来回答这个问题。 Hibernate的优点是它是一个完全的ORM框架，使用Hibernate可以做到不用手写SQL，而且无须关心使用何种数据库，可移植性较好，当需要更变数据库时需要做的修改很少甚至为0。其缺点是需要根据数据库的设计在实体进行又一次的配置，且帮程序员做了太多事，如果需要进行调优的话需要对Hibernate有比较深的了解。MyBatis的优缺点差不多和Hibernate相反，我们需要手写SQL语句和配置结果集和实体类的映射，即使是简单的单表操作也需要写SQL(可以通过拦截器来实现CommonMapper，或者可以使用生成器来生成代码)，因此MyBatis要进行SQL调优也简单直接。其次是MyBatis的二级缓存功能较弱，是针对namespace的。 9. MySQL平时是怎么分析效率和进行SQL优化的? 较常使用的方法是explain SQL查看执行计划，根据查询计划可以知道是否使用了索引，是否进行来全表扫描以及查询的顺序，依此我们可以建立适当的索引和连接查询调优。还有一个是开启慢查询记录执行时间长的SQL语句。 通常会在WHERE、JOIN ON和ORDER BY使用到字段上加上索引。 避免查询时判断NULL，否则可能会导致全表扫描。 避免使用OR来连接查询条件，否则可能导致全表扫描，可以改用UNION或UNION ALL。 避免LIKE查询，否则可能导致全表扫描。 不使用SELECT *，只查询必须的字段，避免加载无用数据。 能用UNION ALL的时候就不用UNION，UNION过滤重复数据要耗费更多的cpu资源。 10. MySQL除了InnoDB还有哪些引擎，有什么区别? 因为平时都是用的InnoDB，对其它引擎的了解甚少，所以这个问题没答上= =，这里直接贴一个链接好了。相关链接: MySQL存储引擎介绍 11. 如何动态改变页面上的元素? 使用$(..).css({..})来改变元素的样式。 使用$(..).attr(..)改变元素的属性。 使用$(..).html(..)改变元素的html内容。 使用$(..).text(..)改变元素的文本内容。 使用$(..).remove(..)删除元素。 使用$(..).append(..)添加元素。 12. 分页的实现。 如果是使用JSP等后端模板的话，一般会将需要分页的JSP代码抽成一个单独的JSP文件，并在页面中动态计算分页按钮的展示方式，在母页中include该JSP文件，然后在前端点击分页按钮时，通过AJAX请求下一页的内容，服务器端将渲染后的HTML返回给前端，前端通过$(..).html()等方式替换展示内容。如果是在前后端分离的项目中，一般会使用一些前端的框架，如: React.js、Vue.js等，每次只向后台请求分页的数据，一般数据交互格式使用JSON，并替换已有的数据，触发页面内容的改变。 13. 解释一下RESTful，平时是怎么用的 RESTful是无状态的，采用URL+HTTP请求方法来描述资源和行为。一般在前后端分离的项目中，后端会提供REST接口给前端，其HTTP请求方法一般为: GET : 获取资源。 POST: 更新资源。 PUT: 创建资源。 DELETE: 删除资源。 其次，RESTful由于是无状态的，一般会采用JWT或OAuth的方式来认证一个用户，Token是保存在前端的，为了安全性一般会配合HTTPS使用。 14. 有没有抓过包?GET和POST格式是怎么样的? HTTP请求分为三部分: 请求行、请求头、请求体:请求行: 第一行是METHOD URL protocal，如GET http://abc.com HTTP/1.1。请求头: 从第二行开始，每一行的内容都是一个请求头参数值，直到遇到一个空行为止。请求体: 请求头和请求体中间隔着一行空行作为分界，请求体包含着本次请求携带的内容。GET方式的请求没有请求体，其是将参数追加到URL后面，URL中?后面的内容为请求参数。POST方式则三部分都有，且POST的请求头应当包含Content-Type来指明请求体中内容的类型。 15. 如果是上传文件的话又是怎样的?后端如何处理? 上传文件的话会设置Content-Type为multipart/form-data，并指定boundary的值来标识请求体中内容的分界，而在请求体中，不同的内容(如：文件A和文件B)之间使用boundary的值来标识分界，并且请求体中每部分内容都会有Content-Disposition和Content-Type来指明这部分内容的类型和信息。 后端的话使用ServletFileUpload来解析请求，获得FileItem的List，遍历Item，然后通过Item获得输入流，从输入流中读取上传文件的数据，再构建FileOutputStream输出到磁盘中保存。如果使用Spring MVC，则可以在接收请求的方法中接收CommonsMultipartFile，并使用transferTo方法保存到磁盘中。 16. AJAX实现原理。这个也没答上来，平时都是使用jQuery封装的AJAX或者其他AJAX框架。 AJAX是利用浏览器的AJAX引擎来实现的异步请求，通过XMLHttpRequest对象来发送请求，由AJAX引擎向服务器发送和接收响应，再回调给用户处理，达到不阻塞用户界面和无刷新的目的。资料来源: AJAX工作原理及其优缺点。 17. Linux下怎么查找一个文件? 如果是查找二进制文件，可以使用whereis。如果是查找命令，可以使用which。如果是其他文件，可以使用find命令(其实什么都可以找), -name指定搜索的名称或者匹配串， -maxdepth指定搜索的深度。也可以使用locate命令查找，但是最新变动的文件可能会找不到，因为该命令实际上是搜索数据库，该数据库每天自动更新，可以手动执行updatedb更新。 18. Linux怎么查找一个进程? 使用ps命令可以查看进程状态，ps -ef查看所有进程，配合grep命令可以进行筛选， 如查看tomcat进程的命令是: ps -ef | grep tomcat。 19. Linux下只知道文件所在目录和内容，如何查找文件?这题没也没答上= = 使用grep命令可以实现:grep -rn /path/to/target/dir -e &quot;pattern&quot;-r: 递归-n: 显示行数-w: 完全匹配例子: grep -rn. -e &quot;ERROR&quot;输出: ./面试:143:输出: ./面试:144:上面的命令搜索当前目录及其子目录中的文件，并输出含有ERROR内容的行详细答案及来源:How to find all files containing specific text on Linux? 20. Redis你用它来做什么? Redis在我接触过的项目中主要做了两件事: 缓存。 存储需要计算的信息。 Redis也可以用来做消息订阅、队列等。 21. Redis如果运行过程中崩溃了怎么办。这个问题我估摸着面试官想问的是Redis的数据保障的方法，不然崩溃了除了重启还能怎么办？ Redis有提供数据持久化的功能，一种是快照，一种是AOF。快照是在某一个时间点将所有数据写入到磁盘中，AOF是将被执行的命令复制到硬盘中，快照的文件体积要比AOF的文件体积小。前者在恢复时速度比后者快，但是因为是间隔持久化，所以会有一定量的数据丢失。后者因为是实时写入的，所以数据的完整性比较好，如果丢失的话一般也就丢失一秒的数据。 其次需要做主从复制，这样一份数据可以保存在多台服务器上，且可以避免Redis崩溃到重启完成这段时间内无法提供正常服务，同时从服务器可以分担主服务器的读压力。 22. Redis集群。没配置过所以没答上= = 相关连接: Redis集群教程。 23. 剩下的问题都是偏向个人的，没有什么通用性的回答，大概问了我: 前一家公司实习的时候主要做什么？ 讲一下做过的项目？ 项目中有没有遇到什么难点?怎么解决的？ 有没有做过什么有亮点的东西？其中在问题3根据我的回答，继续将情况复杂化让我给出解决方案，一步一步问。","categories":[],"tags":[]},{"title":"","slug":"Linux/openwrt/各种插件","date":"2018-03-31T18:24:19.000Z","updated":"2018-03-31T18:35:48.000Z","comments":true,"path":"2018/04/01/Linux/openwrt/各种插件/","link":"","permalink":"http://io.stelawliet.top/2018/04/01/Linux/openwrt/各种插件/","excerpt":"","text":"个人用的潘多拉大杂烩插件教程转载 2017年05月03日 19:42:40 2039 1.装adbyby 本地上传法： img 主机（路由器ip地址），账户（默认root)，密码(路由器管理密码），按照实际填写，可参考我的格式 img 完了就是登陆呗！路由器的IP地址，用户名，密码亲要是再不知道，就不用往下看了！ img 登陆成功！ img 右边是路由器的文件，左边是我电脑的东西，具体你们自己依照实际情况而定！毕竟软件版本各有不同，我也是第一次用，不敢妄加评论！点击右边的根目录，就会进入路由器主文件目录，个人觉得，但凡内存卡经常倒数据的机油，应该对文件夹不陌生吧？哈哈！ img 找到tmp文件夹，打开它然后将路由器插件（2个ipk文件）拽到tmp文件夹里面即可，我是拖拽过去的，一样！切记是2个啊，别落下了！放在tmp文件夹里面，不要放在tmp文件夹里面的文件夹的里面！ img 这三个搞进去了，就OK了，暂且把它最小化。第二步骤，搞掂！使用putty依次安装组件请下载后打开putty软件，别打开错了哈！ img 键入IP地址后，点击打开出现这个黑色背景，绿色光标界面！ img 重点来了：一定要稍等几秒，3五秒左右，会出现提示 img 此时，请键入用户名root， img 敲回车 img 出现此提示，是让你输入密码，就是路由器密码我键入密码后（无提示），切记，无任何显示！！你输入你的，输对就行，然后敲回车 img 出现此界面，说明正确了然后，依次安装组件：第一步 opkg –force-depends –force-overwrite install /tmp/3.ipk第二部 opkg –force-depends –force-overwrite install /tmp/2.ipk切记，这是2个ipk组件，需要按照顺序进行，先复制第一个，然后只需单击右键即可粘贴，然后，敲回车，等待两秒，出现提示，再粘贴第二个，再敲回车，都要有提示，后敲回车！ 不用putty安装方法 img 默默打开软件包找到adbyby 然后点安装。。 之后在启动项里找到adbyby点击启动 之后底部输入代码 cd binchmod 777 adbyby（改权限的）iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 8118/bin/./adbyby&amp;（开机自启用的）exit 0 直接网络下载法： 利用webshell傻瓜下载 img wget http://… 下载完之后直接搜索软件包安装，按照上面教程在启动项后面加传代码 2 用SS教程 有了SS账号后，如下图打开路由后台地址（192.168.1.1），用户名root密码admin，点击【系统】-【服务】-【shad0ws0cks】填入对应的服务器地址、服务器端口、密码、选择对应加密方式。Sock5代理勾选启动、本地端口1080透明代理勾选启动、透明代理本地端口1081、不选忽略内网ip列表、勾选Ip白名单、底下输入框填入对应ip（这个ip名单下载地址后面有）点击“保存&amp;应用” 这里写图片描述 2、如下图，点击【系统】-【服务】-【ChinaDns-c】，上游DNS服务器为114.114.114.114,8.8.4.4 端口1053中国路由表的内容和第1步中的Ip白名单内容一致，复制粘贴过来即可点击“保存&amp;应用” 这里写图片描述 3、如下图，点击【网络】-【DNS/DHCP】-【一般设置】，DNS转发填入 127.0.0.1#1053…【DNS/DHCP】-【HOSTS和解析文件】，勾选忽略解析文件点击“保存&amp;应用” 这里写图片描述 这里写图片描述 4、将电脑的DNS 设置为自动获取。并重启k1路由（【系统】-【重启】-执行重启）5、此时再进入路由器后台，【系统】-【服务】-【shad0ws0cks】，会看到页面内有文字提示：shad0ws0cks 运行中，说明已经配置成功！ 安装SS 用winscp上传shadowsocks.tar.gz到路由的tmp目录下。用putty或xshell登录路由执行命令cd /tmpgunzip shadowsocks.tar.gztar xvf shadowsocks.tar -C /rm shadowsocks.tar至此Shadowsocks安装完成，输入ss-local命令看是否有输出，如果看到帮助信息说明安装成功。 配置Shadowsocks账号用winscp登录路由，编辑/etc/shadowsocks.json 文件，修改里面的IP等信息{ “server”: “服务器IP”, “server_port”: “服务器端口”, “password”: “密码”, “local_port”: “本地端口”, “method”: “aes-256-cfb”, “timeout”: “600”}测试Shadowsocks输入下面的命令ss-local -c /etc/shadowsocks.json启动shadowsocks客户端好了，你现在可以在你的电脑浏览器用socks5方式代理上网了，代理IP要设置成你路由器的IP。端口设为本地端口比如1080，与上面的设置保持一致就行。设置路由器开机启动shadowsocks命令/etc/init.d/shadowsocks enable 还有一种最小白的安装方式，搜索软件包安装即可","categories":[],"tags":[]},{"title":"","slug":"Linux/openwrt/本地安装","date":"2018-03-31T15:53:18.000Z","updated":"2018-03-31T16:08:40.000Z","comments":true,"path":"2018/03/31/Linux/openwrt/本地安装/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/Linux/openwrt/本地安装/","excerpt":"","text":"openwrt ipk 软件包安装教程转载 2018年02月27日 16:11:11 标签： openwrt 378 转载自：http://www.openwrt.org.cn/bbs/thread-3238-1-1.html 方法一、web安装 img 系统－－》软件包先点更新软件包清单 img 填入软件包网址，然后点ok 方法二、ssh连接路由命令安装 或者用ssh软件PuTTY连接路由器 PuTTY下载地址: http://openwrt.8800.org:82/PuTTY_SSH_Telnet程序.rar opkg update opkg install 软件包网址 或者用winscp连接路由 然后上传包到/tmp/下 opkg update opkg install /tmp/xxx.ipk winscp（用于管理路由上的文件 类似FTP）OpenWrt+Linkit Smart 7688：在openwrt上用opkg安装本地ipk软件包 原创 2017年04月11日 16:15:25 标签： openwrt / opkg / ipk / mt7688 2454 硬件平台：Linkit Smart 7688 套件软件平台：OpenWrt 15.05安装工具：Winscp，SecureCRT操作系统：win7 64位ipk软件包：helloworld.ipk 这里对自己在win7上对openwrt上安装opk软件包的过程做一个记录，为什么做记录，因为根据网上的资料安装不进去。综合了一些资料，找出可以用的。也给大家一个参考。 Linkit Smart 7688上运行的是MTK官网（7688）针对Linkit Smart 7688的固件（lks7688）。 这里我就不介绍helloworld.ipk是怎么来的了，写一个helloworld的程序网络上很多。 第一步：工作环境准备1.1、Linkit Smart 7688上安装lks7688固件。这个固件是官网提供的。版本号v0.9.4 。lks7688固件是运行在openwrt系统的。这个不展开，不是主题。1.2、Linkit Smart 7688扩充底板和电脑连上网线。我这里是有开发板和扩充底板的，有些人估计没有扩充底板，这种可能就需要用笔记本这种有无线网卡的电脑，可以连上Linkit Smart 7688的AP网络，或者sta模式下连接同一个AP。不过没有试过，不知道可不可以。理论上应该是电脑和设备在局域网下就是可以的吧。 第二步：把helloworld.ipk上传到openwrt上。 使用Winscp来上传helloworld.ipk到openwrt上：1.1、打开Winscp，按照下面这样设置：1.1.1、文件协议：SCP1.1.2、主机名：就是Linkit Smart 7688的IP地址。这里是一个对Linkit Smart 7688评测，里写的很停清楚的。root和密码设置什么的 这里写图片描述 登录后： 这里写图片描述 左边是本地文件，可以看到有个helloworld_1.0_ramips_24kec.ipk，找到你的ipk软件包就好了。右边是openwrt的系统目录了。我直接就放在root下了。左边选中helloworld_1.0_ramips_24kec.ipk，点击上传。右边就会看到helloworld_1.0_ramips_24kec.ipk，重命名一下helloworld.ipk。也可以不改名字，随你。 这里写图片描述 第三步：把helloworld.ipk上传到openwrt上。. 这里其实我试过Putty的，登录上去了。但是不知道为什么安装不了。 打开：SecureCRT。这个应该会用吧。不清楚百度吧。就是用硬件就是串口接到Linkit Smart 7688的调试口上。启动后的界面如下： 这里写图片描述 输入 12ls12 可以看到helloworld.ipk，就是我们上传上去的。 输入 12opkg install helloworld.ipk12 就开始安装了。安装成功直接就输出了helloworld的字符了。 卸载就是输入： 12opkg remove helloworld12 好了。安装和卸载过程就是这个样了。 第二种方法：这种方法是我经常使用的，需要一个串口和网卡。如果你是开发板应该都有的。 开发板跑的是lks7688固件,其实不一定要他的固件，也可以是自己的编译出来的固件。根据MTK官网的说明编译出来的固件。为什么一定要这种固件呢。因为里面的写好了一个共享文件夹：/Media，在window下是可以直接访问的。 所以就以跑lks7688固件为例： 串口还是用SecureCRT打开，运行系统。网卡肯定要接上的：电脑的IP需要和Linkit7688的开发板需要在同一个网段。要么路由器设置为192.168.100.x，要么电脑和开发板直连吧。Linkit7688的开发板默认是192.168.100.1.可以使用 12ifconfig12 命令在操作台上查看， 这里写图片描述 这样在window上打开我的电脑/计算机，输入 12\\\\192.168.100.112 回车就可以看到/Media 这里写图片描述 然后就可以把这个文件夹映射上来，以后就直接打开就好了： 这里写图片描述 这里打开/Media文件夹后你发现不能复制文件到里面。那是因为没有修改权限，在SecureCRT上输入： 12chmod 777 /Media12 这样/Media的文件夹就可读可写。把xxx.ipk复制到这个文件夹下面。 在SecureCRT上输入 12ls /Media12 这样就能看到xxx.ipk文件了。也可以复制其他如音频.文本等你需要复制到上面的文件。 那就执行 12opkg install /Media/xxx.ipk12 就可以了安装成功了","categories":[],"tags":[]},{"title":"","slug":"Linux/openwrt/sas","date":"2018-03-31T15:49:38.000Z","updated":"2018-03-31T15:49:57.000Z","comments":true,"path":"2018/03/31/Linux/openwrt/sas/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/Linux/openwrt/sas/","excerpt":"","text":"潘多拉 路由器安装 SSR 方法 ON SEPTEMBER 3, 2017 BY ISTARBUCKSIN SSR 路由器安装 SSR 方法 作者：admin • 2017年05月23日 简介： 注：本文中的路由器型号为优酷L1，主控型号为MT7620a，固件为PandoraBox，安装过程中确保路由器能够联网。 软件包包含 shadowsocksr-libev 的可执行文件,以及luci控制界面 支持SSR客户端、服务端模式（服务端支持部分混淆模式、支持多端口） 支持自动分流，国内IP不走代理，国外IP段走透明代理，不需要再安装chnroute等软件 支持本地域名污染情况下的远程服务器解析，多数情况下无需对dns进行处理 可以和Shadowsocks共存，在openwrt可以通过luci界面切换使用Shadowsocks或ShadowsocksR 集成KcpTun加速，此功能对路由器性能要求较高，需下载对应的二进制文件到路由器指定目录，请酌情使用 客户端兼容运行SS或SSR的服务器，使用SS服务器时，传输协议需设置为origin，混淆插件需设置为plain 所有进程自动守护，崩溃后自动重启！首先使用浏览器登录路由器控制界面，依次找到：系统–软件包–配置，将原配置删除，填写以下配置并保存应用！（注：此配置仅适用于路由器主控为MT7620a/PandoraBox系列的固件！如果使用的是其他固件，请参考 这里 核对相应的软件源。） dest root / dest ram /tmp lists_dir ext /var/opkg-lists option overlay_root /overlay src/gz r2_base http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/base src/gz r2_management http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/management src/gz r2_oldpackages http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/oldpackages src/gz r2_packages http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/packages src/gz r2_routing http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/routing src/gz r2_telephony http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/telephony src/gz r2_oldpackages2 http://downloads.openwrt.org.cn/PandoraBox/ralink/mt7620_old/packages src/gz 16.10_base http://downloads.pandorabox.com.cn/pandorabox/packages/mt7620/packages/base src/gz 16.10_luci http://downloads.pandorabox.com.cn/pandorabox/packages/mt7620/packages/luci src/gz 16.10_packages http://downloads.pandorabox.com.cn/pandorabox/packages/mt7620/packages/packages 最新版SSR下载地址：https://github.com/ywb94/openwrt-ssr/releases （全部），或点此下载 （仅限MT7620）下载后打开压缩包，将压缩包内的文件/ramips/luci-app-shadowsocksR_版本号_all.ipk 提取到U盘根目录，然后将U盘插到路由器的USB接口；使用Telnet或SSH进入路由器(命令中的192.168.10.1为此路由器IP地址)：开始–运行，输入cmd并回车，输入：telnet 192.168.10.1，按提示输入用户名和密码后进入命令行终端模式：（注：如果提示“telnet不是内部或外部命令”，请查询 此网页 的图10和图11） echo “nameserver 114.114.114.114”&gt;/tmp/resolv.conf rm -f /var/lock/opkg.lock &amp;&amp; opkg update opkg install /mnt/sda1/luci-app-shadowsocksR_*_all.ipk (or URL of IPK) 安装完成后在浏览器登录路由器并设置SS或SSR帐号即可使用！注意：可以让SS和SSR同时运行，但是要注意使用的Socks5代理端口不能相同，并且最多只能有一个启用透明代理！","categories":[],"tags":[]},{"title":"","slug":"Linux/openwrt/yuan","date":"2018-03-31T15:49:04.000Z","updated":"2018-03-31T15:50:33.000Z","comments":true,"path":"2018/03/31/Linux/openwrt/yuan/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/Linux/openwrt/yuan/","excerpt":"","text":"四、一些资源 1）360p2用breed 文件名：“breed-mt7628-hiwifi-hc5661a.bin” 2）360p2潘多拉固件+一些插件 潘多拉群：【PandoraBox VIP玩家交流群】固件链接：http://downloads.pandorabox.com.cn/ 搜索安装插件小技巧 进入putty1、先更新源opkg update2、按照关键字搜索软件包名称替换命令中为你的关键字，命令已经忽略大小写opkg list |awk ‘BEGIN{IGNORECASE=1}//{print $1}’比如搜索s-sopkg list |awk ‘BEGIN{IGNORECASE=1}/s-s/{print $1}’3、你所熟知的opkg install .ipk了复制代码* img 3）360p2 改华硕老毛子固件，记住选则文件名“RT-AC1200-GPIO-38-7628”的固件 https://eyun.baidu.com/s/3kV0JV19 新软件源 src/gz 17.09_core http://pandorabox.beyang.cc/pandorabox/17.11/targets/ralink/mt7621/packages src/gz 17.09_base http://pandorabox.beyang.cc/pandorabox/17.11/packages/mipsel_1004kc_dsp/base src/gz 17.09_lafite http://pandorabox.beyang.cc/pandorabox/17.11/packages/mipsel_1004kc_dsp/lafite src/gz 17.09_luci http://pandorabox.beyang.cc/pandorabox/17.11/packages/mipsel_1004kc_dsp/luci src/gz 17.09_mtkdrv http://pandorabox.beyang.cc/pandorabox/17.11/packages/mipsel_1004kc_dsp/mtkdrv src/gz 17.09_newifi http://pandorabox.beyang.cc/pandorabox/17.11/packages/mipsel_1004kc_dsp/newifi src/gz 17.09_packages http://pandorabox.beyang.cc/pandorabox/17.11/packages/mipsel_1004kc_dsp/packages 使用方法：系统–软件包–配置–自定义软件源–粘帖以上内容–提交","categories":[],"tags":[]},{"title":"","slug":"Linux/openwrt/WIFI中继","date":"2018-03-31T14:42:19.000Z","updated":"2018-03-31T15:29:42.000Z","comments":true,"path":"2018/03/31/Linux/openwrt/WIFI中继/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/Linux/openwrt/WIFI中继/","excerpt":"","text":"设置开始：首先：192.168.1.1 登陆管理界面，密码：admin img img 按下图做，点搜索。已经测试，虽然5G信号也能搜索到，但是无法连接，原因不明，所以楼主还是中继了2.4G信号，有些遗憾~ img 找到你要中继的路由器 img 按下图设置，然后提交，提交完毕了再点”应用保存“ img 再次回到无线界面，看到如下信息没？就是你刚刚添加的中继路由 img 再看看你的路由器有没有得到主路由DHCP来的ip地址。 刚好潘多拉和小云os 1.6.1.5 不在一个网段~（我多余改成了192.168.88.1） img 好了~这样就设置完毕了~还是非常简单的`~ 本教程适合新鸟，老鸟忽略即可~","categories":[],"tags":[]},{"title":"","slug":"MD/Mac/Mac禁用摄像头","date":"2018-03-31T08:22:22.000Z","updated":"2018-03-31T08:27:43.000Z","comments":true,"path":"2018/03/31/MD/Mac/Mac禁用摄像头/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/MD/Mac/Mac禁用摄像头/","excerpt":"","text":"Mac关闭摄像头为了防止黑客入侵，我们可以手动执行命令，关掉摄像头设备的访问权限，让黑客去看黑夜吧。 Mac关闭禁用摄像头的方法，打开终端。 login root用户获得系统权限 1sudo -i 拷贝如下代码，回车，输入管理员密码，再次拷贝，回车。 123456789sudo chmod a-r /System/Library/Frameworks/CoreMediaIO.framework/Versions/A/Resources/VDC.plugin/Contents/MacOS/VDCsudo chmod a-r /System/Library/PrivateFrameworks/CoreMediaIOServicesPrivate.framework/Versions/A/Resources/AVC.plugin/Contents/MacOS/AVCsudo chmod a-r /System/Library/QuickTime/QuickTimeUSBVDCDigitizer.component/Contents/MacOS/QuickTimeUSBVDCDigitizersudo chmod a-r /Library/CoreMediaIO/Plug-Ins/DAL/AppleCamera.plugin/Contents/MacOS/AppleCamerasudo chmod a-r /Library/CoreMediaIO/Plug-Ins/FCP-DAL/AppleCamera.plugin/Contents/MacOS/AppleCamera 打开摄像头方法 123456789sudo chmod a+r /System/Library/Frameworks/CoreMediaIO.framework/Versions/A/Resources/VDC.plugin/Contents/MacOS/VDCsudo chmod a+r /System/Library/PrivateFrameworks/CoreMediaIOServicesPrivate.framework/Versions/A/Resources/AVC.plugin/Contents/MacOS/AVCsudo chmod a+r /System/Library/QuickTime/QuickTimeUSBVDCDigitizer.component/Contents/MacOS/QuickTimeUSBVDCDigitizersudo chmod a+r /Library/CoreMediaIO/Plug-Ins/DAL/AppleCamera.plugin/Contents/MacOS/AppleCamerasudo chmod a+r /Library/CoreMediaIO/Plug-Ins/FCP-DAL/AppleCamera.plugin/Contents/MacOS/AppleCamera 检验方法，使用Mac自带应用 Photo Booth 或者QQ视频来校验是否生效。 每次系统更新后要重新关闭一次","categories":[],"tags":[]},{"title":"","slug":"MD/site/实用网站1","date":"2018-03-31T06:34:03.000Z","updated":"2018-03-31T06:34:56.000Z","comments":true,"path":"2018/03/31/MD/site/实用网站1/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/MD/site/实用网站1/","excerpt":"","text":"实用的工具网站 总结一下平时可能会用到的工具性网站，欢迎补充。 Regex101 - online regex editor and debugger强大的正则表达式工具，你可以实时查看匹配信息，并且会用不同的颜色将 Group 标记出来。而且有 Quick Reference 来帮助你记忆正则表达式的规则和 Explanation 对你的正则表达式进行解释。重要的是，支持直接生成多种语言的代码。 file file Compressor.io（需要翻墙）强大的图片在线压缩工具，支持JPEG、PNG、GIF、SVG，在保证超高压缩率的同时保证肉眼看不出与原图的差别。（下图：1.07 MB 的图片压缩变成171.41 KB，而视觉效果几乎没有变化。） file TinyPNG同样是图片压缩工具，虽然只支持JPEG、PNG，但是这个不需要翻墙，效果也非常棒。 file VisuAlgo（多语言支持）各种算法可视化，我的多动态图详细讲解二叉搜索树 用的动态图片就是用它做的。 image Desmos Graphing Calculator非常强大的在线作图工具，而且支持动画（支持函数动态变化），界面也非常简洁耐看，我的循环神经网络（Recurrent Neural Network）简介 最后的图片就是用它做的。 file Math在线计算器，可以识别手写的复杂表达式，而且画出函数图像，支持导出为Latex、MathML、SymbolTree等格式。 file Latex2png将 Latex 表达式转换为漂亮的、透明的 PNG 图片，很实用的网站。 file Smallpdf和 PDF 转换有关的操作它都有，而且非常准确。支持哪些？看图片（多语言支持）： file ASCIIFlow InfinityAscii 作图工具，很强大。 1234567891011121314151617Copy+--------+ +---------------+| +-+(A)+ Authorization Request +^+ Resource || | | Owner || +^+(B)++ Authorization Grant +--+ || | +---------------+| || | +---------------+| +-+(C)++ Authorization Grant +-^+ Authorization || Client | | Ser^er || +^+(D)+---+ Access Token +------+ || | +---------------+| || | +---------------+| +-+(E)+---+ Access Token +-----^+ Resource || | | Ser^er || +^+(F)+-+ Protected Resource +--+ |+--------+ +---------------+ file CloudConvert - Conversion Types又一个格式转换网站，太强大了，你能想到的格式转换几乎都有： file Mathcha强大的数学表达式在线编辑工具，可以导出为PDF、Latex等格式。 file ⬆️","categories":[],"tags":[]},{"title":"","slug":"Linux/ssh/mac ssh设置","date":"2018-03-31T06:29:07.000Z","updated":"2018-03-31T08:10:10.000Z","comments":true,"path":"2018/03/31/Linux/ssh/mac ssh设置/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/Linux/ssh/mac ssh设置/","excerpt":"","text":"1、准备ssh-copy-idbrew install ssh-copy-id 2、生成密钥。在终端下执行命令：ssh-keygen -t rsa一路回车，各种提示按默认不要改，等待执行完毕。 3、运行 :ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.6.161","categories":[],"tags":[]},{"title":"","slug":"Linux/ssh/ssh 登录别名与密钥设置","date":"2018-03-31T05:09:56.000Z","updated":"2018-05-12T15:53:45.000Z","comments":true,"path":"2018/03/31/Linux/ssh/ssh 登录别名与密钥设置/","link":"","permalink":"http://io.stelawliet.top/2018/03/31/Linux/ssh/ssh 登录别名与密钥设置/","excerpt":"","text":"SSH别名原创 2015年05月31日 00:07:20 在Mac OS的终端(terminal)中，可以使用命令ssh user@host的命令来远程连接一台服务器，但是，如果要管理的服务器太多，IP地址不能全部记住的时候怎么办？这时候我们可以为每一台服务器设置一个别名（alias），使用vi命令编辑一下~/.ssh/config这个文件（如果目录下没有这个文件，可以新建一个），接着按下面格式添加内容： 1234567891011# 服务器1Host 别名 HostName IP地址 Port 22 User 用户名# 服务器2Host 别名 HostName IP地址 Port 22 User 用户名更多的服务器...1234567891011 添加完以上内容后，就可以使用命令ssh 服务器别名来连接服务器了，是不是方便很多了？ 另外，如果想查看当前有哪些配置了别名的服务器，可以使用命令cat ~/.ssh/config | grep &quot;Host&quot;来查看 SSH公钥和密钥使用场景？ linux 无密login git 无密push ssh有啥？ssh中，有两个钥匙：公钥、私钥 ,公钥主要是用于对一些敏感信息进行加密 ， 私钥是用于对解密 。 ssh的文件都存在于机器的~/.ssh中。 客户机端：id_rsa(私钥) 、 id_rsa.pub(公钥) 、 known_hosts(已知远程主机) 服务器端：authorized_keys(验证过的公钥列表) 、 sshd_config(ssh配置文件) linux 无密loginlinux的远程登录默认是需要密码的，但是我们可以通过ssh通道，进行无密登录，也就是说每次登录只需要 ssh username@host 就能成功登录远程机器。 *下面是无密登录的完整过程： 客户机使用ssh-keygen生成密钥对（私密id_rsa、公密id_rsa.pub）。 复制公密id_rsa.pub的内容 1$ pbcopy &lt; ~/.ssh/id_rsa.pub 使用ssh登录到远程机器（这次需要密码） 1$ ssh root@host //root：帐号 ， host ：服务器IP地址 把剪切版的内容粘贴到~/.ssh/authorized_keys中，退出登录 1$ exit ，基础已经搭建完了，使用ssh无密登录（不需要密码） 1&gt; 如果发现无法自动登录，请修改 $ vi /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 把以上的最前面的＃去掉 。 $ service ssh restart $ exit 重新登录 1234$ ssh root@192.168.1.1The authenticity of host &apos;192.168.1.1 (192.168.1.1)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:8bZUeFxyoxL9oYhc5aAZjgSZ5CT1oGYEYoehN/OLEYY.Are you sure you want to continue connecting (yes/no)? 因为这是第一次登录，ssh无法判断远程的服务端是否是正确的，在这里如果有人中间截获了你的登录请求，并且模拟ssh服务端的话，你的密码就会泄漏（中间人攻击），所以ssh会询问你：远程服务端的指纹是：xxxx，是不是确定登录。 选择yes，ssh会把该服务端的信息存到本地的~/.ssh/known_hosts文件中，那么下次登录就不会再询问了。 这时候服务端会使用公钥对A字符串加密，然后传输到客户端，客户端使用私钥进行解密，得到的A字符串，然后对A字符串进行md5加密，服务端判断传回来的字符串是否正确，如果正确，直接登录。","categories":[],"tags":[]},{"title":"","slug":"Linux/shdaowsocks/kcp-server","date":"2018-03-30T12:26:32.000Z","updated":"2018-07-04T11:48:52.000Z","comments":true,"path":"2018/03/30/Linux/shdaowsocks/kcp-server/","link":"","permalink":"http://io.stelawliet.top/2018/03/30/Linux/shdaowsocks/kcp-server/","excerpt":"","text":"KCP-Server##作为kcptun的搬运工，我只是提供了一键安装脚本，至于使用的原理啊、功能啊、bug啊请各位移步到kcptun项目，我真的无能为力。 ##感谢kcptun提供这么优秀的软件 kcptun是kcp协议的一个简单应用，可以用于任意tcp网络程序的传输承载，以提高网络流畅度，降低掉线情况。 脚本是业余爱好，英文属于文盲，写的不好，不要笑话我，欢迎您批评指正。 安装平台：CentOS、Debian、Ubuntu。 注意：安装脚本2.0版本之前的请卸载后重新安装！！！ServerInstall123wget --no-check-certificate https://github.com/clangcn/kcp-server/raw/master/install-kcp-server.sh -O ./install-kcp-server.shchmod 500 ./install-kcp-server.sh./install-kcp-server.sh install UnInstall1./install-kcp-server.sh uninstall Update1./install-kcp-server.sh update 服务器管理1Usage: /etc/init.d/kcp-server &#123;start|stop|restart|status&#125;","categories":[],"tags":[]},{"title":"KCP和SS脚本","slug":"Linux/shdaowsocks/SS和Kcp脚本","date":"2018-03-30T11:52:51.000Z","updated":"2018-07-04T11:50:50.000Z","comments":true,"path":"2018/03/30/Linux/shdaowsocks/SS和Kcp脚本/","link":"","permalink":"http://io.stelawliet.top/2018/03/30/Linux/shdaowsocks/SS和Kcp脚本/","excerpt":"","text":"Centos安装ShadowSocks123wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.shchmod +x shadowsocks-libev.sh./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 操作命令 使用命令：启动：/etc/init.d/shadowsocks start |stop|restart|status KCPTUN加速123wget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.shchmod +x ./kcptun.sh./kcptun.sh 防火墙启动firewall-cmd –zone=public –add-port=44444/tcp –permanent","categories":[{"name":"Linux","slug":"Linux","permalink":"http://io.stelawliet.top/categories/Linux/"},{"name":"VPS","slug":"Linux/VPS","permalink":"http://io.stelawliet.top/categories/Linux/VPS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://io.stelawliet.top/tags/linux/"},{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"http://io.stelawliet.top/tags/ShadowSocks/"},{"name":"Kcptun","slug":"Kcptun","permalink":"http://io.stelawliet.top/tags/Kcptun/"}]},{"title":"","slug":"JavaScript/node/module.exports&exports区别","date":"2018-03-29T14:53:06.000Z","updated":"2018-03-29T14:55:14.000Z","comments":true,"path":"2018/03/29/JavaScript/node/module.exports&exports区别/","link":"","permalink":"http://io.stelawliet.top/2018/03/29/JavaScript/node/module.exports&exports区别/","excerpt":"","text":"Module.exports和exports的区别一、官方解释因为SeaJs和Nodejs都是基于CommonJS,所以直接看的Node的官方文档解释 Module.exports The module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what you want to do. 译文：module.exports对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给module.exports。 注意，将期望的对象赋值给exports会简单地重新绑定到本地exports变量上，这可能不是你想要的。 exports The exports variable is available within a module’s file-level scope, and is assigned the value of module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = … can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports: 译文：exports变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。它有一个快捷方式，以便 module.exports.f = … 可以被更简洁地写成exports.f = …。 注意，就像任何变量，如果一个新的值被赋值给exports，它就不再绑定到module.exports(其实是exports.属性会自动挂载到没有命名冲突的module.exports.属性) require从require导入方式去理解，关键有两个变量(全局变量module.exports，局部变量exports)、一个返回值(module.exports) 12345678910111213141516function require(...) &#123; var module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // 你的被引入代码 Start // var exports = module.exports = &#123;&#125;; (默认都有的) function some_func() &#123;&#125;; exports = some_func; // 此时，exports不再挂载到module.exports， // export将导出&#123;&#125;默认对象 module.exports = some_func; // 此时，这个模块将导出some_func对象，覆盖exports上的some_func // 你的被引入代码 End &#125;)(module, module.exports); // 不管是exports还是module.exports，最后返回的还是module.exports return module.exports;&#125; 二、Demo事例事例一：1.js123456789101112131415161718console.log(exports); // &#123;&#125; console.log(module.exports); // &#123;&#125; console.log(exports === module.exports); // true console.log(exports == module.exports); // true /** Module &#123; id: &apos;.&apos;, exports: &#123;&#125;, parent: null, filename: &apos;/1.js&apos;, loaded: false, children: [], paths: [ &apos;/node_modules&apos; ] &#125; */console.log(module); 从事例一中，可以看出来 1.每个js文件一创建，都有一个var exports = module.exports = {};，使exports和module.exports都指向一个空对象。 2.module是全局内置对象，exports是被var创建的局部对象。 3.module.exports和exports所指向的内存地址相同 事例二：2.js、3.js12345678910111213141516// 2.jsexports.id = &apos;exports的id&apos;; exports.id2 = &apos;exports的id2&apos;; exports.func = function()&#123; console.log(&apos;exports的函数&apos;);&#125;;exports.func2 = function() &#123; console.log(&apos;exports的函数2&apos;);&#125;;module.exports = &#123; id: &apos;module.exports的id&apos;, func:function()&#123; console.log(&apos;module.exports的函数&apos;); &#125;&#125;; 12345678910111213// 3.jsvar a = require(&apos;./2.js&apos;); // 当属性和函数在module.exports都有定义时：console.log(a.id); // module.exports的id console.log(a.func()); // module.exports的函数// 当属性在module.exports没有定义，函数在module.exports有定义console.log(a.id2); // undefined console.log(a.func()); // module.exports的函数// 当函数在module.exports没有定义，属性在module.exports有定义console.log(a.id); // module.exports的id console.log(a.func2()); // 报错了 TypeError: a.func2 is not a function 由例二可以知道： 1.module.exports像是exports的大哥，当module.exports以{}整体导出时会覆盖exports的属性和方法， 2.注意，若只是将属性/方法挂载在module.exports./exports.上时，exports.id=1和module.exports.id=100，module.exports.id=function(){}和exports.id=function(){}，最后id的值取决于exports.id和module.exports.id的顺序，谁在后，就是最后的值 3.若exports和module.exports同时赋值时，exports所使用的属性和方法必须出现在module.exports，若属性没有在module.exports中定义的话，出现undefined，若方法没有在module.exports中定义，会抛出TypeError错误。 例三 4.js、5.jsmodule.exports的对象、prototype、构造函数使用 12345678// 4.jsvar a = require(&apos;./5.js&apos;); // 若传的是类，new一个对象var person = new a(&apos;Kylin&apos;,20); console.log(person.speak()); // my name is Kylin ,my age is 20// 若不需要在构造函数时初始化参数，直接调用方法/属性// a.speak(); // my name is kylin ,my age is 20 12345678910111213141516// 5.js// Person类function Person(name,age)&#123; this.name = name; this.age = age;&#125;// 为类添加方法Person.prototype.speak = function()&#123; console.log(&apos;my name is &apos;+this.name+&apos; ,my age is &apos;+this.age);&#125;;// 返回类module.exports = Person;// 若构造函数没有传入参数(name,age)，直接传入对象// module.exports = new Person(&apos;kylin&apos;,20); 说了这么多，其实建议就是，如果只是单一属性或方法的话，就使用exports.属性/方法。要是导出多个属性或方法或使用对象构造方法，结合prototype等，就建议使用module.exports = {}。文章有很多地方描述的可能不是很准确，提到的点也不够全面，如果有不对的地方，还望斧正！ 参考资料：Nodejs官方文档(中文)、Node.js Module – exports vs module.exports、Understanding module.exports and exports in Node.js、exports 和 module.exports 的区别 转载请注明：信鑫-King’s Blog » Module.exports和exports的区别","categories":[],"tags":[]},{"title":"","slug":"Linux/ftp实例","date":"2018-03-28T08:32:11.000Z","updated":"2018-05-04T13:17:52.000Z","comments":true,"path":"2018/03/28/Linux/ftp实例/","link":"","permalink":"http://io.stelawliet.top/2018/03/28/Linux/ftp实例/","excerpt":"","text":"使用实例：利用编写 ftp 脚本可以自动完成文件传输任务。具体方法是使用 ftp 命令的 -in 选项，并重定向 ftp 命令的输入。现在我们来编写一个利用 ftp 登录到远程服务器，并以 bin 的文件格式，在 /home 目录下，下载 file1.log 以及 file2.sh 至本机 /opt/ibm/，并从本地 /opt 目录上传文件 file3.jave 至远程服务器 /home 的自动化脚本。 1234567891011ftp -ni &lt;&lt;+ open $IP user $USERNAME $PASSWD bin cd /home lcd /opt/ibm mget file1.log file2.sh lcd /opt mput file3.jave ls bye","categories":[],"tags":[]},{"title":"","slug":"Linux/shdaowsocks/kcptun","date":"2018-03-28T05:29:40.000Z","updated":"2018-03-28T05:29:40.000Z","comments":true,"path":"2018/03/28/Linux/shdaowsocks/kcptun/","link":"","permalink":"http://io.stelawliet.top/2018/03/28/Linux/shdaowsocks/kcptun/","excerpt":"","text":"kcptun shadowsocks加速方案转载 2017年02月17日 11:42:59 标签： kcptun 9825 原文连接：https://blog.kuoruan.com/102.html Kcptun介绍 Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 Kcptun 是 KCP 协议的一个简单应用，可以用于任意 TCP 网络程序的传输承载，以提高网络流畅度，降低掉线情况。由于 Kcptun 使用 Go 语言编写，内存占用低（经测试，在64M内存服务器上稳定运行），而且适用于所有平台，甚至 Arm 平台。 Kcptun 工作示意图： [ 小内存福音，Kcptun Shadowsocks加速方案 - 第1张 | 扩软博客](https://blog.kuoruan.com/wp-content/uploads/2016/06/kcptun-550x159.png) KCP 协议：https://github.com/skywind3000/kcp Kcptun 项目地址：https://github.com/xtaci/kcptun 2016.08.31 v20160831发布，新版支持配置文件！ 2016.08.29 新的客户端可视化配置工具可选 2016.08.13 发布一键安装脚本 https://blog.kuoruan.com/110.html 2016.08.06 添加Kcptun可视化运行工具和Android使用说明。 2016.06.17 添加客户端开机自启批处理，重写软件启动vbs脚本。 相关项目以下为 Kcptun 的相关项目，如果有兴趣，可以了解一下。 1.Kcp-server：https://github.com/clangcn/kcp-server Kcp-server 是在 Kcptun 的基础上，添加了配置文件的支持，并整合了一个socks5代理，可用不用配合其他软件单独使用，而原版 Kcptun 需要配合其他软件使用而不能单独使用。Kcp-server 简化了安装过程，一条命令即可配置完毕。 2.Shadowsocks-Plus：https://github.com/shadowsocks-plus/shadowsocks-plus 基于 Shadowsocks Go 版本，加入了以下特性： 启动后降低权限至 nobody , 增强安全性； 与 kcptun 集成，配合相应客户端可加速传输； 网页控制面板。 部署Kcptun现在博主编写的一键安装脚本已公开发布测试，支持 Kcptun 一键安装、更新、卸载、配置，欢迎测试使用：Kcptun 服务端一键安装脚本 点击这里查看手动配置方式 响应速度： fast3 &gt; [fast2] &gt; fast &gt; normal &gt; default 有效载荷比： default &gt; normal &gt; fast &gt; [fast2] &gt; fast3 中间 mode 参数比较均衡，总之就是越快越浪费带宽（根据设置，可能会浪费数倍流量），请自行斟酌。推荐模式 fast2。 可用的参数请使用 ./server_linux_amd64 -h 查看： 12345678910111213141516171819202122232425262728 ./server_linux_amd64-hNAME: kcptun-kcptunserver USAGE: server_darwin_amd64[globaloptions]command[commandoptions][arguments…] VERSION: 20160820 COMMANDS: help,h Showsalistofcommandsorhelpforonecommand GLOBALOPTIONS: –listenvalue,-lvalue kcpserverlistenaddress(default:”:29900”) –targetvalue,-tvalue targetserveraddress(default:”127.0.0.1:12948”) –keyvalue pre-sharedsecretforclientandserver(default:”it’s a secrect”)[$KCPTUN_KEY] –cryptvalue aes,aes-128,aes-192,salsa20,blowfish,twofish,cast5,3des,tea,xtea,xor,none(default:”aes”) –modevalue profiles:fast3,fast2,fast,normal(default:”fast”) –mtuvalue setmaximumtransmissionunitofUDPpackets(default:1350) –sndwndvalue setsendwindowsize(numofpackets)(default:1024) –rcvwndvalue setreceivewindowsize(numofpackets)(default:1024) –datashardvalue setreed-solomonerasurecoding-datashard(default:10) –parityshardvalue setreed-solomonerasurecoding-parityshard(default:3) –dscpvalue setDSCP(6bit)(default:0) –nocomp disablecompression –help,-h showhelp –version,-v printtheversion 更深层次的参数调整需要理解 KCP 协议，并通过“隐藏参数”调整。巭孬嫑乱动 下面是作者给的配置参数样例，适用大部分ADSL接入（非对称上下行）的参数（实验环境电信100M ADSL）。其它带宽请按比例调整，比如 50M ADSL，把 CLIENT 的 -sndwnd -rcvwnd 减掉一半，SERVER 不变。 12 服务端: -mtu1400-sndwnd2048-rcvwnd2048-modefast2客户端: -mtu1400-sndwnd256-rcvwnd2048-modefast2-dscp46 在不丢包的情况下，有最大-rcvwnd 个数据包在网络上正在向你传输，以平均数据包大小avgsize计算，在任意时刻，有： network_cap = rcvwnd*avgsize 数据流向你，这个值再除以ping值(rtt)，等于最大带宽使用量。 max_bandwidth = network_cap/rtt = rcvwnd*avgsize/rtt 举例，设rcvwnd = 1024, avgsize = 1KB, rtt = 400ms，则： max_bandwidth = 1024 * 1KB / 400ms = 2.5MB/s ~= 25Mbps （注：以上计算不包括前向纠错的数据量） 前向纠错是最大带宽量的一个固定比例增加： max_bandwidth_fec = max_bandwidth*(datashard+parityshard)/datashard 举例，设datashard = 10 , partiyshard = 3，则： max_bandwidth_fec = max_bandwidth (10 + 3) /10 = 1.3max_bandwidth ＝ 1.3 * 25Mbps = 32.5Mbps 看不懂？那就别管它，你只要会简易自我调优方法就够了： 同时在两端逐步增大 client rcvwnd 和 server sndwnd; 尝试下载，观察如果带宽利用率（服务器＋客户端两端都要观察）接近物理带宽则停止，否则跳转到第一步。 基本原则：SERVER 的发送速率不能超过 ADSL 下行带宽，否则只会浪费您的服务器带宽。 如果你有任何问题，欢迎加入我们的QQ群寻求帮助：43391448 配置客户端首先下载 Kcptun 的客户端文件。 请注意：客户端版本建议和服务端版本一致，有许多朋友没有检查两端造成无法连接！ Windows 64位： 1 https://github.com/xtaci/kcptun/releases/download/v20161031/kcptun-windows-amd64-20161031.tar.gz Mac 64位： 1 https://github.com/xtaci/kcptun/releases/download/v20161031/kcptun-darwin-amd64-20161031.tar.gz 注意： 1.0830以后的版本不和之前的版本兼容，请确保两端使用相同的版本！ 2.下面的软件截图仅供选择软件时参考，请不要照着填写里边的参数！ 当前，Kcptun 已经有可视化配置工具了，你可以自行选择使用。如果不想用工具，可以往后翻，手动创建启动文件。 1.Kcptun客户端配置管理工具，来自 @dfdragon [ 小内存福音，Kcptun Shadowsocks加速方案 - 第3张 | 扩软博客](https://blog.kuoruan.com/wp-content/uploads/2016/06/kcptun-gui-1-550x330.jpg) 下载地址：https://github.com/dfdragon/kcptun_gclient/releases 2.kcptun-gui-windows，来自 @GangZhuo [ 小内存福音，Kcptun Shadowsocks加速方案 - 第4张 | 扩软博客](https://blog.kuoruan.com/wp-content/uploads/2016/06/kcptun-gui-windows-550x403.png) 下载地址：https://github.com/GangZhuo/kcptun-gui-windows/releases 3.来自“逗比根据地”的 Kcptun tools。由于软件是易语言编写的，可能会被杀毒软件报毒，请各位自行查毒。 [ 小内存福音，Kcptun Shadowsocks加速方案 - 第5张 | 扩软博客](https://blog.kuoruan.com/wp-content/uploads/2016/06/Kcptun_tools.png) 软件说明：http://www.dou-bi.com/ss-jc37/ 软件下载地址：https://pan.baidu.com/s/1i5HdlVv 4.KcptunGUI，来自“诸神的黄昏”。 [ 小内存福音，Kcptun Shadowsocks加速方案 - 第6张 | 扩软博客](https://blog.kuoruan.com/wp-content/uploads/2016/06/Kcptun-gui-550x280.png) 源码地址：https://git.oschina.net/ragnaroks/KcptunGUI 软件下载：https://git.oschina.net/ragnaroks/KcptunGUI/releases Mac 系统可以下载使用：https://github.com/dfdragon/kcptun_xclient/releases 注意：客户端和服务端参数必须一致的有: datashard parityshard nocomp key crypt 点击查看手动创建启动文件的方法 上面的配置过程中出现了多个端口，我在这里画个图，方便各位理解各端口的作用（点击看大图）： [ 小内存福音，Kcptun Shadowsocks加速方案 - 第7张 | 扩软博客](https://blog.kuoruan.com/wp-content/uploads/2016/06/Kcptun_ports.png) Shadowsocks 客户端配置在客户端中新建服务器： 服务器 IP 填写本机：127.0.0.1 服务器端口填写：12948 正确填写你的 Shadowsocks 密码，加密方式，协议和混淆方式。 切换到该服务器上，测试是否正确运行。 速度实测我用的服务器是搬瓦工 512M 内存，费利蒙机房，以此测试加速效果。 按结论看，Kcptun 的加速效果略逊于 Finalspeed，估计需要细调配置。 刚运行 Finalspeed 时，内存占用就达到了 9.1% 也就是接近 47M；而此时 Kcptun 占用 0.4%，也就是 2M左右。 YouTube 1440p 满跑情况下，FInalspeed 最高内存占用 15.4%，接近 79M；而此时 Kcptun 占用 3% 左右，即 15.5M。 速度方面，Finalspeed 最大速度达到了10000 Kbps +，Kcptun 6000+ Kbps。 以上结论为本人测试所得，仅作为参考；实际情况请自行测试，如有纰漏，欢迎指出。 多人同时使用如果想多人使用同一个服务器并同时使用 Kcptun 加速，需要启动多个 Kcptun 进程： 1.你使用的是本站的一键安装脚本，请使用命令： 1 ./kcptun.shadd 来添加一个新实例，新 Kcptun 实例使用的端口需要与其他实例不一致。 2.你是自己创建的启动脚本： 为了启动多个 Kcptun 服务端，你可以将 start.sh 拷贝一份，然后修改其中的 Kcptun 运行端口。 Android上使用请看这篇文章：Shadowsocks-Android客户端上的KCP配置说明 在路由器上使用如果需要在路由器上使用 Kcptun，首先你得有个智能路由器，然后能进入shell。 编译好的客户端文件在这里下载： https://github.com/bettermanbao/openwrt-kcptun/releases 小米路由器、极路由等一大批国产智能路由器都是 MT7620 的芯片，请下载 ramips 版本。","categories":[],"tags":[]},{"title":"","slug":"Linux/muti","date":"2018-03-27T12:43:22.000Z","updated":"2018-03-27T12:44:01.000Z","comments":true,"path":"2018/03/27/Linux/muti/","link":"","permalink":"http://io.stelawliet.top/2018/03/27/Linux/muti/","excerpt":"","text":"默认配置 服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）密码：自己设定（如不设定，默认为 teddysun.com）加密方式：自己设定（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb）协议（protocol）：自己设定（如不设定，默认为 origin）（仅限 ShadowsocksR 版）混淆（obfs）：自己设定（如不设定，默认为 plain）（仅限 ShadowsocksR 版）备注：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。 客户端下载 常规版 Windows 客户端https://github.com/shadowsocks/shadowsocks-windows/releases ShadowsocksR 版 Windows 客户端https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases 使用方法 使用root用户登录，运行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 安装完成后，脚本提示如下 Congratulations, your_shadowsocks_version install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_method Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)ss://your_encryption_method:your_password@your_server_ip:your_server_portYour QR Code has been saved as a PNG file path:your_path.png Welcome to visit:https://teddysun.com/486.htmlEnjoy it! 卸载方法 若已安装多个版本，则卸载时也需多次运行（每次卸载一种） 使用root用户登录，运行以下命令： 1./shadowsocks-all.sh uninstall 启动脚本 启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。 Shadowsocks-Python 版：/etc/init.d/shadowsocks-python start | stop | restart | statusShadowsocksR 版 ：/etc/init.d/shadowsocks-r start | stop | restart | statusShadowsocks-Go 版 ：/etc/init.d/shadowsocks-go start | stop | restart | statusShadowsocks-libev 版 ：/etc/init.d/shadowsocks-libev start | stop | restart | status 各版本默认配置文件 Shadowsocks-Python 版：/etc/shadowsocks-python/config.jsonShadowsocksR 版 ：/etc/shadowsocks-r/config.jsonShadowsocks-Go 版 ：/etc/shadowsocks-go/config.jsonShadowsocks-libev 版 ：/etc/shadowsocks-libev/config.json","categories":[],"tags":[]},{"title":"","slug":"Linux/ssh/ssr-py","date":"2018-03-27T12:42:27.000Z","updated":"2018-03-28T06:54:59.000Z","comments":true,"path":"2018/03/27/Linux/ssh/ssr-py/","link":"","permalink":"http://io.stelawliet.top/2018/03/27/Linux/ssh/ssr-py/","excerpt":"","text":"Shadowsocks for Windows 客户端下载：https://github.com/shadowsocks/shadowsocks-windows/releases 使用方法：使用root用户登录，运行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完成后，脚本提示如下： Congratulations, Shadowsocks-python server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_method Welcome to visit:http://teddysun.com/342.htmlEnjoy it! 卸载方法：使用root用户登录，运行以下命令： 1./shadowsocks.sh uninstall 单用户配置文件示例（2015 年 08 月 28 日修正）：配置文件路径：/etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例（2015 年 08 月 28 日修正）：配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 使用命令（2015 年 08 月 28 日修正）：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:55555, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;root1234&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;:false&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/mybaits逆向工程example","date":"2018-03-25T07:52:31.000Z","updated":"2018-03-25T07:55:59.000Z","comments":true,"path":"2018/03/25/Java/JavaEE/Java框架/mybaits逆向工程example/","link":"","permalink":"http://io.stelawliet.top/2018/03/25/Java/JavaEE/Java框架/mybaits逆向工程example/","excerpt":"","text":"mybatis的逆向工程中创建的以Example类的作用在平常的开发中，有时会使用mybatis的逆向工程，来快速的创建类，其中在创建实例的过程中有一个以Example结尾的类，这个类是专门用来对这个单表来查询的类，就相当于，对该单表的增删改查是脱离sql性质的，直接在service层就可以完成（当然这个sql是逆向已经生过的） 例如： select id, username, birthday, sex, address from user WHERE ( username = ‘张三’ ) order by username asc 123456789101112131415@Test public void testFindUserByName()&#123; //通过criteria构造查询条件 UserExample userExample = new UserExample(); userExample.setOrderByClause(\"username asc\"); //asc升序,desc降序排列 userExample.setDistinct(false); //去除重复,true是选择不重复记录,false反之 UserExample.Criteria criteria = userExample.createCriteria(); //构造自定义查询条件 criteria.andUsernameEqualTo(\"张三\"); //自定义查询条件可能返回多条记录,使用List接收 List&lt;User&gt; users = userMapper.selectByExample(userExample); System.out.println(users); &#125; 1234567891011121314151617181920212223242526272829303132Mybatis逆向工程会生成实例及实例对应的example（用于添加条件，相当于where后的部分）xxxExample example = new xxxExample();Criteria criteria = example.createCriteria();方法说明：// 1.添加升序排列条件，DESC为降序example.setOrderByClause(\"字段名ASC\")// 2.去除重复，boolean类型，true为选择不重复的记录example.setDistinct(false)// 3.添加字段xxx为null的条件criteria.andXxxIsNull// 4.添加字段xxx不为null的条件criteria.andXxxIsNotNull// 5.添加xxx字段等于value条件criteria.andXxxEqualTo(value)// 6.添加xxx字段不等于value条件criteria.andXxxNotEqualTo(value)// 7.添加xxx字段大于value条件criteria.andXxxGreaterThan(value)// 8.添加xxx字段大于等于value条件criteria.andXxxGreaterThanOrEqualTo(value)// 9.添加xxx字段小于value条件criteria.andXxxLessThan(value)// 10.添加xxx字段小于等于value条件criteria.andXxxLessThanOrEqualTo(value)// 11.添加xxx字段值在Listcriteria.andXxxIn(List)// 12.不添加xxx字段值在Listcriteria.andXxxNotIn(List)// 13.添加xxx字段值在之间criteria.andXxxBetween(value1,value2)// 14.添加xxx字段值不在之间criteria.andXxxNotBetween(value1,value2)","categories":[],"tags":[]},{"title":"mybatis逆向工程配置","slug":"Java/JavaEE/mybatis逆向工程配置","date":"2018-03-24T15:59:00.000Z","updated":"2018-07-04T11:18:20.000Z","comments":true,"path":"2018/03/24/Java/JavaEE/mybatis逆向工程配置/","link":"","permalink":"http://io.stelawliet.top/2018/03/24/Java/JavaEE/mybatis逆向工程配置/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项​ resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties ​ url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.​ 注意，两个属性只能选址一个;​ ​ 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包​ location属性指明加载jar/zip包的全路径&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt; --&gt;&lt;!-- ​ context:生成一组对象的环境 ​ id:必选，上下文id，用于在生成错误时提示​ defaultModelType:指定生成对象的样式​ 1，conditional：类似hierarchical；​ 2，flat：所有内容（主键，blob）等全部生成在一个对象中；​ 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)​ targetRuntime:​ 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；​ 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；​ introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;​ &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；​ 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖​ --&gt;​ &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;​ &lt;!-- 生成的Java文件的编码 --&gt;​ &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;​ &lt;!-- 格式化java代码 --&gt;​ &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;​ &lt;!-- 格式化XML代码 --&gt;​ &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;​ ​ &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;​ &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;​ &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;​ ​ &lt;!-- 必须要有的，使用这个配置链接数据库​ @TODO:是否可以扩展​ --&gt;​ &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;​ &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;​ &lt;/jdbcConnection&gt;​ ​ &lt;!-- java类型处理器 ​ 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；​ 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； ​ --&gt;​ &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;​ &lt;!-- ​ true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型​ false：默认,​ scale&gt;0;length&gt;18：使用BigDecimal;​ scale=0;length[10,18]：使用Long；​ scale=0;length[5,9]：使用Integer；​ scale=0;length&lt;5：使用Short；​ --&gt;​ &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;​ &lt;/javaTypeResolver&gt;​ ​ ​ &lt;!-- java模型创建器，是必须要的元素​ 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类​ targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；​ targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录​ --&gt;​ &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;​ &lt;!-- for MyBatis3/MyBatis3Simple​ 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；​ --&gt;​ &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;​ ​ &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;​ &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;​ ​ &lt;!-- for MyBatis3 / MyBatis3Simple​ 是否创建一个不可变的类，如果为true，​ 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类​ --&gt;​ &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;​ ​ &lt;!-- 设置一个根对象，​ 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项​ 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：​ 1，属性名相同，类型相同，有相同的getter/setter方法；​ --&gt;​ &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;​ ​ &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;​ &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;​ &lt;/javaModelGenerator&gt;​ ​ ​ &lt;!-- 生成SQL map的XML文件生成器，​ 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），​ 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置​ targetPackage/targetProject:同javaModelGenerator​ --&gt;​ &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;​ &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;​ &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;​ &lt;/sqlMapGenerator&gt;​ ​ ​ &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 ​ targetPackage/targetProject:同javaModelGenerator​ type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：​ 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；​ 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；​ 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；​ 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER​ --&gt;​ &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;​ &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;​ &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;​ ​ &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查​ &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;​ --&gt;​ &lt;/javaClientGenerator&gt;​ ​ &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素​ 选择的table会生成一下文件：​ 1，SQL map文件​ 2，生成一个主键类；​ 3，除了BLOB和主键的其他字段的类；​ 4，包含BLOB的类；​ 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；​ 6，Mapper接口（可选）​ ​ tableName（必要）：要生成对象的表名；​ 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会​ 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：​ 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；​ 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；​ 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；​ 4，否则，使用指定的大小写格式查询；​ 另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；​ 这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；​ ​ 可选：​ 1，schema：数据库的schema；​ 2，catalog：数据库的catalog；​ 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName​ 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；​ 5，enableInsert（默认true）：指定是否生成insert语句；​ 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；​ 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；​ 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；​ 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；​ 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；​ 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；​ 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；​ 13，modelType：参考context元素的defaultModelType，相当于覆盖；​ 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）​ 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性​ ​ 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；​ --&gt;​ &lt;table tableName=&quot;userinfo&quot; &gt;​ ​ &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;​ &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;​ ​ &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;​ &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;​ ​ &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;​ &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;​ ​ &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;​ &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;​ ​ &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 ​ &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- 参考javaClientGenerator 的 rootInterface 属性​ &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog ​ &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema ​ &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename ​ &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- 注意，该属性只针对MyBatis3Simple有用；​ 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；​ --&gt;​ &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;​ ​ &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;​ &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;​ ​ ​ &lt;!-- generatedKey用于生成生成主键的方法，​ 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选​ column:主键的列名；​ sqlStatement：要生成的selectKey语句，有以下可选项：​ Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()​ DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()​ DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1​ Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()​ HSQLDB :相当于selectKey的SQL为：CALL IDENTITY()​ Informix :相当于selectKey的SQL为：select dbinfo(&apos;sqlca.sqlerrd1&apos;) from systables where tabid=1​ MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()​ SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()​ SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY​ JDBC :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性​ &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- ​ 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，​ 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；​ 那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是​ custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；​ ​ 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，​ 如果使用了columnOverride元素，该属性无效；​ ​ &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;​ --&gt;​ ​ ​ &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；​ column:要重新设置的列名；​ 注意，一个table元素中可以有多个columnOverride元素哈~​ --&gt;​ &lt;columnOverride column=&quot;username&quot;&gt;​ &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;​ &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;​ ​ &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名​ &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- jdbcType用于指定该列的JDBC类型 ​ &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名​ 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler​ 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述​ &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;​ --&gt;​ ​ &lt;!-- 参考table元素的delimitAllColumns配置，默认为false​ &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;​ --&gt;​ &lt;/columnOverride&gt;​ ​ &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 ​ column:指定要忽略的列的名字；​ delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false​ ​ 注意，一个table元素中可以有多个ignoreColumn元素​ &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;​ --&gt;​ &lt;/table&gt;​ &lt;/context&gt;&lt;/generatorConfiguration&gt; 作者：叩丁狼教育链接：https://www.jianshu.com/p/e09d2370b796","categories":[{"name":"Java","slug":"Java","permalink":"http://io.stelawliet.top/categories/Java/"},{"name":"framework","slug":"Java/framework","permalink":"http://io.stelawliet.top/categories/Java/framework/"},{"name":"mybatis","slug":"Java/framework/mybatis","permalink":"http://io.stelawliet.top/categories/Java/framework/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://io.stelawliet.top/tags/mybatis/"},{"name":"逆向工程","slug":"逆向工程","permalink":"http://io.stelawliet.top/tags/逆向工程/"}]},{"title":"web管理tomcat项目配置","slug":"Java/JavaEE/远程web管理tomcat部署","date":"2018-03-24T08:40:04.000Z","updated":"2018-07-04T12:02:27.000Z","comments":true,"path":"2018/03/24/Java/JavaEE/远程web管理tomcat部署/","link":"","permalink":"http://io.stelawliet.top/2018/03/24/Java/JavaEE/远程web管理tomcat部署/","excerpt":"","text":"1.配置web管理帐号密码权限vim tomcat/conf/tomcat-users.xml编辑tomcat配置路径下的tomcat-users.xml; 123456&lt;role rolename=\"tomcat\"/&gt;&lt;role rolename=\"manager\"/&gt;&lt;role rolename=\"manager-gui\"/&gt;&lt;role rolename=\"manager-script\" /&gt;&lt;role rolename=\"admin-gui\"/&gt;&lt;user username=\"admin\" password=\"admin\" roles=\"tomcat,manager,manager-gui,manager-script,admin-gui\" /&gt; username 和password的值为管理帐号和密码 role为对应的管理功能 2.远程管理云主机配置vim tomcat/conf/Catalina/localhost/manager.xml 在此文件中添加远程主机管理权限 （原本默认只能本机管理） 1234&lt;Context privileged=\"true\" antiResourceLocking=\"false\" docBase=\"$&#123;catalina.home&#125;/webapps/manager\"&gt; &lt;Valve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\"^.*$\" /&gt;&lt;/Context&gt; 3.MAVEN插件自动部署设置Maven目前有俩个插件来配置tomcat的部署：tomcat-maven-plugin和tomcat7-maven-plugin、 12345678910 &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt; password和username为上文设置的用户名和密码","categories":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/categories/java/"},{"name":"javaee","slug":"java/javaee","permalink":"http://io.stelawliet.top/categories/java/javaee/"},{"name":"server","slug":"java/javaee/server","permalink":"http://io.stelawliet.top/categories/java/javaee/server/"},{"name":"tomcat","slug":"java/javaee/server/tomcat","permalink":"http://io.stelawliet.top/categories/java/javaee/server/tomcat/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://io.stelawliet.top/tags/tomcat/"}]},{"title":"","slug":"Java/JavaEE/MAVEN/Maven配置详解","date":"2018-03-24T08:10:23.000Z","updated":"2018-03-24T08:11:21.000Z","comments":true,"path":"2018/03/24/Java/JavaEE/MAVEN/Maven配置详解/","link":"","permalink":"http://io.stelawliet.top/2018/03/24/Java/JavaEE/MAVEN/Maven配置详解/","excerpt":"","text":"MAVEN2的配置文件有两个settings.xml和pom.xml settings.xml：保存的是本地所有项目所共享的全局配置信息，默认在maven安装目录的conf目录下，如果没有安装maven而是用的m2eclipse插件，那么也可以把这个配置文件放在.m2目录下 pom.xml：描述项目的配置文件，放在每个项目的根目录下 settings.xml localRepository：本地仓库位置，默认在.m2/repository/，可以人为更改 offline：离线开关，是否每次构建都从远程仓库下载，默认false servers：对应POM文件的distributionManagement元素里定义id,和登陆服务器的用户名、密码 mirrors：定义仓库镜像，将仓库地址指向自定义仓库地址(id：新的镜像ID，name：镜像名称，url：镜像地址，mirrorOf：以那个地址做镜像，默认为central) proxies：设置HTTP代理 parent 给出父项目的位置，如果存在上一级父项目的话。如果没有特别指出的话，值就是父项目对于当前项目而言。位置是一个 as a group ID, artifact ID 和version元素的组合。modelVersion 描述这个POM文件遵从哪个版本的项目描述符.groupId 针对一个项目的普遍唯一识别符。通常用一个完全正确的包的名字来与其他项目的类似名字来进行区分（比如：org.apache.maven)artifactId 在给定groupID 的group里面为artifact 指定的标识符是唯一的 artifact 代表的是被制作或者被一个project应用的组件。对于Maven项目的artifact 的例子包括：一些JARs, 原代码以及二进制的发布以及WARs.packaging 这个项目生产出来的artifact 类型，举个例子 jar war pom Plugins 能够创建他们自己的包，包括包的类型，所以这个列表不可能包含所有可能的类型name 当前项目的全称version 当前项目产生的artifact的当前版本description 当前项目的一个细节描述，当需要描述这个项目的时候被Maven所用，比如在web 站点中。 这个元素能够被指定为CDATA 类型，允许在描述器中HTML的tags, 并不鼓励用空白文本来表示。 如果你需要去修改生成的web 站点的索引页，你能够用你自己的索引来代替自动生成的文本。url 当前项目的主页的URLprerequisites 描述当前项目的编译环境的先决条件issueManagement 当前项目的发布管理信息。ciManagement 当前项目的连续集成信息。inceptionYear 当前项目开始的年份, 用4位数字描述. 涉及到介绍情况时用作提供版权信息mailingLists 包含的信息包括邮件列表developers 描述当前的项目的开发人员的信息contributors 描述对当前项目有贡献的人员的信息，不特指开发人员licenses 这个元素描述了当前项目的所有的许可文件。每一个许可文件用一个许可元素来描述，然后描述额外的元素. 通常只列出适用于这个项目的许可文件以及适用于 依赖的非licenses。如果多个licenses都列出来了，那么假设这个用户选择其中的所需的，而不是接受所有的许可文件。scm 指定当前项目中的版本控制工具，比如CVS, Subversion, 等等。organization 这个元素描述这个项目所属组织的各种属性的描述。这些属性应用于文档创建的时候 (版权通知和链接).build 创建项目时必须的信息。profiles 本地项目编译档案文件时的列表，被激活时会修改build的过程modules 模块 (有时被叫做子项目)作为当前项目的一部分.每一个被列出来的子模块都指向包含这个模块的目录文件的相对路径repositories 发现依赖和扩展的远程资源库pluginRepositories 发现plugins 的远程资源库的列表，主要是为了编译和报告dependencies 这个元素描述了所有与当前项目相关的依赖.这些依赖被用作创建一个编译时的路径. 他们被自动的从资源库中下在下来依据当前项目的定义。如需更多信息，参看 the dependency mechanismreports Deprecated.禁止适用。现在的版本中被 Maven所忽略掉。reporting 这个元素包括报告的plugins 的指定，用作Maven生成站点的自动生成报告.这些报告将会运行当用户执行mvn site. 所有的报告将会包括在浏览器的导航栏中。dependencyManagement 缺省的依赖信息将会从这个元素中继承。这些依赖在这一部分中被不立刻被解决的。当一个源于这个POM的元素描述了一个依赖根据匹配的 groupId 和artifactId,这个部分的版本和其他值用作那些还没有指定的依赖。distributionManagement 对于一个项目分配的信息允许对于远程web服务器和资源库的site和artifacts配置。 -——————————————————————————————————- 什么是pom?​ pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。快速察看： xml 代码 4.0.0modelVersion&gt; … … … … … … … … … … … … … … … … … … … … … … … … … … … … 基本内容：POM包括了所有的项目信息。maven 相关：pom定义了最小的maven2元素，允许groupId,artifactId,version。所有需要的元素 groupId:项目或者组织的唯一标志，并且配置时生成的路径也是由此生成，如org.codehaus.mojo生成的相对路径为：/org/codehaus/mojoartifactId: 项目的通用名称version:项目的版本packaging: 打包的机制，如pom, jar, maven-plugin, ejb, war, ear, rar, parclassifier: 分类 POM关系：主要为依赖，继承，合成依赖关系：xml 代码 ​ ​ junit​ junit​ 4.0​ ja​ test​ true​ ​ … groupId, artifactId, version:描述了依赖的项目唯一标志可以通过以下方式进行安装： 使用以下的命令安装：mvn install:install-file –Dfile=non-maven-proj.jar –DgroupId=some.group –DartifactId=non-maven-proj –Dversion=1创建自己的库,并配置，使用deploy:deploy-file设置此依赖范围为system，定义一个系统路径。不提倡。type:相应的依赖产品包形式，如jar，warscope:用于限制相应的依赖范围，包括以下的几种变量：compile ：默认范围，用于编译provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpathruntime:在执行时，需要使用test:用于test任务时使用system:需要外在提供相应得元素。通过systemPath来取得systemPath: 仅用于范围为system。提供相应的路径optional: 标注可选，当项目自身也是依赖时。用于连续依赖时使用独占性外在告诉maven你只包括指定的项目，不包括相关的依赖。此因素主要用于解决版本冲突问题 xml 代码 ​ ​ org.apache.maven​ maven-embedder​ 2.0​ ​ ​ org.apache.maven​ maven-core​ ​ ​ 表示项目maven-embedder需要项目maven-core，但我们不想引用maven-core 继承关系另一个强大的变化,maven带来的是项目继承。主要的设置：定义父项目 xml 代码 4.0.0 org.codehaus.mojo my-parent 2.0version&gt; pom packaging 类型，需要pom用于parent和合成多个项目。我们需要增加相应的值给父pom，用于子项目继承。主要的元素如下： 依赖型开发者和合作者插件列表报表列表插件执行使用相应的匹配ids插件配置子项目配置xml 代码 4.0.0 ​ org.codehaus.mojo​ my-parent​ 2.0​ ../my-parent my-project relativePath可以不需要，但是用于指明parent的目录，用于快速查询。 dependencyManagement：用于父项目配置共同的依赖关系，主要配置依赖包相同因素，如版本，scope。 合成（或者多个模块）​ 一个项目有多个模块，也叫做多重模块，或者合成项目。如下的定义： xml 代码 4.0.0 org.codehaus.mojo my-parent 2.0 ​ my-project1​ my-project2 build 设置​ 主要用于编译设置，包括两个主要的元素，build和reportbuild​ 主要分为两部分，基本元素和扩展元素集合注意：包括项目build和profile build xml 代码 … ​ ​ …​ 基本元素 xml 代码 install ${basedir}/targetdirectory&gt; ${artifactId}-${version}finalName&gt; ​ filters/filter1.properties … defaultGoal: 定义默认的目标或者阶段。如installdirectory: 编译输出的目录finalName: 生成最后的文件的样式filter: 定义过滤，用于替换相应的属性文件，使用maven定义的属性。设置所有placehold的值 资源(resources)​ 你项目中需要指定的资源。如spring配置文件,log4j.properties xml 代码 ​ …​ ​ ​ META-INF/plexus​ falsefiltering&gt;​ ${basedir}/src/main/plexus​ ​ configuration.xml​ ​ ​ */.properties​ ​ ​ ​ ​ …​ ​ … resources: resource的列表，用于包括所有的资源targetPath: 指定目标路径，用于放置资源，用于buildfiltering: 是否替换资源中的属性placeholddirectory: 资源所在的位置includes: 样式，包括那些资源excludes: 排除的资源testResources: 测试资源列表插件在build时，执行的插件，比较有用的部分，如使用jdk 5.0编译等等 xml 代码 ​ …​ ​ ​ org.apache.maven.plugins​ maven-jar-plugin​ 2.0​ false​ true​ ​ test​ ​ …​ …​ ​ extensions: true or false，是否装载插件扩展。默认falseinherited: true or false，是否此插件配置将会应用于poms，那些继承于此的项目configuration: 指定插件配置dependencies: 插件需要依赖的包executions: 用于配置execution目标，一个插件可以有多个目标。如下： xml 代码 ​ maven-antrun-plugin​ ​ ​ echodirid&gt;​ ​ run​ verify​ false​ ​ ​ Build Dir: ${project.build.directory}​ ​ ​ ​ ​ 说明：id:规定execution 的唯一标志goals: 表示目标phase: 表示阶段，目标将会在什么阶段执行inherited: 和上面的元素一样，设置false maven将会拒绝执行继承给子插件configuration: 表示此执行的配置属性插件管理 pluginManagement：插件管理以同样的方式包括插件元素，用于在特定的项目中配置。所有继承于此项目的子项目都能使用。主要定义插件的共同元素扩展元素集合主要包括以下的元素：Directories用于设置各种目录结构，如下：xml 代码​ ${basedir}/src/main/java​ ${basedir}/src/main/scripts​ ${basedir}/src/test/java​ ${basedir}/target/classes​ ${basedir}/target/test-classes​ …Extensions表示需要扩展的插件，必须包括进相应的build路径。xml 代码​ …​ ​ ​ org.apache.maven.wagon​ wagon-ftp​ 1.0-alpha-3​ ​ ​ …Reporting​ 用于在site阶段输出报表。特定的maven 插件能输出相应的定制和配置报表。xml 代码​ ​ ​ ${basedir}/target/siteoutputDirectory&gt;​ maven-project-info-reports-pluginartifactId&gt;​ ​ reportSet&gt;​ reportSets&gt;​ plugin&gt;​ plugins&gt;reporting&gt;Report Sets​ 用于配置不同的目标，应用于不同的报表xml 代码​ ​ ​ …​ ​ ​ sunlinkid&gt;​ ​ javadoc​ truei​ ​ ​ http://java.sun.com/j2se/1.5.0/docs/api/​ ​ ​ ​ ​ name:项目除了artifactId外，可以定义多个名称description: 项目描述url: 项目urlinceptionYear:创始年份Licensesxml 代码​ Apache 2name&gt;​ http://www.apache.org/licenses/LICENSE-2.0.txt​ repodistribution&gt;​ A business-friendly OSS licenseOrganization配置组织信息xml 代码​ Codehaus Mojoname&gt;​ http://mojo.codehaus.orgorganization&gt;Developers配置开发者信息xml 代码​ ​ eric​ Eric​ eredmond@codehaus.org​ http://eric.propellors.net​ Codehausorganization&gt;​ http://mojo.codehaus.orgorganization​ ​ architect​ developer​ ​ -6timezone&gt;​ ​ http://tinyurl.com/prv4tpic​ ​ Contributorsxml 代码 ​ Noelle​ some.name@gmail.com​ http://noellemarie.com​ Noelle Marie​ http://noellemarie.com​ ​ tester​ ​ -5​ ​ some.name@gmail.com​ 环境设置Issue Management​ 定义相关的bug跟踪系统，如bugzilla,testtrack,clearQuest等xml 代码​ Bugzilla​ http://127.0.0.1/bugzillauContinuous Integration Management连续整合管理，基于triggers或者timingsxml 代码 continuum http://127.0.0.1:8080/continuum ​ ​ mail​ true​ true​ false​ false​ continuum@127.0.0.1​ Mailing Listsxml 代码 ​ User List​ user-subscribe@127.0.0.1​ user-unsubscribe@127.0.0.1un​ user@127.0.0.1​ http://127.0.0.1/user/​ ​ http://base.google.com/base/1/127.0.0.1​ SCM软件配置管理，如cvs 和svnxml 代码​ scm:svn:http://127.0.0.1/svn/my-project​ scm:svn:https://127.0.0.1/svn/my-project​ HEAD​ http://127.0.0.1/websvn/my-projectRepositories配置同setting.xml中的开发库Plugin Repositories配置同 repositoriesDistribution Management用于配置分发管理，配置相应的产品发布信息,主要用于发布，在执行mvn deploy后表示要发布的位置1 配置到文件系统xml 代码proficio-repositoryProficio Repositoryfile://${basedir}/target/deploy2 使用ssh2配置xml 代码proficio-repositoryProficio Repositoryscp://sshserver.yourcompany.com/deploy3 使用sftp配置xml 代码proficio-repositoryiProficio Repositorysftp://ftpserver.yourcompany.com/deploy4 使用外在的ssh配置​ 编译扩展用于指定使用wagon外在ssh提供，用于提供你的文件到相应的远程服务器。xml 代码proficio-repositoryProficio Repositoryscpexe://sshserver.yourcompany.com/deployorg.apache.maven.wagonwagon-ssh-external1.0-alpha-65 使用ftp配置xml 代码proficio-repositoryProficio Repositoryftp://ftpserver.yourcompany.com/deployorg.apache.maven.wagongroupId&gt;wagon-ftpartifactId&gt;1.0-alpha-6version&gt;repository 对应于你的开发库，用户信息通过settings.xml中的server取得Profiles类似于settings.xml中的profiles，增加了几个元素，如下的样式：xml 代码​ ​ test​ …​ …​ …​ …​ …​ …​ …r​ …​ …​ 设置项目主函数：​ org.apache.maven.plugins​ maven-shade-plugin​ 1.2.1​ ​ ​ package​ ​ shade​ ​ ​ ​ ​ cn.vicky.mainapp.App​ ​ ​ ​ ​ ​","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/spring-aop注解","date":"2018-03-21T13:08:01.000Z","updated":"2018-03-21T13:10:58.000Z","comments":true,"path":"2018/03/21/Java/JavaEE/Java框架/spring/spring-aop注解/","link":"","permalink":"http://io.stelawliet.top/2018/03/21/Java/JavaEE/Java框架/spring/spring-aop注解/","excerpt":"","text":"目标对象（被增强1.xml中配置目标对象 &lt;bean name=&quot;userService&quot; class=&quot;cn.itcast.service.UserServiceImpl&quot; &gt;&lt;/bean&gt; 2. 1234567891011121314151617181920public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(\"保存用户!\"); //int i = 1/0; &#125; @Override public void delete() &#123; System.out.println(\"删除用户!\"); &#125; @Override public void update() &#123; System.out.println(\"更新用户!\"); &#125; @Override public void find() &#123; System.out.println(\"查找用户!\"); &#125;&#125; 切面对象切入的注解：@Pointcut(&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;) 123456789101112131415161718192021222324252627282930313233343536//通知类@Aspect//表示该类是一个通知类public class MyAdvice &#123; @Pointcut(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public void pc()&#123;&#125; //前置通知 //指定该方法是前置通知,并制定切入点 @Before(\"MyAdvice.pc()\") public void before()&#123; System.out.println(\"这是前置通知!!\"); &#125; //后置通知 @AfterReturning(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public void afterReturning()&#123; System.out.println(\"这是后置通知(如果出现异常不会调用)!!\"); &#125; //环绕通知 @Around(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"这是环绕通知之前的部分!!\"); Object proceed = pjp.proceed();//调用目标方法 System.out.println(\"这是环绕通知之后的部分!!\"); return proceed; &#125; //异常通知 @AfterThrowing(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public void afterException()&#123; System.out.println(\"出事啦!出现异常了!!\"); &#125; //后置通知 @After(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public void after()&#123; System.out.println(\"这是后置通知(出现异常也会调用)!!\"); &#125; xml配置1234567&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt; &lt;bean name=\"userService\" class=\"cn.itcast.service.UserServiceImpl\" &gt;&lt;/bean&gt;&lt;!-- 2.配置通知对象 --&gt; &lt;bean name=\"myAdvice\" class=\"cn.itcast.e_annotationaop.MyAdvice\" &gt;&lt;/bean&gt;&lt;!-- 3.开启使用注解完成织入 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 约束 12&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd \"&gt;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/spring-aop配置xml","date":"2018-03-21T13:00:37.000Z","updated":"2018-03-21T13:14:49.000Z","comments":true,"path":"2018/03/21/Java/JavaEE/Java框架/spring/spring-aop配置xml/","link":"","permalink":"http://io.stelawliet.top/2018/03/21/Java/JavaEE/Java框架/spring/spring-aop配置xml/","excerpt":"","text":"xml配置123456789101112131415161718192021&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt; &lt;bean name=\"userService\" class=\"cn.itcast.service.UserServiceImpl\" &gt;&lt;/bean&gt;&lt;!-- 2.配置通知对象 --&gt; &lt;bean name=\"myAdvice\" class=\"cn.itcast.d_springaop.MyAdvice\" &gt;&lt;/bean&gt;&lt;!-- 3.配置将通知织入目标对象 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* cn.itcast.service.*ServiceImpl.*(..))\" id=\"pc\"/&gt; &lt;aop:aspect ref=\"myAdvice\" &gt; &lt;!-- 指定名为before方法作为前置通知 --&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pc\" /&gt; &lt;!-- 后置 --&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"pc\" /&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=\"around\" pointcut-ref=\"pc\" /&gt; &lt;!-- 异常拦截通知 --&gt; &lt;aop:after-throwing method=\"afterException\" pointcut-ref=\"pc\"/&gt; &lt;!-- 后置 --&gt; &lt;aop:after method=\"after\" pointcut-ref=\"pc\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 配置切入点多种匹配 12345678//配置切入点 public void cn.itcast.service.UserServiceImpl.save() void cn.itcast.service.UserServiceImpl.save() * cn.itcast.service.UserServiceImpl.save() * cn.itcast.service.UserServiceImpl.*() * cn.itcast.service.*ServiceImpl.*(..) * cn.itcast.service..*ServiceImpl.*(..) 通知类1234567891011121314151617181920212223242526272829303132333435363738//通知类public class MyAdvice &#123; //前置通知 // |-目标方法运行之前调用 //后置通知(如果出现异常不会调用)// |-在目标方法运行之后调用 //环绕通知// |-在目标方法之前和之后都调用 //异常拦截通知// |-如果出现异常,就会调用 //后置通知(无论是否出现 异常都会调用)// |-在目标方法运行之后调用//---------------------------------------------------------------- //前置通知 public void before()&#123; System.out.println(\"这是前置通知!!\"); &#125; //后置通知 public void afterReturning()&#123; System.out.println(\"这是后置通知(如果出现异常不会调用)!!\"); &#125; //环绕通知 public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"这是环绕通知之前的部分!!\"); Object proceed = pjp.proceed();//调用目标方法 System.out.println(\"这是环绕通知之后的部分!!\"); return proceed; &#125; //异常通知 public void afterException()&#123; System.out.println(\"出事啦!出现异常了!!\"); &#125; //后置通知 public void after()&#123; System.out.println(\"这是后置通知(出现异常也会调用)!!\"); &#125;&#125; 目标类12","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/spring-事务注解配置","date":"2018-03-21T12:36:37.000Z","updated":"2018-03-21T12:49:03.000Z","comments":true,"path":"2018/03/21/Java/JavaEE/Java框架/spring/spring-事务注解配置/","link":"","permalink":"http://io.stelawliet.top/2018/03/21/Java/JavaEE/Java框架/spring/spring-事务注解配置/","excerpt":"","text":"xml配置12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd \"&gt;&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\" /&gt;&lt;!-- 事务核心管理器,封装了所有事务操作. 依赖于连接池 --&gt;&lt;bean name=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" &gt; &lt;property name=\"dataSource\" ref=\"dataSource\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务模板对象 --&gt;&lt;bean name=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\" &gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启使用注解管理aop事务 --&gt;&lt;tx:annotation-driven/&gt;&lt;!-- 1.将连接池 --&gt;&lt;bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" &gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\" &gt;&lt;/property&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\" &gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\" &gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2.Dao--&gt;&lt;bean name=\"accountDao\" class=\"cn.itcast.dao.AccountDaoImpl\" &gt; &lt;property name=\"dataSource\" ref=\"dataSource\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3.Service--&gt;&lt;bean name=\"accountService\" class=\"cn.itcast.service.AccountServiceImpl\" &gt; &lt;property name=\"ad\" ref=\"accountDao\" &gt;&lt;/property&gt; &lt;property name=\"tt\" ref=\"transactionTemplate\" &gt;&lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt; ####事务注解 Spring事务的隔离级别 1、 ISOLATION_DEFAULT: 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。 2、ISOLATION_READ_UNCOMMITTED:这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。 3、ISOLATION_READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 4、ISOLATION_REPEATALBE_READ: 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻想读。它除了保证一个事务不能读取另外一个事务未提交的数据外，还保证了避免下面的情况产生（不可重复读）。 5、ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不课重复读外，还避免了幻想读。 事务属性说明的注解@Transactional,Isolation.REPEATALBE_READ 123456789101112131415@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=true)public class AccountServiceImpl implements AccountService &#123; private AccountDao ad ; private TransactionTemplate tt; @Override @Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false) public void transfer(final Integer from,final Integer to,final Double money) &#123; //减钱 ad.decreaseMoney(from, money); int i = 1/0; //加钱 ad.increaseMoney(to, money); &#125;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/spring-事务配置","date":"2018-03-21T12:30:12.000Z","updated":"2018-03-21T12:53:58.000Z","comments":true,"path":"2018/03/21/Java/JavaEE/Java框架/spring/spring-事务配置/","link":"","permalink":"http://io.stelawliet.top/2018/03/21/Java/JavaEE/Java框架/spring/spring-事务配置/","excerpt":"","text":"事务xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd \"&gt;&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\" /&gt;&lt;!-- 事务核心管理器,封装了所有事务操作. 依赖于连接池 --&gt;&lt;bean name=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" &gt; &lt;property name=\"dataSource\" ref=\"dataSource\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务模板对象 --&gt;&lt;bean name=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\" &gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\" &gt; &lt;tx:attributes&gt; &lt;!-- 以方法为单位,指定方法应用什么事务属性 isolation:隔离级别 propagation:传播行为 read-only:是否只读 --&gt; &lt;tx:method name=\"save*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"persist*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"modify*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"delete*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"remove*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;tx:method name=\"get*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\" /&gt; &lt;tx:method name=\"find*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\" /&gt; &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置织入 --&gt;&lt;aop:config &gt; &lt;!-- 配置切点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* cn.itcast.service.*ServiceImpl.*(..))\" id=\"txPc\"/&gt; &lt;!-- 配置切面 : 通知+切点 advice-ref:通知的名称 pointcut-ref:切点的名称 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPc\" /&gt;&lt;/aop:config&gt;&lt;!-- 1.将连接池 --&gt;&lt;bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" &gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\" &gt;&lt;/property&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\" &gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\" &gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2.Dao--&gt;&lt;bean name=\"accountDao\" class=\"cn.itcast.dao.AccountDaoImpl\" &gt; &lt;property name=\"dataSource\" ref=\"dataSource\" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3.Service--&gt;&lt;bean name=\"accountService\" class=\"cn.itcast.service.AccountServiceImpl\" &gt; &lt;property name=\"ad\" ref=\"accountDao\" &gt;&lt;/property&gt; &lt;property name=\"tt\" ref=\"transactionTemplate\" &gt;&lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt;","categories":[],"tags":[]},{"title":"","slug":"JavaScript/webpack报错总结","date":"2018-02-27T07:51:37.000Z","updated":"2018-07-04T14:00:20.000Z","comments":true,"path":"2018/02/27/JavaScript/webpack报错总结/","link":"","permalink":"http://io.stelawliet.top/2018/02/27/JavaScript/webpack报错总结/","excerpt":"","text":"1.在项目根目录下 npm init 2.webpack-dev-server的版本问题。 保持webpack和webpack-dev-server版本兼容 在package.josn中修改 “webpack”: “2.2.0” “webpack-dev-server”: “2.2.0” 然后执行npm update。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/idea spring配置","date":"2018-01-06T15:01:47.000Z","updated":"2018-01-06T15:03:09.000Z","comments":true,"path":"2018/01/06/Java/JavaEE/Java框架/spring/idea spring配置/","link":"","permalink":"http://io.stelawliet.top/2018/01/06/Java/JavaEE/Java框架/spring/idea spring配置/","excerpt":"","text":"&lt;转&gt;IDEA用maven创建springMVC项目和配置（XML配置和Java配置）转自http://blog.csdn.net/cquwel 这段时间在学习javaweb的一些知识，然后接触到了springmvc框架。框架的创建和配置一直是新手入门的一个难题，所以我就写一下我的配置过程，以供参考，另外因为spring4的新特性可以用java来配置，网上相关资料较少，所以我参考了很多博文后，把xml和java两种配置方式都试了一下。工具准备：IDEA2016.3 Java jdk 1.81、DEA创建项目新建一个maven project，并且选择webapp原型。 这里写图片描述 然后点击next 这里写图片描述 这里的GroupId和ArtifactID随意填写，但是ArtifactID最好和你的项目一名一样然后next 这里写图片描述 为了快一点创建，我们添加一个属性值，如图中亮的所示，点右边的加号，name=archetypeCatalog value=internal。这里我们选择使用IDEA自带的maven，下面的两个分别是你的maven配置文件和你的仓库地址，我记得idea的maven一开始是没有setting.xml的，所以你要去maven的目录里面拷一份setting.xml到你的仓库中。idea的maven在安装路径的plugins文件夹下，即X:\\xxx\\JetBrains\\IntelliJ IDEA 2016.3.2\\plugins\\plugins\\maven\\lib\\maven3\\conf\\setting.xml拷贝到你的用户文件夹下的.m2文件夹下，为了之后能够快速的下载依赖包，我们要加一个官方库的镜像，因为maven的官方仓库在国外，太慢了。我们在你的.m2文件夹下的setting.xml中添加如下代码： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;123456 具体位置如下图所示 这里写图片描述 这个是阿里的库，所以很快。做完之后我们回到idea，点击next，然后填写项目名，然后finish。接下来idea开始创建项目，这里你要把maven自动导入打开。 这里写图片描述 然后等待maven创建项目成功 这里写图片描述 这样我们的项目初始的框架就弄好了。 2、添加pom依赖创建好之后的项目目录如图所示 这里写图片描述 我们打开其中的pom.xml，添加我们的依赖。这里我把我的依赖全部放出来，复制到你的pom.xml的dependencies标签之间就可以了，pom文件中也会给你一个示例。我的依赖如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!--测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!--J2EE--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!--springframework--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt; &lt;artifactId&gt;system-rules&lt;/artifactId&gt; &lt;version&gt;1.16.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--其他需要的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 一旦你复制过去之后，maven就会开始下载相应的jar文件，等待下载完成即可。可能包有点多，不过用了阿里的镜像之后还是挺快的。 3、添加框架支持配置完pom.xml之后，我们在idea中要添加一下框架的支持。右击我们的项目文件夹，选择add framework support 这里写图片描述 然后在窗口中分别选中spring和springmvc，并且选择spring是，记得勾选springconfig.xml 这里写图片描述 因为我们之前下载过相应的文件，所以这里直接用我们下载好的spring文件。点击ok之后，我们会发现WEB-INF文件夹下多出了两个文件 这里写图片描述 这个就是我们之后要配置的文件，先不用管。 4、完善目录结构首先我们在src/main文件夹下创建java文件夹，你会发现这个文件夹不能创建java的类文件和package，别急，先把必须的文件夹全部创建好。请按照下图创建文件夹 这里写图片描述 然后我们进入project structure选择文件夹的作用，在界面的右上角进入project structure 这里写图片描述 然后在module中选择设置各个模块，其中java文件夹是 sources，test是Test，改完之后，点ok，文件夹会变色，那就成功了。 这里写图片描述 然后仔仔java文件夹中添加需要的包。最后的完整目录如下 这里写图片描述 这样我们配置前的工作就完成了，接下来就是对springmvc进行配置。我把两种配置的方法分成两部分，以供参考。 5、基于XML 的配置 5.1、配置web.xml idea创建的web.xml这个文件版本比较低，所以我们要找一个新的。把我的文件直接全部覆盖复制进去就可以了。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--welcome pages--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置springmvc DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置dispatcher.xml作为mvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--把applicationContext.xml加入到配置文件中--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;1234567891011121314151617181920212223242526272829303132333435363738 上面代码的意思主要就是创建一个中央的控制器，都有简单的注释，如果有需要，请自行百度。 5.2 配置dispatcher-servlet.xml 这个文件负责mvc的配置。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--此文件负责整个mvc中的配置--&gt; &lt;!--启用spring的一些annotation --&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源映射--&gt; &lt;!--本项目把静态资源放在了webapp的statics目录下，资源映射如下--&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/statics/css/&quot;/&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/statics/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/image/**&quot; location=&quot;/WEB-INF/statics/image/&quot;/&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id=&quot;defaultViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;property name=&quot;exposeContextBeansAsAttributes&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 自动扫描装配 --&gt; &lt;context:component-scan base-package=&quot;example.controller&quot;/&gt;&lt;/beans&gt;1234567891011121314151617181920212223242526272829303132 直接复制即可，都有注释，如果有需要，请自行百度。 5.3、 配置applicationContext.xml 其实这个文件没什么好配置的，这个文件主要负责一些非mvc组件（或者其他组件）的配置，暂时没有，所以是空的，但你也可以扫描一下。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;example&quot;/&gt;&lt;/beans&gt;1234567 5.4、 测试 三个配置文件配置好之后，就可以测试了。首先在controller文件夹下创建一个IndexController，代码如下： 123456789@Controller@RequestMapping(&quot;/home&quot;)public class IndexController &#123; @RequestMapping(&quot;/index&quot;) public String index() &#123; return &quot;index&quot;; &#125;&#125;12345678910 views文件夹下创建index.jsp，statics/css/下创建test.css 123456789101112&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Index&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;c:url value=&quot;/css/test.css&quot;/&gt; &quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Spring MVC based on XML config success!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;123456789101112 123456p&#123; background-color: brown; font-family: &quot;Courier New&quot;; font-size:100px;&#125;123456 接下来配置tomcat，如果没有，去官网下载tomcat7以上的版本。右上角 这里写图片描述 然后选择tomcat 这里写图片描述 配置相关信息 这里写图片描述 还有deployment 这里写图片描述 选择第二个 这里写图片描述 这里的名称和项目名一样。 这里写图片描述 然后点击ok完成。 最后运行tomcat，在浏览器输入http://localhost:8080/Demo/home/index 即可。 这里写图片描述 运行成功。 6、基于Java配置java配置也是参考spring in action 第四版这个书，所以具体的原理不去详解，所以我这里更加倾向于把java配置和xml配置中的相同功能的部分进行比较，也是能对java配置又以有一个更加直观的认识。首先我们先完成准备工作，也就是本文的前四个直到文件目录完成，但是目录需要一点小的修改，因为多了配置类，如下图。 这里写图片描述 可以看到我们多了一个config包，这个里面就是放配置类的。 6.1 、去除web.xmlweb.xml里面的内容可以删掉了。在config中创建WebXml类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WebXml extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /* &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123;ApplicationContextXml.class&#125;; &#125; /* &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置dispatcher.xml作为mvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123;DispatcherServletXml.class&#125;; &#125; /* &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; */ @Override protected String[] getServletMappings() &#123; return new String[] &#123;&quot;/&quot;&#125;; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445 6.2、去除dispatcher-servle.xml 1234567891011121314151617181920212223242526272829303132333435363738394041@Configuration@EnableWebMvc@ComponentScan(&quot;web.example.controller&quot;)public class DispatcherServletXml extends WebMvcConfigurerAdapter&#123; /* &lt;bean id=&quot;defaultViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;property name=&quot;exposeContextBeansAsAttributes&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; */ @Bean public ViewResolver viewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setViewClass(org.springframework.web.servlet.view.JstlView.class); resolver.setPrefix(&quot;/WEB-INF/views/&quot;); resolver.setSuffix(&quot;.jsp&quot;); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); super.configureDefaultServletHandling(configurer); &#125; // 静态资源配置 /* &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/statics/css/&quot;/&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/statics/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/image/**&quot; location=&quot;/WEB-INF/statics/image/&quot;/&gt; */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/WEB-INF/statics/css/&quot;); registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/WEB-INF/statics/js/&quot;); registry.addResourceHandler(&quot;/image/**&quot;).addResourceLocations(&quot;WEB-INF/statics/image/&quot;); super.addResourceHandlers(registry); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041 6.3、去除applicationContext.xml 1234567@Configuration@ComponentScan(basePackages = &#123;&quot;web&quot;&#125;, excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class) &#125;)public class ApplicationContextXml &#123;&#125;12345678 上面三个配置类中的每一个设置我都对应的给出了原xml文档中的对应部分，两边对照着看，应该很容易理解。然后按照之前的测试方法，测试成功。 7、 结束语以上的都是我边写边进行配置的，如果说的有什么错误，希望指正，毕竟我还是个新手，配置成功的项目我已经上传，以方便参考。链接：点此下载 参考资料：IntelliJ IDEA上创建Maven Spring MVC项目 IntelliJ idea创建Spring MVC的Maven项目 Intellij IDEA使用Maven快速创建Spring MVC Web项目工程 applicationContext.xml和dispatcher-servlet.xml的区别 Servlet 3 + Spring MVC零配置：去除所有xml Spring(三）：使用java config配置spring mvc 版权声明：欢迎转载，转载请注明出处http://blog.csdn.net/cquwel","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/spring xml约束","date":"2018-01-06T15:01:29.000Z","updated":"2018-01-06T15:01:29.000Z","comments":true,"path":"2018/01/06/Java/JavaEE/Java框架/spring/spring xml约束/","link":"","permalink":"http://io.stelawliet.top/2018/01/06/Java/JavaEE/Java框架/spring/spring xml约束/","excerpt":"","text":"spring配置文件最全约束转载 2016年09月12日 22:05:30 &lt;?xml version=”1.0” encoding=”utf-8”?&gt;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/spring-xml","date":"2018-01-06T14:45:58.000Z","updated":"2018-01-06T14:45:58.000Z","comments":true,"path":"2018/01/06/Java/JavaEE/Java框架/spring/spring-xml/","link":"","permalink":"http://io.stelawliet.top/2018/01/06/Java/JavaEE/Java框架/spring/spring-xml/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"MD/ssss","date":"2017-12-28T11:46:45.000Z","updated":"2017-12-28T11:48:03.000Z","comments":true,"path":"2017/12/28/MD/ssss/","link":"","permalink":"http://io.stelawliet.top/2017/12/28/MD/ssss/","excerpt":"","text":"img","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/DataSources数据库连接池","date":"2017-12-26T11:15:52.000Z","updated":"2017-12-26T11:15:52.000Z","comments":true,"path":"2017/12/26/Java/JavaEE/DataSources数据库连接池/","link":"","permalink":"http://io.stelawliet.top/2017/12/26/Java/JavaEE/DataSources数据库连接池/","excerpt":"","text":"DataSources数据库连接池.mdhtml {overflow-x: initial !important;}.CodeMirror { height: auto; } .CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { padding: 4px 0px; } .CodeMirror pre { } .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler { background-color: white; } .CodeMirror-gutters { border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); background-color: rgb(247, 247, 247); white-space: nowrap; } .CodeMirror-linenumbers { } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .CodeMirror div.CodeMirror-cursor { border-left-width: 1px; border-left-style: solid; border-left-color: black; z-index: 3; } .CodeMirror div.CodeMirror-secondarycursor { border-left-width: 1px; border-left-style: solid; border-left-color: silver; } .CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor { width: auto; border: 0px; background-color: rgb(119, 238, 119); z-index: 1; background-position: initial initial; background-repeat: initial initial; } .CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite { } .cm-tab { display: inline-block; } .cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property { color: rgb(217, 79, 138); } .cm-s-typora-default pre.cm-header1:not(.cm-atom) :not(.cm-overlay) { font-size: 2rem; line-height: 2rem; } .cm-s-typora-default pre.cm-header2:not(.cm-atom) :not(.cm-overlay) { font-size: 1.4rem; line-height: 1.4rem; } .cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number { color: rgb(149, 132, 134); } .cm-s-typora-default .cm-table-row, .cm-s-typora-default .cm-block-start { font-family: monospace; } .cm-s-typora-default .cm-comment, .cm-s-typora-default .cm-code { color: rgb(74, 90, 159); font-family: monospace; } .cm-s-typora-default .cm-tag { color: rgb(169, 68, 66); } .cm-s-typora-default .cm-string { color: rgb(126, 134, 169); } .cm-s-typora-default .cm-link { color: rgb(196, 122, 15); text-decoration: underline; } .cm-s-typora-default .cm-variable-2, .cm-s-typora-default .cm-variable-1 { color: inherit; } .cm-s-typora-default .cm-overlay { font-family: monospace; } .CodeMirror.cm-s-typora-default div.CodeMirror-cursor { border-left-width: 3px; border-left-style: solid; border-left-color: rgb(228, 98, 154); } .cm-s-typora-default .CodeMirror-activeline-background { left: -60px; right: -30px; background-color: rgba(204, 204, 204, 0.2); background-position: initial initial; background-repeat: initial initial; } .cm-s-typora-default .CodeMirror-gutters { border-right-style: none; background-color: inherit; } .cm-s-typora-default .cm-trailing-space-new-line::after, .cm-startspace::after, .cm-starttab .cm-tab::after { content: '•'; position: absolute; left: 0px; opacity: 0; font-family: LetterGothicStd, monospace; } .os-windows .cm-startspace::after, .os-windows .cm-starttab .cm-tab::after { left: -0.1em; } .cm-starttab .cm-tab::after { content: ' '; } .cm-startspace, .cm-tab, .cm-starttab, .cm-trailing-space-a, .cm-trailing-space-b, .cm-trailing-space-new-line { font-family: monospace; position: relative; } .cm-s-typora-default .cm-trailing-space-new-line::after { content: '↓'; opacity: 0.3; } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: black; } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-property { color: black; } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: blue; } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: bold; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: rgb(255, 0, 0); } .cm-invalidchar { color: rgb(255, 0, 0); } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; background-position: inherit inherit; background-repeat: inherit inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { margin-bottom: -30px; margin-right: -30px; padding-bottom: 30px; padding-right: 30px; height: 100%; outline: none; position: relative; box-sizing: content-box; } .CodeMirror-sizer { position: relative; } .CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler { position: absolute; z-index: 6; display: none; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow-x: hidden; overflow-y: scroll; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow-y: hidden; overflow-x: scroll; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background-image: none !important; border: none !important; background-position: initial initial !important; background-repeat: initial initial !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; border-width: 0px; background-color: transparent; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; background-position: initial initial; background-repeat: initial initial; } .CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right-width: 30px; border-right-style: solid; border-right-color: transparent; width: -webkit-fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right-style: none; width: auto; } .CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-widget { } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right-style: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .CodeMirror-selected { background-color: rgb(217, 217, 217); background-position: initial initial; background-repeat: initial initial; } .CodeMirror-focused .CodeMirror-selected { background-color: rgb(215, 212, 240); background-position: initial initial; background-repeat: initial initial; } .cm-searching { background-color: rgba(255, 255, 0, 0.4); background-position: initial initial; background-repeat: initial initial; } .CodeMirror span { } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } .CodeMirror-lint-markers { width: 16px; } .CodeMirror-lint-tooltip { background-color: infobackground; border: 1px solid black; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; color: infotext; font-family: monospace; overflow: hidden; padding: 2px 5px; position: fixed; white-space: pre-wrap; z-index: 10000; max-width: 600px; opacity: 0; -webkit-transition: opacity 0.4s; transition: opacity 0.4s; font-size: 0.8em; } .CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning { background-position: 0% 100%; background-repeat: repeat no-repeat; } .CodeMirror-lint-mark-error { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==); } .CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning { cursor: pointer; display: inline-block; height: 16px; width: 16px; vertical-align: middle; position: relative; background-position: 50% 50%; background-repeat: no-repeat no-repeat; } .CodeMirror-lint-message-error, .CodeMirror-lint-message-warning { padding-left: 18px; background-position: 0% 0%; background-repeat: no-repeat no-repeat; } .CodeMirror-lint-marker-error, .CodeMirror-lint-message-error { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=); } .CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=); } .CodeMirror-lint-marker-multiple { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC); width: 100%; height: 100%; background-position: 100% 100%; background-repeat: no-repeat no-repeat; } :root { --bg-color: rgb(255, 255, 255); --text-color: rgb(51, 51, 51); --code-block-bg-color: inherit; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857143; overflow-x: hidden; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; background-position: inherit inherit; background-repeat: inherit inherit; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { background-color: rgb(181, 214, 252); text-shadow: none; background-position: initial initial; background-repeat: initial initial; } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } .typora-export #write { margin: 0px auto; } #write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; } #write li > table:first-child { margin-top: -20px; } img { max-width: 100%; vertical-align: middle; } input, button, select, textarea { color: inherit; font-family: inherit; font-size: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; line-height: inherit; } input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; } ::before, ::after, * { box-sizing: border-box; } #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; } #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; } .typora-export p { white-space: normal; } .mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.701961); color: rgb(85, 85, 85); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; } #write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; } figure { max-width: 100%; overflow-x: auto; margin: 0px; } tr { page-break-inside: avoid; page-break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; page-break-inside: auto; text-align: left; } table.md-table td { min-width: 80px; } .CodeMirror-gutters { border-right-width: 0px; background-color: inherit; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } pre { white-space: pre-wrap; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; page-break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: var(--code-block-bg-color); position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } .md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; } .md-fences.mock-cm { white-space: pre-wrap; } .show-fences-line-number .md-fences { padding-left: 0px; } .show-fences-line-number .md-fences.mock-cm { padding-left: 40px; } .CodeMirror-line { page-break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; } .footnotes + .footnotes { margin-top: -1em; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background-color: transparent; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; background-position: initial initial; background-repeat: initial initial; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li p, li .mathjax-block { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; } @media print { html, body { border: 1px solid transparent; height: 99%; page-break-after: avoid; page-break-before: avoid; } .typora-export * { -webkit-print-color-adjust: exact; } h1, h2, h3, h4, h5, h6 { page-break-after: avoid; orphans: 2; } p { orphans: 4; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; page-break-after: avoid; } .typora-export #write::after { height: 0px; } @page { margin: 20mm 0mm; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; background-color: rgb(204, 204, 204); display: block; overflow-x: hidden; background-position: initial initial; background-repeat: initial initial; } p > img:only-child { display: block; margin: auto; } p .md-image:only-child { display: inline-block; width: 100%; text-align: center; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .mathjax-block { white-space: pre; overflow: hidden; width: 100%; } p + .mathjax-block { margin-top: -1.143rem; } .mathjax-block:not(:empty)::after { display: none; } [contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus { outline: none; box-shadow: none; } .task-list { list-style-type: none; } .task-list-item { position: relative; padding-left: 1em; } .task-list-item input { position: absolute; top: 0px; left: 0px; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc::after, .md-toc-content::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: '.'; } .md-tag { opacity: 0.5; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: monospace; } code { text-align: left; } h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; } a.md-print-anchor { border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; background-color: transparent !important; text-shadow: initial !important; background-position: initial initial !important; background-repeat: initial initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: monospace; } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { -webkit-transition: none; transition: none; } .md-diagram-panel > svg { max-width: 100%; } [lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } @include-when-export url(http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext); @font-face { font-family: 'Open Sans'; font-style: normal; font-weight: normal; src: local('Open Sans Regular'),url('file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/github/400.woff') format('woff') } @font-face { font-family: 'Open Sans'; font-style: italic; font-weight: normal; src: local('Open Sans Italic'),url('file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/github/400i.woff') format('woff') } @font-face { font-family: 'Open Sans'; font-style: normal; font-weight: bold; src: local('Open Sans Bold'),url('file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/github/700.woff') format('woff') } @font-face { font-family: 'Open Sans'; font-style: italic; font-weight: bold; src: local('Open Sans Bold Italic'),url('file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/github/700i.woff') format('woff') } html { font-size: 16px; } body { font-family: \"Open Sans\",\"Clear Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write{ max-width: 860px; margin: 0 auto; padding: 20px 30px 40px 30px; padding-top: 20px; padding-bottom: 100px; } #write > ul:first-child, #write > ol:first-child{ margin-top: 30px; } body > *:first-child { margin-top: 0 !important; } body > *:last-child { margin-bottom: 0 !important; } a { color: #4183C4; } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { /*background: url(\"file:///Users/zhaoziqi/Library/Application%20Support/images/modules/styleguide/para.png\") no-repeat 10px center;*/ text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { padding-bottom: .3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } h2 { padding-bottom: .3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: #777; } p, blockquote, ul, ol, dl, table{ margin: 0.8em 0; } li>ol, li>ul { margin: 0 0; } hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box; border-bottom: 1px solid #ddd; } body > h2:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child + h2 { margin-top: 0; padding-top: 0; } body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0; padding-top: 0; } a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0; padding-top: 0; } h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #dddddd; padding: 0 15px; color: #777777; } blockquote blockquote { padding-right: 0; } table { padding: 0; word-break: initial; } table tr { border-top: 1px solid #cccccc; margin: 0; padding: 0; } table tr:nth-child(2n) { background-color: #f8f8f8; } table tr th { font-weight: bold; border: 1px solid #cccccc; text-align: left; margin: 0; padding: 6px 13px; } table tr td { border: 1px solid #cccccc; text-align: left; margin: 0; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0; } table tr th:last-child, table tr td:last-child { margin-bottom: 0; } .CodeMirror-gutters { border-right: 1px solid #ddd; } .md-fences, code, tt { border: 1px solid #ddd; background-color: #f8f8f8; border-radius: 3px; padding: 0; font-family: Consolas, \"Liberation Mono\", Courier, monospace; padding: 2px 4px 0px 4px; font-size: 0.9em; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding: 0.2em 1em; padding-top: 8px; padding-bottom: 6px; } .task-list{ padding-left: 0; } .task-list-item { padding-left:32px; } .task-list-item input { top: 3px; left: 8px; } @media screen and (min-width: 914px) { /*body { width: 854px; margin: 0 auto; }*/ } @media print { html { font-size: 13px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: #f8f8f8; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important; } .mathjax-block>.code-tooltip { bottom: .375rem; } #write>h3.md-focus:before{ left: -1.5625rem; top: .375rem; } #write>h4.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h5.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h6.md-focus:before{ left: -1.5625rem; top: .285714286rem; } .md-image>.md-meta { border: 1px solid #ddd; border-radius: 3px; font-family: Consolas, \"Liberation Mono\", Courier, monospace; padding: 2px 4px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag{ color: inherit; } .md-toc { margin-top:20px; padding-bottom:20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8; } #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px; } #md-notification:before { top: 10px; } /** focus mode */ .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer{ font-family: \"Segoe UI\", \"Arial\", sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state{ visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: #fafafa; background-color: var(--side-bar-bg-color); } .md-lang { color: #b4654d; } 数据库连接池DBCPjar：commons-pool.jar、commons-dbcp.jarC3P0Tomcat配置连接池获取Tomcat资源修改JdbcUtilsDBUtils增、删、改查批处理数据库连接池作用：使用池来管理连接的生命周期，节省资源，提高性能。 java提供的连接池接口：javax.sql.DataSource，连接池厂商的连接池类需要实现这一接口。DBCPjar：commons-pool.jar、commons-dbcp.jar xxxxxxxxxx121BasicDataSource ds = new BasicDataSource();2ds.setUsername(\"root\");3ds.setPassword(\"123\");4ds.setUrl(\"jdbc:mysql://localhost:3306/mydb1\");5ds.setDriverClassName(\"com.mysql.jdbc.Driver\");6 7ds.setMaxActive(20); 8ds.setMaxIdle(10); 9ds.setInitialSize(10) ;10ds.setMinIdle(2) ;11ds.setMaxWait(1000) ;12Connection con = ds.getConnection();C3P0jar：c3p0-0.9.2-pre1.jar、c3p0-oracle-thin-extras-0.9.2-pre1.jar、mchange-commons-0.2.jar xxxxxxxxxx121ComboPooledDataSource ds = new ComboPooledDataSource();2ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydb1\");3ds.setUser(\"root\");4ds.setPassword(\"123\");5ds.setDriverClass(\"com.mysql.jdbc.Driver\");6 7ds.setAcquireIncrement(5) ;8ds.setInitialPoolSize(20) ;9ds.setMinPoolSize(2) ;10ds.setMaxPoolSize(50) ;11​12Connection con = ds.getConnection();C3P0配置文件xml文件详细配置 通过默认配置初始化连接池 xxxxxxxxxx21 &nbsp;ComboPooledDataSource ds = new ComboPooledDataSource();2 &nbsp;Connection con = ds.getConnection(); xxxxxxxxxx31&lt;default-config&gt;2 &nbsp;&lt;property name=\"xxx\"&gt;XXX&lt;/property&gt;3&lt;/defualt-config&gt;通过命名配置初始化连接池 xxxxxxxxxx21 &nbsp;ComboPooledDataSource ds = new ComboPooledDataSource(\"oracle-config\");2 &nbsp;Connection con = ds.getConnection(); xxxxxxxxxx31&lt;named-config name=\"orcale-config\"&gt;2 &nbsp;&lt;property name=\"xxx\"&gt;XXX&lt;/property&gt;3&lt;/named-config&gt;Tomcat配置连接池在server.xml中，或在conf/catalina/localhost/下创建xml文件 xxxxxxxxxx131&lt;Context&gt; &nbsp;2 &nbsp;&lt;Resource name=\"myc3p0\" 3 &nbsp; type=\"com.mchange.v2.c3p0.ComboPooledDataSource\"4 &nbsp; factory=\"org.apache.naming.factory.BeanFactory\"5 &nbsp; user=\"root\" 6 &nbsp; password=\"123\" 7 &nbsp; classDriver=\"com.mysql.jdbc.Driver\" &nbsp; &nbsp;8 &nbsp; jdbcUrl=\"jdbc:mysql://127.0.0.1/mydb1\"9 &nbsp; maxPoolSize=\"20\"10 &nbsp; minPoolSize =\"5\"11 &nbsp; initialPoolSize=\"10\"12 &nbsp; &nbsp; &nbsp; &nbsp;acquireIncrement=\"2\"/&gt;13&lt;/Context&gt; &nbsp;&nbsp;获取Tomcat资源 xxxxxxxxxx31Context cxt = new InitialContext(); 2DataSource ds = (DataSource)cxt.lookup(\"java:/comp/env/myc3p0\");3Connection con = ds.getConnection();修改JdbcUtils xxxxxxxxxx151public class JdbcUtils {2​3 &nbsp; &nbsp;private static DataSource dataSource = new ComboPooledDataSource();4​5 &nbsp; &nbsp;public static DataSource getDataSource() {6 &nbsp; return dataSource;7 &nbsp; }8 &nbsp; &nbsp;9 &nbsp; &nbsp;public static Connection getConnection() {10 &nbsp; try {11 &nbsp; return dataSource.getConnection();12 &nbsp; } catch (Exception e) {13 &nbsp; throw new RuntimeException(e);14 &nbsp; } &nbsp;15 &nbsp; }}DBUtilsjar：commons-dbutils.jar 核心类：QueryRunner、ResultSetHandlerQueryRunner方法：update()：DDL、DMLquery()：DQLbatch()：批处理增、删、改 xxxxxxxxxx71public void fun1() throws SQLException {2 &nbsp; &nbsp;QueryRunner qr = new QueryRunner();3 &nbsp; &nbsp;String sql = \"insert into user values(?,?,?)\";4 &nbsp; &nbsp;qr.update(JdbcUtils.getConnection()5 &nbsp; , sql, \"u1\", \"zhangSan\", \"123\");6}7​查 xxxxxxxxxx301DataSource ds = JdbcUtils.getDataSource();2​3QueryRunner qr = new QueryRunner(ds);4​5String sql = \"select * from tab_student\";6​7// 把结果集转换成Bean8​9Student stu = qr.query(sql, new BeanHandler&lt;Student&gt;(Student.class));10​11// 把结果集转换成Bean的List12​13List&lt;Student&gt; list = qr.query(sql, new BeanListHandler&lt;Student&gt;(Student.class));14​15// 把结果集转换成Map16​17Map&lt;String,Object&gt; map = qr.query(sql, new MapHandler());18​19// 把结果集转换成List&lt;Map&gt;20​21List&lt;Map&lt;String,Object&gt;&gt; list = qr.query(sql, new MapListHandler() );22​23// 把结果集转换成一列的List24​25List&lt;Object&gt; list = qr.query(sql, new ColumnListHandler(\"name\")) ;26​27// 把结果转换成单行单列的值28​29Number number = (Number)qr.query(sql, new ScalarHandler());30​批处理 xxxxxxxxxx131DataSource ds = JdbcUtils.getDataSource();2QueryRunner qr = new QueryRunner(ds);3String sql = \"insert into tab_student values(?,?,?,?)\";4Object[][] params = new Object[10][]; //表示 要插入10行记录5/**6 * Object[] parms = new Object{\"xxxx\",\"xxxx\"};7 * String[] s = new String{\"xxx\",\"xxx\"};8 */9for(int i = 0; i &lt; params.length; i++) {10 params[i] = new Object[]11 &nbsp; &nbsp; {\"S_300\" + i, \"name\" + i, 30 + i, i%2==0?\"男\":\"女\"};12}13qr.batch (sql, params);","categories":[],"tags":[]},{"title":"","slug":"sql/SQL面试语法","date":"2017-12-26T07:17:26.000Z","updated":"2017-12-26T07:18:38.000Z","comments":true,"path":"2017/12/26/sql/SQL面试语法/","link":"","permalink":"http://io.stelawliet.top/2017/12/26/sql/SQL面试语法/","excerpt":"","text":"DDL—数据定义语言(Create，Alter，Drop，DECLARE) DML—数据操纵语言(Select，Delete，Update，Insert) DCL—数据控制语言(GRANT，REVOKE，COMMIT，ROLLBACK) 首先,简要介绍基础语句：1、创建数据库Create DATABASE database-name2、删除数据库drop database dbname3、备份sql server— 创建备份数据的 deviceUSE masterEXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\\mssql7backup\\MyNwind_1.dat’— 开始备份BACKUP DATABASE pubs TO testBack4、创建新表create table tabname(col1 type1 [not null] [primary key],col2 type2 [notnull],..)根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… fromtab_old definition only5、删除新表drop table tabname6、增加一个列Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。7、添加主键： Alter table tabname add primary key(col)说明：删除主键： Alter table tabname drop primary key(col)8、创建索引：create [unique] index idxname on tabname(col….)删除索引：drop index idxname注：索引是不可更改的，想更改必须删除重新建。9、创建视图：create view viewname as select statement删除视图：drop view viewname10、几个简单的基本的sql语句选择：select from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table111、几个高级查询运算词 本帖隐藏的内容A： UNION 运算符UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。B： EXCEPT 运算符EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。C： INTERSECT 运算符INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。 12、使用外连接A、left outer join：左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。sql: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.cB：right outer join:右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。C：full outer join：全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。13、复制表(只复制结构,源表名：a 新表名：b) (Access可用)法一：select into b from a where 1&lt;&gt;1法二：select top 0 into b from a14、拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)insert into b(a, b, c) select d,e,f from b;15、跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件例子：..from b in’”&amp;Server.MapPath(“.”)&amp;”\\data.mdb”&amp;”‘ where..16、子查询(表名1：a 表名2：b)select a,b,c from a where a IN (select d from b ) 或者: selecta,b,c from a where a IN(1,2,3)17、显示文章、提交人和最后回复时间select a.title,a.username,b.adddate from table a,(select max(adddate) adddatefromtable where table.title=a.title) b18.外连接查询(表名1：a 表名2：b)select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c19、在线视图查询(表名1：a )select from (Select a,b,c FROM a) T where t.a &gt; 1;20、between的用法,between限制查询数据范围时包括了边界值,not between不包括select from table1 where time between time1 and time2select a,b,c, from table1 where a not between 数值1 and 数值221、：in 的使用方法select from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)22、：两张关联表，删除主表中已经在副表中没有的信息delete from table1 where not exists ( select from table2 wheretable1.field1=table2.field1 )23、四表联查问题：select from a left inner join b on a.a=b.b right inner join c on a.a=c.cinner joind on a.a=d.d where …..24、日程安排提前五分钟提醒sql: select from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;525、一条sql 语句搞定数据库分页select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段 26、前10条记录select top 10 * form table1 where 范围 27、选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)select a,b,c from tablename ta where a=(select max(a) from tablename tb wheretb.b=ta.b) 28、包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表(select a from tableA ) except (select a from tableB) except (select a from tableC) 29、随机取出10条数据select top 10 * from tablename order by newid() 30、随机选择记录select newid() 31、删除重复记录Delete from tablename where id not in (select max(id) from tablename group bycol1,col2,…) 32、列出数据库里所有的表名select name from sysobjects where type=’U’ 33、列出表里的所有的select name from syscolumns where id=object_id(‘TableName’) 34、列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablenamegroup by type显示结果：type vender pcs电脑 A 1电脑 A 1光盘 B 2光盘 A 2手机 B 3手机 C 3 35、初始化表 table1TRUNCATE TABLE table1","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/java1年经验之谈","date":"2017-12-15T06:39:45.000Z","updated":"2017-12-15T06:40:10.000Z","comments":true,"path":"2017/12/15/Java/JavaEE/java1年经验之谈/","link":"","permalink":"http://io.stelawliet.top/2017/12/15/Java/JavaEE/java1年经验之谈/","excerpt":"","text":"java后端工作一年浅谈经验转载 2017年08月27日 18:53:17 标签： java / 程序员 / 经验 / 技术 **185 1.引言 毕业已经一年有余，这一年里特别感谢技术管理人员的器重，以及同事的帮忙，学到了不少东西。这一年里走过一些弯路，也碰到一些难题，也受到过做为一名开发却经常为系统维护和发布当救火队员的苦恼。遂决定梳理一下自己所学的东西，为大家分享一下。 经过一年意识到以前也有很多认识误区，比如： 偏爱收集，经常收集各种资料视频塞满一个个硬盘，然后心满意足的看着容量不行动。 不重基础，总觉得很多基础东西不需要再看了，其实不懂的地方很多，计算机程序方面任何一个结果都必有原因，不要只会用不知道原理，那是加工厂出来的。现在ide查看代码那么方便，ctrl+点击就进入了JDK查看实现细节。 好高骛远，在计算机基础不牢固的情况下，总想着要做架构，弄分布式，搞大数据之类。 不重视性能，只求能实现功能，sql查询是不是可以优化，是否有算法妙用，大对象是否要清除。 不重视扩展性，模块之间紧密耦合，常用方法不提取成工具类，调用关系混乱等问题。 …… 本文重点不在这些，故只列举了一小部分，下面进入正题。 2.语法基础 2.1 Java类初始化顺序 这是所有情况的类初始化顺序，如果实际类中没有定义则跳过：父类静态变量——父类静态代码块——子类静态代码块——父类非静态变量——父类非静态代码块——父类构造函数——子类非静态变量——子类非静态代码块——子类构造函数 2.2值传递和引用传递 可能很多人对此不屑一顾，心想老子都工作一年了，对这些还不熟悉吗？但实际情况并非这样，JDK中东西全部熟悉了吗？以一个最简单的例子开始，你觉得下图中代码执行完之后fatherList中的元素是什么？ 这是一个最基础的值传递和引用传递的例子，你觉得好简单，已经想跃跃欲试的挑战了，那么请看下面的，StringBuffer很好理解，但是当你执行一遍之后发现是不是和预想中的输出不一样呢？String不是引用类型吗，怎么会这样呢？如果你无法理解，那么请看下String的实现源码，了解下其在内存中分配的实现原理。 2.3集合的使用 这部分几乎每个人都会用到，而且大家还都不陌生。下图来源于互联网，供大家复习一下。但是利用集合的特性进行巧妙的组合运用能解决优化很多复杂问题。Set不可重复性，List的顺序性，Map的键值对，SortSet/SortMap的有序性，我在工作中有很多复杂的业务都巧妙的使用了这些，涉及到公司保密信息，我就不贴出代码了。工作越久越发现这些和越巧妙。 2.3异常处理 1.看着try、catch、finally非常容易，如果和事务传播结合在一起，就会变得极其复杂。 2.finally不一定必须执行，return在catch/finally中处理情况（建议亲自操刀试一下）。 3.catch中可以继续抛自定义异常（并把异常一步步传递到控制层，利用切面抓取封装异常，返回给调用者）。 2.4面向对象思想 一提起面向对象，大家都知道抽象、封装、继承、和多态。但是实际工作经验中又知道多少呢，对于项目中如何巧用估计更不要提了。 共性的机会每个都需要用的建立基类，如每个控制层方法可能要通过security获取一个登录用户id，用于根据不同的用户操作不同的数据，可以抽象出一个应用层基类，实现获取id的protect方法。同理DAO层可以利用泛型提取出一个包含增删改查的基类。 多态的Override：基类的引用变量不仅可以指向基类的实例对象，也可以指向其子类的实例对象，如果指向子类的实例对象，其调用的方法应该是正在运行的那个对象的方法。在策略模式中使用很普遍。 提到面向对象，就不可避免的要说设计模式，在工作中，一个技术大牛写的一个类似策略模式（更复杂一点），十分巧妙的解决了各种业务同一个方法，并且实现了订单、工单、业务的解耦，看得我是非常佩服。我想很多面试中都会问道单例模式吧，还没有理解的建议去看一看。 3.多线程 3.1线程安全 这个是老生常谈的问题了，但是确实是问题和bug高发区。线程同步问题不需要单独写了，想必大家都清楚，不太熟悉的建议百度一下。 3.1.1 线程安全问题 1.代码中如果有同步操作，共享变量要特别注意（这个一般都能意识到） 2多个操作能修改数据表中同一条数据的。（这个容易被忽略，业务A可能操作表a，业务B也可以操作表a，业务A、B即使在不同的模块和方法中，也会引起线程安全问题。例如如果一个人访问业务A接口，另一个人访问业务B接口，在web中每个业务请求都是会有单独的一个线程进行处理的，就会出现线程安全问题）。 3.不安全的类型使用，例如StringBuffer、StringBuild，HashTable、HashMap等。在工作中我就遇到过有人在for循环进行list的remove，虽然编译器不报错，程序可以运行，但是结果却可想而知。 4.Spring的bean默认是单例的，如果有类变量就要特别小心了（一般情况下是没人在控制层、业务层、DAO层等用类变量的，用的话建议是final类型，例如日志log，gson等）。 5.多个系统共享数据库情况，这个其实和分布式系统类似 用户重复提交问题（即使代码中从数据库读取是否存在进行限制不能解决问题） 3.1.2线程安全解决 在需要同步的地方采用安全的类型。 JDK锁机制，lock、tryLock，synchronized，wait、notify、notifyAll等 Concurrent并发工具包，在处理一些问题上，谁用谁知道。强烈建议查看源码！ 数据表加锁。（除非某个表的访问频率极低，否则不建议使用） 涉及分布式的，采用中间件技术例如zookeeper等解决。 3.2异步 异步使用场景不影响主线程，且响应较慢的业务。例如IO操作，第三方服务（短信验证码、app推送、云存储上传等）。 如果异步任务很多，就需要使用任务队列了，任务队列可以在代码级别实现，也可以利用redis（优势太明显了）。 3.3多线程通信 这方面文章非常多，这里不在详述。 1.共享变量方式（共享文件、全局变量，信号量机制等） 2.消息队列方式 3.忙等，锁机制 3.4多线程实现 1.集成Thread类，重写（这里的重写指的是override）run方法，调用start方法执行。 2.实现Runable接口，实现run方法，以Runable实例创建thread对象。 3.实现Callable接口，实现call方法，FutureTask包装callable接口，FutureTask对象创建thread对象，常用语异步操作，建议使用匿名内部类，方便阅读和使用。 额外需要说明的是： 1.理解thread的join方法； 2.不要认为volitate是线程安全的（不明白原因的建议去看jvm运行时刻内存分配策略）； 3.sleep时间片结束后并不保证立马获取cpu。 4.ThreadLocal能够为每一个线程维护变量副本，常用于在多线程中用空间换时间。 4.开源框架 4.1 Hibernate、Mybatis 相信每一个java程序员对这些都不陌生，这里不再详述。 需要说明的主要以下几点： 1.hibernate一级缓存（内置session缓存），二级缓存（可装配sessionFactory缓存），二级缓存会引起并发问题。 2.hibernate延迟加载原理理解。 3.hibernate的get、load方法，sava、persist、savaOrUpdate方法区别 4.session重建了关联关系却并没有同数据库进行同步和更新 5.hibernate session关联关系：detached对象、persistent对象 6.Spring data集成，注解方式配置属性和实体。 7.mybatis插件。 8.分页查询（数据库）。 9.连接池技术 4.2 Spring IOC 4.1.1 Spring bean 1.bean注入注解方式方便易读，引用第三方（数据库连接，数据库连接池，JedisPool等）采用配置文件方式。 \\2. bean作用域：Singleton，prototype，request，session，global session 3.bean生命周期:如下图所示（图片来源于互联网）： 4.3 Spring AOP 基本概念：关注点、切面Aspect、切入点pointcut、连接点joinpoint、通知advice、织入weave、引入introduction。 Spring AOP支持5中类型通知，分别是MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice、MethodInterceptor、IntroductionInterceptor（吐槽一下名字太长） 实现方式如下: 1.基于代理的AOP 2.基于@Aspect注解驱动的切面。（强烈推荐：可读性好，易维护，易扩展，开发快） 3.纯POJO切面。 4.注入式Aspect切面。 4.4 Srping事务 4.4.1事务传播 概念：某些操作需要保证原子性，如果中间出错，需要事务回滚。如果某个事务回滚，那么调用该事务的方法中的事务的作出如何的动作，就是事务传播。 短时间内写不清楚，建议访问 http://www.cnblogs.com/yangy608/archive/2010/12/15/1907065.html 查看。 事务传播属性： PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 \\2. PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。 \\3. PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。 \\4. PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。 \\5. PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 \\6. PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。 事务隔离级别： ISOLATION_DEFAULT：这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应 \\2. ISOLATION_READ_UNCOMMITTED：这是事务最低的隔离级别，充许令外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 \\3. ISOLATION_READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据 \\4. ISOLATION_REPEATABLE_READ：这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。 \\5. ISOLATION_SERIALIZABLE这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。 4.5其他Spring 技术栈 spring boot轻量级启动框架 spring security用户权限管理，根据角色和用户，实现UserDetailsService，进行自定义权限管理。 spring task代码级定时任务，注解方式，使用起来非常方便。需要注意的是，如果某次定时任务出了异常而没有进行处理，会导致接下来定时任务失效。如果各个任务相互独立，可以简单用try，catch包围（之前就吃过这方面的亏）。 spring data注解方式定义实体，属性等 spring mvc简单明了的mvc框架。url传值、数组传值、对象传值、对象数组等传值类型，上传/下载文件类型需要注意。 spring restful注意命名，对命名要求很严格。 spring shell命令行方式执行命令，救火、导入导出数据等用起来非常方便、制作报表。 \\5. Web基础 5.1 web容器启动 1.web.xml加载顺序: listener -&gt; filter -&gt;servlet 2.webt容器启动过程，java新手很怕配置文件，理解完这些有助于熟悉配置文件 http://blog.csdn.net/u014431852/article/details/47042895 5.2 Servlet、Interceptor、Listener、Filter Servlet接收请求返回响应，最原始的web业务处理类。 Interceptor拦截器，可以实现HandlerInterceptor接口自定义拦截器，在日志记录、权限检查、性能监控、通用行为等场景使用，本质是AOP。 Listener监听器常用于统计在线人数等纵向功能。 Filter过滤器在请求接口处理业务之前改变requset，在业务处理之后响应用户之前改变response。如果某些数据不加密，很容易用抓包工具加filter作弊。 5.3 web项目结构 5.3.1 mvn结构 熟练掌握几种常见的mvn项目结构，mvn可以自动生成，这里不再详述。 5.3.2 mvn包管理 1.版本号尽量几种在一个文件中便于管理。 2.spring milestone包解决spring包冲突问题。 3.mvn dependency:tree命令分析所有包依赖，对于冲突的在pom文件中包围起来 5.3.3版本控制 1.git、svn等 2.代码冲突解决方案 3.分支管理。 对于某个稳定版本上线后，如果在此基础上开发新功能，一定要新建分支，在新分支上提交代码，最后在新版发布时合并分支。修改运营环境bug切换到主分支进行修改 5.4 Http请求 5.4.1请求方法 post、get、put、head、delete、copy、move、connect、link、patch，最常用的是前4、5个。 5.4.2请求头，状态码 常用的请求头有Accept（下载文件会特殊使用）、Accept-Charset（设置utf-8字符集）、Content-Type（json等配置）等 常用的响应头有Content-Type、Content-Type、Content-Length等，偏前端，不再详述。 6.系统架构 接触的不是特别多，目前用到的只是服务器主从备份。Nginx反向代理进行配置。 多个项目nginx配置 Spring Mvc用json数据进行交互，配置json转换的servlet。 封装返回值 自定义RunEnvironmentException（状态码，原因），覆盖原有Exception，切面ExceptionHandler抓取Exception并封装到返回值中（前后端松耦合） 令人头疼的用户重复（连续快速点击）提交问题，前端限制治标不治本；后端用sessonid在切面上实现，又需要前端存储，对所有请求数据加sessionId。最后用jedis中存储，用接口名+用户名当做key，根据不同的接口对不同的key可以单独设置时间，不仅保证了重复提交问题，也避免了恶意请求问题，同时还能自定义请求间隔。（期初担心redis缓存读写时间延误导致限制失效，后来发现多虑了，对一般的小系统来说，经性能测试，发现即使请求频率再提高100被也不会导致限制失效） testNg单元测试、性能测试，覆盖测试。 切面管理日期、权限。缓存等。 \\7. Nosql 1.Redis的java库Jedis。 Jedispool配置。 项目中用到的有任务队列、缓存。 neo4j图数据库 处理社交、推荐 8.服务端 linux操作系统熟悉以centos为例： 常用简单命令：ssh、vim、scp、ps、gerp、sed、awk、cat、tail，df、top，shell、chmod、sh、tar、find、wc、ln、| 目录结构明细:/etc/、~/、/usr/、/dev/、/home/、/etc/init.d/ 服务端：jdk、tomcat、nginx、mysql、jedis、neo4j启动与配置（特别说明的是该死的防火墙，nginx启动后一直访问不了，查找一下午查不到原因，最后发现是防火墙问题） 监控服务器状态（cpu，磁盘，内存），定位pid，日志查看 nginx负载均衡、反向代理、配置 自动化部署脚本 简单shell脚本书写，避免大量人力劳动。 监控系统，代码抛fatal异常自动发邮件，系统指标持续偏高自动发邮件。 9.数据库相关 10.第三方接口对接 10.1支付接口 微信支付坑比较多，用将近两周时间才把微信支付所有完成。需要在微信后台配置的地方太多。 而支付宝支付模块只用了2天时间就搞定了。 10.2推送接口 为用户定义tag、定义alias，注意当数据更新时需要同步更新tag、更新alias。如果没采用异步实现（用户体验就是好卡啊） 10.3云存储 大量文件上传云端（七牛云），注意创建bucket 10.4短信验证 很简单的第三方接口，引入依赖，直接调用即可。需要在第三方后台设置模板等，注意限定用户访问次数。 10.5邮件 很简单小功能，工具类。 时间有限，目前先写这么多技术栈。对于代码书写和、算法技巧问题，会抽时间写在（2）中。 好了同学们，我能介绍的也都全部介绍完给你们了，如果下获得更多JAVA教学资源，可以选择来我们这里共同交流，群：24044837，很多大神在这里切磋学习，不懂可以直接问，晚上还有大牛免费直播教学。注：加群要求1、具有一定工作经验的，面对目前流行的技术不知从何下手，需要突破技术瓶颈的可以加，有些应届生和实习生也可以加。2、在公司待久了，过得很安逸，但跳槽时面试碰壁。需要在短时间内进修、跳槽拿高薪的可以加。3、如果没有工作经验，但基础非常扎实，对java工作机制，常用设计思想，常用java开发框架掌握熟练的，可以加。4、觉得自己很牛B，一般需求都能搞定。但是所学的知识点没有系统化，很难在技术领域继续突破的可以加。5.阿里Java高级大牛直播讲解知识点，分享知识，多年工作经验的梳理和总结，带着大家全面、科学地建立自己的技术体系和技术认知！PS：现在主要讲解的内容是（反射原理、枚举原理与应用、注解原理、常用设计模式、正规表达式高级应用、JAVA操作Office原理详解、JAVA图像处理技术，等多个知识点的详解和实战）6.小号或者小白之类加群一律不给过，谢谢。最后，每一位读到这里的网友，感谢你们能耐心地看完。觉得对你有帮助可以给个喜欢！希望在成为一名更优秀的Java程序员的道路上，我们可以一起学习、一起进步","categories":[],"tags":[]},{"title":"","slug":"JavaScript/emmt","date":"2017-12-05T16:49:22.000Z","updated":"2017-12-05T16:49:39.000Z","comments":true,"path":"2017/12/06/JavaScript/emmt/","link":"","permalink":"http://io.stelawliet.top/2017/12/06/JavaScript/emmt/","excerpt":"","text":"原创新闻](http://www.iteye.com/images/news/ori.gif?1448702469) [Emmet：HTML/CSS代码快速编写神器 2013-04-16 17:40 by 副主编 wangguo 评论(17) 有375673人浏览 html css Emmet Zen coding 声明：ITeye资讯文章的版权属于ITeye网站所有，严禁任何网站转载本文，否则必将追究法律责任！相关知识库： [ img](http://img.knowledge.csdn.net/upload/base/1467787369452_452.jpg) HTML5知识库 Zen coding下的编码演示 但Emmet不只改名，还带来了一些新特性。本文就来直观地演示给你。 一、快速编写HTML代码 初始化 html:5 或!：用于HTML5文档类型 html:xt：用于XHTML过渡文档类型 html:4s：用于HTML4严格文档类型 轻松添加类、id、文本和属性 Html代码 Html代码 foo 嵌套 >：子元素符号，表示嵌套的元素 +：同级标签符号 ^：可以使该符号前的标签提升一行 分组 Html代码 隐式标签 li：用于ul和ol中 tr：用于table、tbody、thead和tfoot中 td：用于tr中 option：用于select和optgroup中 定义多个元素 Html代码 定义多个带属性的元素 Html代码 二、CSS缩写 值 Css代码 width: 100px; Css代码 height: 10%; margin: 5em; p 表示% e 表示 em x 表示 ex 附加属性 Css代码 @font-face { font-family:; src:url(); } Css代码 @font-face { font-family: ‘FontName’; src: url(‘FileName.eot’); src: url(‘FileName.eot?#iefix’) format(‘embedded-opentype’), ​ url(‘FileName.woff’) format(‘woff’), ​ url(‘FileName.ttf’) format(‘truetype’), ​ url(‘FileName.svg#FontName’) format(‘svg’); font-style: normal; font-weight: normal; } 模糊匹配 Css代码 overflow: hidden; 供应商前缀 Css代码 -webkit-transform: ; -moz-transform: ; -ms-transform: ; -o-transform: ; transform: ; Css代码 -webkit-super-foo: ; -moz-super-foo: ; -ms-super-foo: ; -o-super-foo: ; super-foo: ; Css代码 -webkit-transform: ; -moz-transform: ; transform: ; w 表示 -webkit- m 表示 -moz- s 表示 -ms- o 表示 -o- 渐变 Css代码 background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000)); background-image: -webkit-linear-gradient(left, #fff 50%, #000); background-image: -moz-linear-gradient(left, #fff 50%, #000); background-image: -o-linear-gradient(left, #fff 50%, #000); background-image: linear-gradient(left, #fff 50%, #000); 三、附加功能 生成Lorem ipsum文本 引用 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus. img 四、定制 添加新缩写或更新现有缩写，可修改snippets.json文件 更改Emmet过滤器和操作的行为，可修改preferences.json文件 定义如何生成HTML或XML代码，可修改syntaxProfiles.json文件","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/class文件路径","date":"2017-11-28T05:34:42.000Z","updated":"2018-07-02T01:18:44.000Z","comments":true,"path":"2017/11/28/Java/JavaEE/class文件路径/","link":"","permalink":"http://io.stelawliet.top/2017/11/28/Java/JavaEE/class文件路径/","excerpt":"","text":"Class.getResource和ClassLoader.getResource的使用 参考 Class.getResource(String path)12path不以’/&apos;开头时，默认是从此类所在的包下取资源；path 以’/&apos;开头时，则是从ClassPath根下获取； 什么意思呢？看下面这段代码的输出结果就明白了： 1234567package testpackage;public class TestMain &#123; public static void main(String[] args) &#123; System.out.println(TestMain.class.getResource(&quot;&quot;)); System.out.println(TestMain.class.getResource(&quot;/&quot;)); &#125;&#125; 输出结果： 12file:/E:/workspace/Test/WebRoot/WEB-INF/classes/testpackage/file:/E:/workspace/Test/WebRoot/WEB-INF/classes/ getclass.getResource(&quot;&quot;)为当前类的包根路径 getClass.getRessource(&quot;/&quot;)为classpath根路径 ※Class.getResource和Class.getResourceAsStream在使用时，路径选择上是一样的。 Class.getClassLoader（）.getResource(String path)12path不能以’/&apos;开头时；path是从ClassPath根下获取； Class.getClassLoader().getResource(&quot;&quot;) == xxClass.getResource(&quot;/&quot;) 注： Windows绝对路径： 以盘符开始 如C:/a.txt Windows相对路径： . 指的是当前目录 .. 指的是当前目录的上一级目录 ./test 表示当前目录下的test文件夹 /test 表示当前盘符下的test文件夹 Linux绝对路径： 以root根目录/开始的路径 如/ 表示root根目录 Linux相对路径： ./ 指的是当前目录 ../ 指的是当前目录的上一级目录 .代表当前目录，..代表上级目录 好像是统一的。 在windows或者Linux获取配置文件如：.properties文件时 使用Class.getResource或者ClassLoader.getResource获取绝对路径classpath时返回的值如下不同 Windows输出 Linux输出 因此获取绝对路径的截取的也就不同 ※Class.getClassLoader（）.getResource和Class.getClassLoader（）.getResourceAsStream在使用时，路径选择上也是一样的。 getResourceAsStream()方法，参数是与getResouce()方法是一样的，它相当于你用getResource()取得File文件后，再new InputStream(file) 总结： Xxx.class.getResource(“”) ; Xxx.class.getResource(“/“)或者Xxx.class.getClassLoader().getgetResource(“”);; xxx.getClass.getResource(“”) ; xxx.getClass.getResource(“/“)或者xxx.getClass.getClassLoader().getgetResource(“”); 1234567891011121314151617181920212223242526272829知识扩充：linux下没有C、D盘等硬盘分区的概念。linux下是采用目录形式来代替windows中硬盘分区的概念。linux文件结构/：根目录，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。/bin：bin 就是二进制（binary）英文缩写。在一般的系统当中，都可以在这个目录下找到linux常用的命令。系统所需要的那些命令位于此目录。/boot：Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录。/cdrom：这个目录在刚刚安装系统的时候是空的。可以将光驱文件系统挂在这个目录下。例如：mount /dev/cdrom /cdrom/dev：dev 是设备（device)的英文缩写。这个目录对所有的用户都十分重要。因为在这个目录中包含了所有linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序。这一点和常用的windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。/etc：etc这个目录是linux系统中最重要的目录之一。在这个目录下存放了系统管理时要用到的各种配置文件和子目录。要用到的网络配置文件，文件系统，x系统配置文件，设备配置信息，设置用户信息等都在这个目录下。/home：如果建立一个用户，用户名是&quot;xx&quot;,那么在/home目录下就有一个对应的/home/xx路径，用来存放用户的主目录。/lib：lib是库（library）英文缩写。这个目录是用来存放系统动态连接共享库的。几乎所有的应用程序都会用到这个目录下的共享库。因此，千万不要轻易对这个目录进行什么操作，一旦发生问题，系统就不能工作了。/lost+found：在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。/mnt：这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom等目录。可以参看/etc/fstab的定义。/media：有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。/opt：这里主要存放那些可选的程序。/proc：可以在这个目录下获取系统信息。这些信息是在内存中，由系统自己产生的。/root：Linux超级权限用户root的家目录。/sbin：这个目录是用来存放系统管理员的系统管理程序。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的，凡是目录sbin中包含的都是root权限才能执行的。/selinux ：对SElinux的一些配置文件目录，SElinux可以让linux更加安全。/srv 服务启动后，所需访问的数据目录，举个例子来说，www服务启动读取的网页数据就可以放在/srv/www中/tmp：临时文件目录，用来存放不同程序执行时产生的临时文件。有时用户运行程序的时候，会产生临时文件。/tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。/usr这是linux系统中占用硬盘空间最大的目录。用户的很多应用程序和文件都存放在这个目录下。在这个目录下，可以找到那些不适合放在/bin或/etc目录下的额外的工具/usr/local：这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts)放到/usr/local目录下面、。/usr/share ：系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。/var：这个目录的内容是经常变动的，看名字就知道，可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/ www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地。","categories":[],"tags":[]},{"title":"","slug":"JavaScript/js","date":"2017-11-24T15:12:59.000Z","updated":"2017-11-24T15:13:20.000Z","comments":true,"path":"2017/11/24/JavaScript/js/","link":"","permalink":"http://io.stelawliet.top/2017/11/24/JavaScript/js/","excerpt":"","text":"ssssyoki2017 年 11 月 21 日 这一次，彻底弄懂 JavaScript 执行机制本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。 不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论： javascript是按照语句出现的顺序执行的 看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的： 12345let a = &apos;1&apos;;console.log(a);let b = &apos;2&apos;;console.log(b); img 然而实际上js是这样的： 1234567891011121314setTimeout(function()&#123; console.log(&apos;定时器开始啦&apos;)&#125;);new Promise(function(resolve)&#123; console.log(&apos;马上执行for循环啦&apos;); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log(&apos;执行then函数啦&apos;)&#125;);console.log(&apos;代码执行结束&apos;); img 依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果： 1234//&quot;定时器开始啦&quot;//&quot;马上执行for循环啦&quot;//&quot;执行then函数啦&quot;//&quot;代码执行结束&quot; 去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？ img 我们真的要彻底弄明白javascript的执行机制了。 1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： img 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log(&apos;发送成功!&apos;); &#125;&#125;)console.log(&apos;代码执行结束&apos;); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： 123setTimeout(() =&gt; &#123; console.log(&apos;延时3秒&apos;);&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： 1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log(&apos;执行console&apos;); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码： 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 12345//代码1console.log(&apos;先执行这里&apos;);setTimeout(() =&gt; &#123; console.log(&apos;执行啦&apos;)&#125;,0); 12345//代码2console.log(&apos;先执行这里&apos;);setTimeout(() =&gt; &#123; console.log(&apos;执行啦&apos;)&#125;,3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;promise&apos;);&#125;).then(function() &#123; console.log(&apos;then&apos;);&#125;)console.log(&apos;console&apos;); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： img 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); process.nextTick(function() &#123; console.log(&apos;3&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&apos;6&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;8&apos;)&#125;)setTimeout(function() &#123; console.log(&apos;9&apos;); process.nextTick(function() &#123; console.log(&apos;10&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;11&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;12&apos;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制 牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！","categories":[],"tags":[]},{"title":"","slug":"JavaScript/JavaScript复习","date":"2017-11-21T09:22:48.000Z","updated":"2017-11-22T09:38:41.000Z","comments":true,"path":"2017/11/21/JavaScript/JavaScript复习/","link":"","permalink":"http://io.stelawliet.top/2017/11/21/JavaScript/JavaScript复习/","excerpt":"","text":"JavaScript内置对象 switch Java SDF ​ javascript 事件 Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 事件句柄 (Event Handlers)HTML 4.0 的新特性之一是能够使 HTML 事件触发浏览器中的行为，比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，可将之插入 HTML 标签以定义事件的行为。 | 属性 | 此事件发生在何时… || —————————————- | —————— || onabort | 图像的加载被中断。 || onblur | 元素失去焦点。 || onchange | 域的内容被改变。 || onclick | 当用户点击某个对象时调用的事件句柄。 || ondblclick | 当用户双击某个对象时调用的事件句柄。 || onerror | 在加载文档或图像时发生错误。 || onfocus | 元素获得焦点。 || onkeydown | 某个键盘按键被按下。 || onkeypress | 某个键盘按键被按下并松开。 || onkeyup | 某个键盘按键被松开。 || onload | 一张页面或一幅图像完成加载。 || onmousedown | 鼠标按钮被按下。 || onmousemove | 鼠标被移动。 || onmouseout | 鼠标从某元素移开。 || onmouseover | 鼠标移到某元素之上。 || onmouseup | 鼠标按键被松开。 || onreset | 重置按钮被点击。 || onresize | 窗口或框架被重新调整大小。 || onselect | 文本被选中。 || onsubmit | 确认按钮被点击。 || onunload | 用户退出页面。 | 鼠标 / 键盘属性| 属性 | 描述 || —————————————- | ————————- || altKey | 返回当事件被触发时，”ALT” 是否被按下。 || button | 返回当事件被触发时，哪个鼠标按钮被点击。 || clientX | 返回当事件被触发时，鼠标指针的水平坐标。 || clientY | 返回当事件被触发时，鼠标指针的垂直坐标。 || ctrlKey | 返回当事件被触发时，”CTRL” 键是否被按下。 || metaKey | 返回当事件被触发时，”meta” 键是否被按下。 || relatedTarget | 返回与事件的目标节点相关的节点。 || screenX | 返回当某个事件被触发时，鼠标指针的水平坐标。 || screenY | 返回当某个事件被触发时，鼠标指针的垂直坐标。 || shiftKey | 返回当事件被触发时，”SHIFT” 键是否被按下。 | IE 属性除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性： | 属性 | 描述 || ————— | —————————————- || cancelBubble | 如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。 || fromElement | 对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。 || keyCode | 对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。 || offsetX,offsetY | 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。 || returnValue | 如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。 || srcElement | 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。 || toElement | 对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。 || x,y | 事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。 | ​","categories":[],"tags":[]},{"title":"","slug":"JavaScript/html复习","date":"2017-11-19T11:48:56.000Z","updated":"2017-11-19T11:48:56.000Z","comments":true,"path":"2017/11/19/JavaScript/html复习/","link":"","permalink":"http://io.stelawliet.top/2017/11/19/JavaScript/html复习/","excerpt":"","text":"html复习 &lt;a&gt; target 1234567891011&lt;html&gt; &lt;head&gt; &lt;!--html注释--&gt; &lt;title&gt;this is a title&lt;/title&gt; &lt;meta http-equiv=\"content-type\"content=\"text/html;charset=utf-8\"/&gt; &lt;/head&gt; &lt;a name=\"top\"&gt;&lt;/a&gt; &lt;!-- --&gt; &lt;a href=\"o3.html#top\" target=\"_blank\"&gt;top&lt;/a&gt;&amp;nbsp; &lt;/html&gt; &lt;img&gt; alt &lt;frame&gt; cosl rowl &lt;link href=&quot;01.css&quot; rel=&quot;stylesheet&quot;/&gt; 引入css文件 盒子模型重新 norepeat","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/day22test","date":"2017-11-14T11:39:35.000Z","updated":"2017-11-14T11:39:35.000Z","comments":true,"path":"2017/11/14/Java/JavaEE/day22test/","link":"","permalink":"http://io.stelawliet.top/2017/11/14/Java/JavaEE/day22test/","excerpt":"","text":"day22 body { font-family: Helvetica, arial, sans-serif; font-size: 14px; line-height: 1.6; padding-top: 10px; padding-bottom: 10px; background-color: white; padding: 30px; } body > *:first-child { margin-top: 0 !important; } body > *:last-child { margin-bottom: 0 !important; } a { color: #4183C4; } a.absent { color: #cc0000; } a.anchor { display: block; padding-left: 30px; margin-left: -30px; cursor: pointer; position: absolute; top: 0; left: 0; bottom: 0; } h1, h2, h3, h4, h5, h6 { margin: 20px 0 10px; padding: 0; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text; position: relative; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center; text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { font-size: 28px; color: black; } h2 { font-size: 24px; border-bottom: 1px solid #cccccc; color: black; } h3 { font-size: 18px; } h4 { font-size: 16px; } h5 { font-size: 14px; } h6 { color: #777777; font-size: 14px; } p, blockquote, ul, ol, dl, li, table, pre { margin: 15px 0; } hr { background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0; border: 0 none; color: #cccccc; height: 4px; padding: 0; } body > h2:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child + h2 { margin-top: 0; padding-top: 0; } body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0; padding-top: 0; } a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0; padding-top: 0; } h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0; } li p.first { display: inline-block; } li { margin: 0; } ul, ol { padding-left: 30px; } ul :first-child, ol :first-child { margin-top: 0; } dl { padding: 0; } dl dt { font-size: 14px; font-weight: bold; font-style: italic; padding: 0; margin: 15px 0 5px; } dl dt:first-child { padding: 0; } dl dt > :first-child { margin-top: 0; } dl dt > :last-child { margin-bottom: 0; } dl dd { margin: 0 0 15px; padding: 0 15px; } dl dd > :first-child { margin-top: 0; } dl dd > :last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #dddddd; padding: 0 15px; color: #777777; } blockquote > :first-child { margin-top: 0; } blockquote > :last-child { margin-bottom: 0; } table { padding: 0;border-collapse: collapse; } table tr { border-top: 1px solid #cccccc; background-color: white; margin: 0; padding: 0; } table tr:nth-child(2n) { background-color: #f8f8f8; } table tr th { font-weight: bold; border: 1px solid #cccccc; margin: 0; padding: 6px 13px; } table tr td { border: 1px solid #cccccc; margin: 0; padding: 6px 13px; } table tr th :first-child, table tr td :first-child { margin-top: 0; } table tr th :last-child, table tr td :last-child { margin-bottom: 0; } img { max-width: 100%; } span.frame { display: block; overflow: hidden; } span.frame > span { border: 1px solid #dddddd; display: block; float: left; overflow: hidden; margin: 13px 0 0; padding: 7px; width: auto; } span.frame span img { display: block; float: left; } span.frame span span { clear: both; color: #333333; display: block; padding: 5px 0 0; } span.align-center { display: block; overflow: hidden; clear: both; } span.align-center > span { display: block; overflow: hidden; margin: 13px auto 0; text-align: center; } span.align-center span img { margin: 0 auto; text-align: center; } span.align-right { display: block; overflow: hidden; clear: both; } span.align-right > span { display: block; overflow: hidden; margin: 13px 0 0; text-align: right; } span.align-right span img { margin: 0; text-align: right; } span.float-left { display: block; margin-right: 13px; overflow: hidden; float: left; } span.float-left span { margin: 13px 0 0; } span.float-right { display: block; margin-left: 13px; overflow: hidden; float: right; } span.float-right > span { display: block; overflow: hidden; margin: 13px auto 0; text-align: right; } code, tt { margin: 0 2px; padding: 0 5px; white-space: nowrap; border: 1px solid #eaeaea; background-color: #f8f8f8; border-radius: 3px; } pre code { margin: 0; padding: 0; white-space: pre; border: none; background: transparent; } .highlight pre { background-color: #f8f8f8; border: 1px solid #cccccc; font-size: 13px; line-height: 19px; overflow: auto; padding: 6px 10px; border-radius: 3px; } pre { background-color: #f8f8f8; border: 1px solid #cccccc; font-size: 13px; line-height: 19px; overflow: auto; padding: 6px 10px; border-radius: 3px; } pre code, pre tt { background-color: transparent; border: none; } sup { font-size: 0.83em; vertical-align: super; line-height: 0; } kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb } * { -webkit-print-color-adjust: exact; } @media screen and (min-width: 914px) { body { width: 854px; margin:0 auto; } } @media print { table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } /** * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML * Based on https://github.com/chriskempson/tomorrow-theme * @author Rose Pritchard */ code[class*=\"language-\"], pre[class*=\"language-\"] { color: #ccc; background: none; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; word-wrap: normal; line-height: 1.5; -moz-tab-size: 4; -o-tab-size: 4; tab-size: 4; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; } /* Code blocks */ pre[class*=\"language-\"] { padding: 1em; margin: .5em 0; overflow: auto; } :not(pre) > code[class*=\"language-\"], pre[class*=\"language-\"] { background: #2d2d2d; } /* Inline code */ :not(pre) > code[class*=\"language-\"] { padding: .1em; border-radius: .3em; white-space: normal; } .token.comment, .token.block-comment, .token.prolog, .token.doctype, .token.cdata { color: #999; } .token.punctuation { color: #ccc; } .token.tag, .token.attr-name, .token.namespace, .token.deleted { color: #e2777a; } .token.function-name { color: #6196cc; } .token.boolean, .token.number, .token.function { color: #f08d49; } .token.property, .token.class-name, .token.constant, .token.symbol { color: #f8c555; } .token.selector, .token.important, .token.atrule, .token.keyword, .token.builtin { color: #cc99cd; } .token.string, .token.char, .token.attr-value, .token.regex, .token.variable { color: #7ec699; } .token.operator, .token.entity, .token.url { color: #67cdcc; } .token.important, .token.bold { font-weight: bold; } .token.italic { font-style: italic; } .token.entity { cursor: help; } .token.inserted { color: green; } 番茄花园 Lawliet L 2 7062 2017-11-14T11:33:00Z 2017-11-14T11:33:00Z 26 3384 19291 番茄花园 160 45 22630 15.0 96 800x600 &lt;![if !supportAnnotations]&gt; &lt;![endif]&gt; day22总结 文件上传概述 &nbsp; 1 文件上传的作用 例如网络硬盘！就是用来上传下载文件的。 在智联招聘上填写一个完整的简历还需要上传照片呢。 &nbsp; 2 文件上传对页面的要求 上传文件的要求比较多，需要记一下： 1.&nbsp;&nbsp;&nbsp;&nbsp; 必须使用表单，而不能是超链接； 2.&nbsp;&nbsp;&nbsp;&nbsp; 表单的method必须是POST，而不能是GET； 3.&nbsp;&nbsp;&nbsp;&nbsp; 表单的enctype必须是multipart/form-data； 4.&nbsp;&nbsp;&nbsp;&nbsp; 在表单中添加file表单字段，即&lt;input type=”file”…/&gt; &nbsp; &lt;form action=&ldquo;${pageContext.request.contextPath }/FileUploadServlet&rdquo; method=&ldquo;post&rdquo; enctype=&ldquo;multipart/form-data&rdquo;&gt; 用户名：&lt;input type=&ldquo;text&rdquo; name=&ldquo;username&rdquo;/&gt;&lt;br/&gt; 文件1：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file1&rdquo;/&gt;&lt;br/&gt; 文件2：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file2&rdquo;/&gt;&lt;br/&gt; &lt;input type=&ldquo;submit&rdquo; value=&ldquo;提交&rdquo;/&gt; &lt;/form&gt; &nbsp; 3 比对文件上传表单和普通文本表单的区别 通过httpWatch查看“文件上传表单”和“普通文本表单”的区别。 l&nbsp; 文件上传表单的enctype=”multipart/form-data”，表示多部件表单数据； l&nbsp; 普通文本表单可以不设置enctype属性： Ø&nbsp; 当method=”post”时，enctype的默认值为application/x-www-form-urlencoded，表示使用url编码正文； Ø&nbsp; 当method=”get”时，enctype的默认值为null，没有正文，所以就不需要enctype了。 &nbsp; 对普通文本表单的测试： &lt;form action=&ldquo;${pageContext.request.contextPath }/FileUploadServlet&rdquo; method=&ldquo;post&rdquo;&gt; 用户名：&lt;input type=&ldquo;text&rdquo; name=&ldquo;username&rdquo;/&gt;&lt;br/&gt; 文件1：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file1&rdquo;/&gt;&lt;br/&gt; 文件2：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file2&rdquo;/&gt;&lt;br/&gt; &lt;input type=&ldquo;submit&rdquo; value=&ldquo;提交&rdquo;/&gt; &lt;/form&gt; &nbsp; &nbsp; 通过httpWatch测试，查看表单的请求数据正文，我们发现请求中只有文件名称，而没有文件内容。也就是说，当表单的enctype不是multipart/form-data时，请求中不包含文件内容，而只有文件的名称，这说明普通文本表单中input:file与input:text没什么区别了。 &nbsp; 对文件上传表单的测试： &lt;form action=&ldquo;${pageContext.request.contextPath }/FileUploadServlet&rdquo; method=&ldquo;post&rdquo; enctype=&ldquo;multipart/form-data&rdquo;&gt; 用户名：&lt;input type=&ldquo;text&rdquo; name=&ldquo;username&rdquo;/&gt;&lt;br/&gt; 文件1：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file1&rdquo;/&gt;&lt;br/&gt; 文件2：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file2&rdquo;/&gt;&lt;br/&gt; &lt;input type=&ldquo;submit&rdquo; value=&ldquo;提交&rdquo;/&gt; &lt;/form&gt; &nbsp; &nbsp; 通过httpWatch测试，查看表单的请求数据正文部分，发现正文部分是由多个部件组成，每个部件对应一个表单字段，每个部件都有自己的头信息。头信息下面是空行，空行下面是字段的正文部分。多个部件之间使用随机生成的分隔线隔开。 文本字段的头信息中只包含一条头信息，即Content-Disposition，这个头信息的值有两个部分，第一部分是固定的，即form-data，第二部分为字段的名称。在空行后面就是正文部分了，正文部分就是在文本框中填写的内容。 文件字段的头信息中包含两条头信息，Content-Disposition和Content-Type。Content-Disposition中多出一个filename，它指定的是上传的文件名称。而Content-Type指定的是上传文件的类型。文件字段的正文部分就是文件的内容。 &nbsp; 请注意，因为我们上传的文件都是普通文本文件，即txt文件，所以在httpWatch中是可以正常显示的，如果上传的是exe、mp3等文件，那么在httpWatch看到的就是乱码了。 &nbsp; 4 文件上传对Servlet的要求 当提交的表单是文件上传表单时，那么对Servlet也是有要求的。 首先我们要肯定一点，文件上传表单的数据也是被封装到request对象中的。 request.getParameter(String)方法获取指定的表单字段字符内容，但文件上传表单已经不在是字符内容，而是字节内容，所以失效。 &nbsp; 这时可以使用request的getInputStream()方法获取ServletInputStream对象，它是InputStream的子类，这个ServletInputStream对象对应整个表单的正文部分（从第一个分隔线开始，到最后），这说明我们需要的解析流中的数据。当然解析它是很麻烦的一件事情，而Apache已经帮我们提供了解析它的工具：commons-fileupload。 &nbsp; 可以尝试把request.getInputStream()这个流中的内容打印出来，再对比httpWatch中的请求数据。 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { InputStream in = request.getInputStream(); String s = IOUtils.toString(in);[崔1]&nbsp; System.out.println(s); } &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;7ddd3370ab2 Content-Disposition: form-data; name=&ldquo;username&rdquo; &nbsp; hello &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;7ddd3370ab2 Content-Disposition: form-data; name=&ldquo;file1&rdquo;; filename=&ldquo;a.txt&rdquo; Content-Type: text/plain &nbsp; aaa &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;7ddd3370ab2 Content-Disposition: form-data; name=&ldquo;file2&rdquo;; filename=&ldquo;b.txt&rdquo; Content-Type: text/plain &nbsp; bbb &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;7ddd3370ab2&ndash; &nbsp; commons-fileupload &nbsp; 为什么使用fileupload： 上传文件的要求比较多，需要记一下： l&nbsp; 必须是POST表单； l&nbsp; 表单的enctype必须是multipart/form-data； l&nbsp; 在表单中添加file表单字段，即&lt;input type=”file”…/&gt; &nbsp; Servlet的要求： l&nbsp; 不能再使用request.getParameter()来获取表单数据； l&nbsp; 可以使用request.getInputStream()得到所有的表单数据，而不是一个表单项的数据； l&nbsp; 这说明不使用fileupload，我们需要自己来对request.getInputStream()的内容进行解析！！！ &nbsp; &nbsp; 1 fileupload概述 fileupload是由apache的commons组件提供的上传组件。它最主要的工作就是帮我们解析request.getInputStream()。 fileupload组件需要的JAR包有： l&nbsp; commons-fileupload.jar，核心包； l&nbsp; commons-io.jar，依赖包。 &nbsp; 2 fileupload简单应用 fileupload的核心类有：DiskFileItemFactory、ServletFileUpload、FileItem。 使用fileupload组件的步骤如下： 1.&nbsp;&nbsp;&nbsp;&nbsp; 创建工厂类DiskFileItemFactory对象：DiskFileItemFactory factory = new DiskFileItemFactory() 2.&nbsp;&nbsp;&nbsp;&nbsp; 使用工厂创建解析器对象：ServletFileUpload fileUpload = new ServletFileUpload(factory) 3.&nbsp;&nbsp;&nbsp;&nbsp; 使用解析器来解析request对象：List&lt;FileItem&gt; list = fileUpload.parseRequest(request) &nbsp; 隆重介绍FileItem类，它才是我们最终要的结果。一个FileItem对象对应一个表单项（表单字段）。一个表单中存在文件字段和普通字段，可以使用FileItem类的isFormField()方法来判断表单字段是否为普通字段，如果不是普通字段，那么就是文件字段了。 l&nbsp; String getName()：获取文件字段的文件名称； l&nbsp; String getString()：获取字段的内容，如果是文件字段，那么获取的是文件内容，当然上传的文件必须是文本文件； l&nbsp; String getFieldName()：获取字段名称，例如：&lt;input type=”text” name=”username”/&gt;，返回的是username； l&nbsp; String getContentType()：获取上传的文件的类型，例如：text/plain。 l&nbsp; int getSize()：获取上传文件的大小； l&nbsp; boolean isFormField()：判断当前表单字段是否为普通文本字段，如果返回false，说明是文件字段； l&nbsp; InputStream getInputStream()：获取上传文件对应的输入流； l&nbsp; void write(File)：把上传的文件保存到指定文件中。 &nbsp; 3 简单上传示例 写一个简单的上传示例： l&nbsp; 表单包含一个用户名字段，以及一个文件字段； l&nbsp; Servlet保存上传的文件到uploads目录，显示用户名，文件名，文件大小，文件类型。 &nbsp; 第一步： 完成index.jsp，只需要一个表单。注意表单必须是post的，而且enctype必须是mulitpart/form-data的。 &lt;form action=&ldquo;${pageContext.request.contextPath }/FileUploadServlet&rdquo; method=&ldquo;post&rdquo; enctype=&ldquo;multipart/form-data&rdquo;&gt; 用户名：&lt;input type=&ldquo;text&rdquo; name=&ldquo;username&rdquo;/&gt;&lt;br/&gt; 文件1：&lt;input type=&ldquo;file&rdquo; name=&ldquo;file1&rdquo;/&gt;&lt;br/&gt; &lt;input type=&ldquo;submit&rdquo; value=&ldquo;提交&rdquo;/&gt; &lt;/form&gt; &nbsp; 第二步： 完成FileUploadServlet public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 因为要使用response打印，所以设置其编码 response.setContentType(&ldquo;text/html;charset=utf-8&rdquo;); // 创建工厂 DiskFileItemFactory dfif = new DiskFileItemFactory(); // 使用工厂创建解析器对象 ServletFileUpload fileUpload = new ServletFileUpload(dfif); try { // 使用解析器对象解析request，得到FileItem列表 List&lt;FileItem&gt; list = fileUpload.parseRequest(request); // 遍历所有表单项 for(FileItem fileItem : list) { // 如果当前表单项为普通表单项 if(fileItem.isFormField()) { // 获取当前表单项的字段名称 String fieldName = fileItem.getFieldName(); // 如果当前表单项的字段名为username if(fieldName.equals(&ldquo;username&rdquo;)) { // 打印当前表单项的内容，即用户在username表单项中输入的内容 response.getWriter().print(&ldquo;用户名：&rdquo; + fileItem.getString() + &ldquo;&lt;br/&gt;&rdquo;); } } else {//如果当前表单项不是普通表单项，说明就是文件字段 String name = fileItem.getName();//获取上传文件的名称 // 如果上传的文件名称为空，即没有指定上传文件 if(name == null || name.isEmpty()) { continue; } // 获取真实路径，对应${项目目录}/uploads，当然，这个目录必须存在 String savepath = this.getServletContext().getRealPath(&ldquo;/uploads&rdquo;); // 通过uploads目录和文件名称来创建File对象 File file = new File(savepath, name); // 把上传文件保存到指定位置 fileItem.write(file); // 打印上传文件的名称 response.getWriter().print(&ldquo;上传文件名：&rdquo; + name + &ldquo;&lt;br/&gt;&rdquo;); // 打印上传文件的大小 response.getWriter().print(&ldquo;上传文件大小：&rdquo; + fileItem.getSize() + &ldquo;&lt;br/&gt;&rdquo;); // 打印上传文件的类型 response.getWriter().print(&ldquo;上传文件类型：&rdquo; + fileItem.getContentType() + &ldquo;&lt;br/&gt;&rdquo;); } } } catch (Exception e) { throw new ServletException(e); } } &nbsp; 文件上传之细节 &nbsp; 1 把上传的文件放到WEB-INF目录下 如果没有把用户上传的文件存放到WEB-INF目录下，那么用户就可以通过浏览器直接访问上传的文件，这是非常危险的。 假如说用户上传了一个a.jsp文件，然后用户在通过浏览器去访问这个a.jsp文件，那么就会执行a.jsp中的内容，如果在a.jsp中有如下语句：Runtime.getRuntime().exec(“shutdown –s –t 1”);，那么你就会… &nbsp; 通常我们会在WEB-INF目录下创建一个uploads目录来存放上传的文件，而在Servlet中找到这个目录需要使用ServletContext的getRealPath(String)方法，例如在我的upload1项目中有如下语句： ServletContext servletContext = this.getServletContext(); String savepath = servletContext.getRealPath(“/WEB-INF/uploads”); &nbsp; 其中savepath为：F:\\tomcat6_1\\webapps\\upload1\\WEB-INF\\uploads。 &nbsp; 2 文件名称（完整路径、文件名称） 上传文件名称可能是完整路径： IE6获取的上传文件名称是完整路径，而其他浏览器获取的上传文件名称只是文件名称而已。浏览器差异的问题我们还是需要处理一下的。 String name = file1FileItem.getName(); response.getWriter().print(name); &nbsp; 使用不同浏览器测试，其中IE6就会返回上传文件的完整路径，不知道IE6在搞什么，这给我们带来了很大的麻烦，就是需要处理这一问题。 处理这一问题也很简单，无论是否为完整路径，我们都去截取最后一个“\\”后面的内容就可以了。 String name = file1FileItem.getName(); int lastIndex = name.lastIndexOf(&ldquo;\\&rdquo;);//获取最后一个“\\”的位置 if(lastIndex != -1) {//注意，如果不是完整路径，那么就不会有“\\”的存在。 name = name.substring(lastIndex + 1);//获取文件名称 } response.getWriter().print(name); &nbsp; 3 中文乱码问题 上传文件名称中包含中文： 当上传的谁的名称中包含中文时，需要设置编码，commons-fileupload组件为我们提供了两种设置编码的方式： l&nbsp; request.setCharacterEncoding(String)：这种方式是我们最为熟悉的方式了； l&nbsp; fileUpload.setHeaderEncdoing(String)：这种方式的优先级高与前一种。 &nbsp; 上传文件的文件内容包含中文： 通常我们不需关心上传文件的内容，因为我们会把上传文件保存到硬盘上！也就是说，文件原来是什么样子，到服务器这边还是什么样子！ 但是如果你有这样的需求，非要在控制台显示上传的文件内容，那么你可以使用fileItem.getString(“utf-8”)来处理编码。 文本文件内容和普通表单项内容使用FileItem类的getString(“utf-8”)来处理编码。 &nbsp; 4 上传文件同名问题（文件重命名） 通常我们会把用户上传的文件保存到uploads目录下，但如果用户上传了同名文件呢？这会出现覆盖的现象。处理这一问题的手段是使用UUID生成唯一名称，然后再使用“_”连接文件上传的原始名称。 例如用户上传的文件是“我的一寸照片.jpg”，在通过处理后，文件名称为：“891b3881395f4175b969256a3f7b6e10_我的一寸照片.jpg”，这种手段不会使文件丢失扩展名，并且因为UUID的唯一性，上传的文件同名，但在服务器端是不会出现同名问题的。 &nbsp; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&ldquo;utf-8&rdquo;); DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(dfif); try { List&lt;FileItem&gt; list = fileUpload.parseRequest(request); //获取第二个表单项，因为第一个表单项是username，第二个才是file表单项 FileItem fileItem = list.get(1); String name = fileItem.getName();//获取文件名称 // 如果客户端使用的是IE6，那么需要从完整路径中获取文件名称 int lastIndex = name.lastIndexOf(&ldquo;\\&rdquo;); if(lastIndex != -1) { name = name.substring(lastIndex + 1); } // 获取上传文件的保存目录 String savepath = this.getServletContext().getRealPath(&ldquo;/WEB-INF/uploads&rdquo;); String uuid = CommonUtils.uuid();//生成uuid String filename = uuid + &ldquo;_&rdquo; + name;//新的文件名称为uuid + 下划线 + 原始名称 //创建file对象，下面会把上传文件保存到这个file指定的路径 //savepath，即上传文件的保存目录 //filename，文件名称 File file = new File(savepath, filename); // 保存文件 fileItem.write(file); } catch (Exception e) { throw new ServletException(e); } } &nbsp; 5 一个目录不能存放过多的文件（存放目录打散） 一个目录下不应该存放过多的文件，一般一个目录存放1000个文件就是上限了，如果在多，那么打开目录时就会很“卡”。你可以尝试打印C:\\WINDOWS\\system32目录，你会感觉到的。 也就是说，我们需要把上传的文件放到不同的目录中。但是也不能为每个上传的文件一个目录，这种方式会导致目录过多。所以我们应该采用某种算法来“打散”！ 打散的方法有很多，例如使用日期来打散，每天生成一个目录。也可以使用文件名的首字母来生成目录，相同首字母的文件放到同一目录下。 日期打散算法：如果某一天上传的文件过多，那么也会出现一个目录文件过多的情况； 首字母打散算法：如果文件名是中文的，因为中文过多，所以会导致目录过多的现象。 &nbsp; 我们这里使用hash算法来打散： 1.&nbsp;&nbsp;&nbsp;&nbsp; 获取文件名称的hashCode：int hCode = name.hashCode();； 2.&nbsp;&nbsp;&nbsp;&nbsp; 获取hCode的低4位，然后转换成16进制字符； 3.&nbsp;&nbsp;&nbsp;&nbsp; 获取hCode的5~8位，然后转换成16进制字符； 4.&nbsp;&nbsp;&nbsp;&nbsp; 使用这两个16进制的字符生成目录链。例如低4位字符为“5” &nbsp; 这种算法的好处是，在uploads目录下最多生成16个目录，而每个目录下最多再生成16个目录，即256个目录，所有上传的文件都放到这256个目录下。如果每个目录上限为1000个文件，那么一共可以保存256000个文件。 &nbsp; 例如上传文件名称为：新建 文本文档.txt，那么把“新建 文本文档.txt”的哈希码获取到，再获取哈希码的低4位，和5~8位。假如低4位为：9，5~8位为1，那么文件的保存路径为uploads/9/1/。 &nbsp; int hCode = name.hashCode();//获取文件名的hashCode //获取hCode的低4位，并转换成16进制字符串 String dir1 = Integer.toHexString(hCode &amp; 0xF); //获取hCode的低5~8位，并转换成16进制字符串 String dir2 = Integer.toHexString(hCode &gt;&gt;&gt; 4 &amp; 0xF); //与文件保存目录连接成完整路径 savepath = savepath + &ldquo;/&rdquo; + dir1 + &ldquo;/&rdquo; + dir2; //因为这个路径可能不存在，所以创建成File对象，再创建目录链，确保目录在保存文件之前已经存在 new File(savepath).mkdirs(); &nbsp; 6 上传的单个文件的大小限制 限制上传文件的大小很简单，ServletFileUpload类的setFileSizeMax(long)就可以了。参数就是上传文件的上限字节数，例如servletFileUpload.setFileSizeMax(1024*10)表示上限为10KB。 一旦上传的文件超出了上限，那么就会抛出FileUploadBase.FileSizeLimitExceededException异常。我们可以在Servlet中获取这个异常，然后向页面输出“上传的文件超出限制”。 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&ldquo;utf-8&rdquo;); DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(dfif); // 设置上传的单个文件的上限为10KB fileUpload.setFileSizeMax(1024 * 10);[崔2]&nbsp; try { List&lt;FileItem&gt; list = fileUpload.parseRequest(request); //获取第二个表单项，因为第一个表单项是username，第二个才是file表单项 FileItem fileItem = list.get(1); String name = fileItem.getName();//获取文件名称 // 如果客户端使用的是IE6，那么需要从完整路径中获取文件名称 int lastIndex = name.lastIndexOf(&ldquo;\\&rdquo;); if(lastIndex != -1) { name = name.substring(lastIndex + 1); } // 获取上传文件的保存目录 String savepath = this.getServletContext().getRealPath(&ldquo;/WEB-INF/uploads&rdquo;); String uuid = CommonUtils.uuid();//生成uuid String filename = uuid + &ldquo;_&rdquo; + name;//新的文件名称为uuid + 下划线 + 原始名称 int hCode = name.hashCode();//获取文件名的hashCode //获取hCode的低4位，并转换成16进制字符串 String dir1 = Integer.toHexString(hCode &amp; 0xF); //获取hCode的低5~8位，并转换成16进制字符串 String dir2 = Integer.toHexString(hCode &gt;&gt;&gt; 4 &amp; 0xF); //与文件保存目录连接成完整路径 savepath = savepath + &ldquo;/&rdquo; + dir1 + &ldquo;/&rdquo; + dir2; //因为这个路径可能不存在，所以创建成File对象，再创建目录链，确保目录在保存文件之前已经存在 new File(savepath).mkdirs(); //创建file对象，下面会把上传文件保存到这个file指定的路径 //savepath，即上传文件的保存目录 //filename，文件名称 File file = new File(savepath, filename); // 保存文件 fileItem.write(file); } catch (Exception e) { // 判断抛出的异常的类型是否为FileUploadBase.FileSizeLimitExceededException // 如果是，说明上传文件时超出了限制。 if(e instanceof FileUploadBase.FileSizeLimitExceededException) { // 在request中保存错误信息 request.setAttribute(&ldquo;msg&rdquo;, &ldquo;上传失败！上传的文件超出了10KB！&rdquo;); // 转发到index.jsp页面中！在index.jsp页面中需要使用${msg}来显示错误信息 request.getRequestDispatcher(&ldquo;/index.jsp&rdquo;).forward(request, response); return; } [崔3]&nbsp; throw new ServletException(e); } } &nbsp; 7 上传文件的总大小限制 上传文件的表单中可能允许上传多个文件，例如： &nbsp; 有时我们需要限制一个请求的大小。也就是说这个请求的最大字节数（所有表单项之和）！实现这一功能也很简单，只需要调用ServletFileUpload类的setSizeMax(long)方法即可。 例如fileUpload.setSizeMax(1024 * 10);，显示整个请求的上限为10KB。当请求大小超出10KB时，ServletFileUpload类的parseRequest()方法会抛出FileUploadBase.SizeLimitExceededException异常。 &nbsp; 8 缓存大小与临时目录 大家想一想，如果我上传一个蓝光电影，先把电影保存到内存中，然后再通过内存copy到服务器硬盘上，那么你的内存能吃的消么？ 所以fileupload组件不可能把文件都保存在内存中，fileupload会判断文件大小是否超出10KB，如果是那么就把文件保存到硬盘上，如果没有超出，那么就保存在内存中。 10KB是fileupload默认的值，我们可以来设置它。 当文件保存到硬盘时，fileupload是把文件保存到系统临时目录，当然你也可以去设置临时目录。 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&ldquo;utf-8&rdquo;); DiskFileItemFactory dfif = new DiskFileItemFactory(1024*20, new File(&ldquo;F:\\temp&rdquo;));[崔4]&nbsp; ServletFileUpload fileUpload = new ServletFileUpload(dfif); try { List&lt;FileItem&gt; list = fileUpload.parseRequest(request); FileItem fileItem = list.get(1); String name = fileItem.getName(); String savepath = this.getServletContext().getRealPath(&ldquo;/WEB-INF/uploads&rdquo;); // 保存文件 fileItem.write(path(savepath, name)); } catch (Exception e) { throw new ServletException(e); } } private File path[崔5]&nbsp;(String savepath, String filename) { // 从完整路径中获取文件名称 int lastIndex = filename.lastIndexOf(&ldquo;\\&rdquo;); if(lastIndex != -1) { filename = filename.substring(lastIndex + 1); } // 通过文件名称生成一级、二级目录 int hCode = filename.hashCode(); String dir1 = Integer.toHexString(hCode &amp; 0xF); String dir2 = Integer.toHexString(hCode &gt;&gt;&gt; 4 &amp; 0xF); savepath = savepath + &ldquo;/&rdquo; + dir1 + &ldquo;/&rdquo; + dir2; // 创建目录 new File(savepath).mkdirs(); // 给文件名称添加uuid前缀 String uuid = CommonUtils.uuid(); filename = uuid + &ldquo;_&rdquo; + filename; // 创建文件完成路径 return new File(savepath, filename); } &nbsp; 文件下载 &nbsp; 2 通过Servlet下载1 被下载的资源必须放到WEB-INF目录下（只要用户不能通过浏览器直接访问就OK），然后通过Servlet完成下载。 在jsp页面中给出超链接，链接到DownloadServlet，并提供要下载的文件名称。然后DownloadServlet获取文件的真实路径，然后把文件写入到response.getOutputStream()流中。 &nbsp; download.jsp &lt;body&gt; This is my JSP page. &lt;br&gt; &lt;a href=&ldquo;&lt;c:url value=&lsquo;/DownloadServlet?path=a.avi&rsquo;/&gt;&rdquo;&gt;a.avi&lt;/a&gt;&lt;br/&gt; &lt;a href=&ldquo;&lt;c:url value=&lsquo;/DownloadServlet?path=a.jpg&rsquo;/&gt;&rdquo;&gt;a.jpg&lt;/a&gt;&lt;br/&gt; &lt;a href=&ldquo;&lt;c:url value=&lsquo;/DownloadServlet?path=a.txt&rsquo;/&gt;&rdquo;&gt;a.txt&lt;/a&gt;&lt;br/&gt; &lt;/body&gt; &nbsp; DownloadServlet.java public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String filename = request.getParameter(&ldquo;path&rdquo;);[崔6]&nbsp; String filepath = this.getServletContext().getRealPath(&ldquo;/WEB-INF/uploads/&rdquo; + filename);[崔7]&nbsp; File file = new File(filepath); if(!file.exists()) { response.getWriter().print(&ldquo;您要下载的文件不存在！&rdquo;); return; }[崔8]&nbsp; IOUtils.copy(new FileInputStream(file), response.getOutputStream());[崔9]&nbsp; } &nbsp; 上面代码有如下问题： l&nbsp; 可以下载a.avi，但在下载框中的文件名称是DownloadServlet； l&nbsp; 不能下载a.jpg和a.txt，而是在页面中显示它们。 &nbsp; &nbsp; 3 通过Servlet下载2 下面来处理上一例中的问题，让下载框中可以显示正确的文件名称，以及可以下载a.jpg和a.txt文件。 通过添加content-disposition头来处理上面问题。当设置了content-disposition头后，浏览器就会弹出下载框。 而且还可以通过content-disposition头来指定下载文件的名称！ &nbsp; String filename = request.getParameter(&ldquo;path&rdquo;); String filepath = this.getServletContext().getRealPath(&ldquo;/WEB-INF/uploads/&rdquo; + filename); File file = new File(filepath); if(!file.exists()) { response.getWriter().print(&ldquo;您要下载的文件不存在！&rdquo;); return; } response.addHeader(&ldquo;content-disposition&rdquo;, &ldquo;attachment;filename=&rdquo; + filename);[崔10]&nbsp; IOUtils.copy(new FileInputStream(file), response.getOutputStream()); &nbsp; &nbsp; 虽然上面的代码已经可以处理txt和jpg等文件的下载问题，并且也处理了在下载框中显示文件名称的问题，但是如果下载的文件名称是中文的，那么还是不行的。 &nbsp; 3 通过Servlet下载3 下面是处理在下载框中显示中文的问题！ 其实这一问题很简单，只需要通过URL来编码中文即可！ &nbsp; download.jsp &lt;a href=&ldquo;&lt;c:url value=&lsquo;/DownloadServlet?path=这个杀手不太冷.avi&rsquo;/&gt;&rdquo;&gt;这个杀手不太冷.avi&lt;/a&gt;&lt;br/&gt; &lt;a href=&ldquo;&lt;c:url value=&lsquo;/DownloadServlet?path=白冰.jpg&rsquo;/&gt;&rdquo;&gt;白冰.jpg&lt;/a&gt;&lt;br/&gt; &lt;a href=&ldquo;&lt;c:url value=&lsquo;/DownloadServlet?path=说明文档.txt&rsquo;/&gt;&rdquo;&gt;说明文档.txt&lt;/a&gt;&lt;br/&gt; &nbsp; DownloadServlet.java String filename = request.getParameter(&ldquo;path&rdquo;); // GET请求中，参数中包含中文需要自己动手来转换。 // 当然如果你使用了“全局编码过滤器”，那么这里就不用处理了 filename = new String(filename.getBytes(&ldquo;ISO-8859-1&rdquo;), &ldquo;UTF-8&rdquo;); String filepath = this.getServletContext().getRealPath(&ldquo;/WEB-INF/uploads/&rdquo; + filename); File file = new File(filepath); if(!file.exists()) { response.getWriter().print(&ldquo;您要下载的文件不存在！&rdquo;); return; } // 所有浏览器都会使用本地编码，即中文操作系统使用GBK // 浏览器收到这个文件名后，会使用iso-8859-1来解码 filename = new String(filename.getBytes(&ldquo;GBK&rdquo;), &ldquo;ISO-8859-1&rdquo;); response.addHeader(&ldquo;content-disposition&rdquo;, &ldquo;attachment;filename=&rdquo; + filename); IOUtils.copy(new FileInputStream(file), response.getOutputStream()); &nbsp; JavaMail 今日内容 l&nbsp; 邮件协议 l&nbsp; telnet访问邮件服务器 l&nbsp; JavaMail &nbsp; 邮件协议 &nbsp; 1 收发邮件 发邮件大家都会吧！发邮件是从客户端把邮件发送到邮件服务器，收邮件是把邮件服务器的邮件下载到客户端。 我们在163、126、QQ、sohu、sina等网站注册的Email账户，其实就是在邮件服务器中注册的。这些网站都有自己的邮件服务器。 &nbsp; 2 邮件协议概述 与HTTP协议相同，收发邮件也是需要有传输协议的。 l&nbsp; SMTP：（Simple Mail Transfer Protocol，简单邮件传输协议）发邮件协议； l&nbsp; POP3：（Post Office Protocol Version 3，邮局协议第3版）收邮件协议； l&nbsp; IMAP：（Internet Message Access Protocol，因特网消息访问协议）收发邮件协议，我们的课程不涉及该协议。 &nbsp; 3 理解邮件收发过程 其实你可以把邮件服务器理解为邮局！如果你需要给朋友寄一封信，那么你需要把信放到邮筒中，这样你的信会“自动”到达邮局，邮局会把信邮到另一个省市的邮局中。然后这封信会被送到收信人的邮箱中。最终收信人需要自己经常查看邮箱是否有新的信件。 其实每个邮件服务器都由SMTP服务器和POP3服务器构成，其中SMTP服务器负责发邮件的请求，而POP3负责收邮件的请求。 &nbsp; 当然，有时我们也会使用163的账号，向126的账号发送邮件。这时邮件是发送到126的邮件服务器，而对于163的邮件服务器是不会存储这封邮件的。 &nbsp; 4 邮件服务器名称 smtp服务器的端口号为25，服务器名称为smtp.xxx.xxx。 pop3服务器的端口号为110，服务器名称为pop3.xxx.xxx。 例如： l&nbsp; 163：smtp.163.com和pop3.163.com； l&nbsp; 126：smtp.126.com和pop3.126.com； l&nbsp; qq：smtp.qq.com和pop3.qq.com； l&nbsp; sohu：smtp.sohu.com和pop3.sohu.com； l&nbsp; sina：smtp.sina.com和pop3.sina.com。 &nbsp; telnet收发邮件 &nbsp; 1 BASE64加密 BASE64是一种加密算法，这种加密方式是可逆的！它的作用是使加密后的文本无法用肉眼识别。Java提供了sun.misc.BASE64Encoder这个类，用来对做Base64的加密和解密，但我们知道，使用sun包下的东西会有警告！甚至在eclipse中根本使用不了这个类（需要设置），所以我们还是听sun公司的话，不要去使用它内部使用的类，我们去使用apache commons组件中的codec包下的Base64这个类来完成BASE64加密和解密。 package cn.itcast; &nbsp; import org.apache.commons.codec.binary.Base64; &nbsp; public class Base64Utils { public static String encode(String s) { return encode(s, &ldquo;utf-8&rdquo;); } public static String decode(String s) { return decode(s, &ldquo;utf-8&rdquo;); } public static String encode(String s, String charset) { try { byte[] bytes = s.getBytes(charset); bytes = Base64.encodeBase64(bytes); return new String(bytes, charset); } catch (Exception e) { throw new RuntimeException(e); } } &nbsp; public static String decode(String s, String charset) { try { byte[] bytes = s.getBytes(charset); bytes = Base64.decodeBase64(bytes); return new String(bytes, charset); } catch (Exception e) { throw new RuntimeException(e); } } } &nbsp; 2 telnet发邮件 连接163的smtp服务器：； 连接成功后需要如下步骤才能发送邮件： 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与服务器打招呼：ehlo你的名字 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发出登录请求：auth login 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输入加密后的邮箱名：(itcast_cxf@163.com)aXRjYXN0X2N4ZkAxNjMuY29t 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输入加密后的邮箱密码：(itcast)aXRjYXN0 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输入谁来发送邮件，即from：mail from:&lt;itcast_cxf@163.com&gt; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输入把邮件发给谁，即to：rcpt to:&lt;itcast_cxf@126.com&gt; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发送填写数据请求：data 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开始输入数据，数据包含：from、to、subject，以及邮件内容，如果输入结束后，以一个“.”为一行，表示输入结束： from:&lt;zhangBoZhi@163.com&gt; to:&lt;itcast_cxf@sina.com&gt; subject: 我爱上你了 &nbsp; 我已经深深的爱上你了，我是张柏芝。 . 注意，在标题和邮件正文之间要有一个空行！当要退出时，一定要以一个“.”为单行，表示输入结束。 9 最后一步：quit &nbsp; telnet收邮件 &nbsp; 1 telnet收邮件的步骤 pop3无需使用Base64加密！！！ &nbsp; 收邮件连接的服务器是pop3.xxx.com，pop3协议的默认端口号是110。请注意！这与发邮件完全不同。如果你在163有邮箱账户，那么你想使用telnet收邮件，需要连接的服务器是pop3.163.com。 l&nbsp; 连接pop3服务器：telnet pop3.163.com 110 l&nbsp; user命令：user 用户名，例如：user itcast_cxf@163.com； l&nbsp; pass命令：pass 密码，例如：pass itcast； l&nbsp; stat命令：stat命令用来查看邮箱中邮件的个数，所有邮件所占的空间； l&nbsp; list命令：list命令用来查看所有邮件，或指定邮件的状态，例如：list 1是查看第一封邮件的大小，list是查看邮件列表，即列出所有邮件的编号，及大小； l&nbsp; retr命令：查看指定邮件的内容，例如：retr 1#是查看第一封邮件的内容； l&nbsp; dele命令：标记某邮件为删除，但不是马上删除，而是在退出时才会真正删除； l&nbsp; quit命令：退出！如果在退出之前已经使用dele命令标记了某些邮件，那么会在退出是删除它们。 &nbsp; &nbsp; &nbsp; &nbsp; JavaMail &nbsp; 1 JavaMail概述 Java Mail是由SUN公司提供的专门针对邮件的API，主要Jar包：mail.jar、activation.jar。 在使用MyEclipse创建web项目时，需要小心！如果只是在web项目中使用java mail是没有什么问题的，发布到Tomcat上运行一点问题都没有！ 但是如果是在web项目中写测试那就出问题了。 在MyEclipse中，会自动给web项目导入javax.mail包中的类，但是不全（其实是只有接口，而没有接口的实现类），所以只靠MyEclipse中的类是不能运行java mail项目的，但是如果这时你再去自行导入mail.jar时，就会出现冲突。 处理方案：到下面路径中找到javaee.jar文件，把javax.mail删除！！！ D:\\Program Files\\MyEclipse\\Common\\plugins\\com.genuitec.eclipse.j2eedt.core_10.0.0.me201110301321\\data\\libraryset\\EE_5 &nbsp; 2 JavaMail中主要类 java mail中主要类：javax.mail.Session、javax.mail.internet.MimeMessage、javax.mail.Transport。 Session：表示会话，即客户端与邮件服务器之间的会话！想获得会话需要给出账户和密码，当然还要给出服务器名称。在邮件服务中的Session对象，就相当于连接数据库时的Connection对象。 MimeMessage：表示邮件类，它是Message的子类。它包含邮件的主题（标题）、内容，收件人地址、发件人地址，还可以设置抄送和暗送，甚至还可以设置附件。 Transport：用来发送邮件。它是发送器！ &nbsp; 3 JavaMail之Hello World 在使用telnet发邮件时，还需要自己来处理Base64编码的问题，但使用JavaMail就不必理会这些问题了，都由JavaMail来处理。 第一步：获得Session Session session = Session.getInstance(Properties prop, Authenticator auth); 其中prop需要指定两个键值，一个是指定服务器主机名，另一个是指定是否需要认证！我们当然需要认证！ Properties prop = new Properties(); prop.setProperty(“mail.host”, “smtp.163.com”);//设置服务器主机名 prop.setProperty(“mail.smtp.auth”, “true”);//设置需要认证 &nbsp; 其中Authenticator是一个接口表示认证器，即校验客户端的身份。我们需要自己来实现这个接口，实现这个接口需要使用账户和密码。 Authenticator auth = new Authenticator() { public PasswordAuthentication getPasswordAuthentication () { new PasswordAuthentication(“itcast_cxf”, “itcast”);//用户名和密码 } }; 通过上面的准备，现在可以获取得Session对象了： Session session = Session.getInstance(prop, auth); &nbsp; 第二步：创建MimeMessage对象 创建MimeMessage需要使用Session对象来创建： MimeMessage msg = new MimeMessage(session); 然后需要设置发信人地址、收信人地址、主题，以及邮件正文。 msg.setFrom(new InternetAddress(“itcast_cxf@163.com”));//设置发信人 msg.addRecipients(RecipientType.TO, “itcast_cxf@qq.com,itcast_cxf@sina.com”);//设置多个收信人 msg.addRecipients(RecipientType.CC, “itcast_cxf@sohu.com,itcast_cxf@126.com”);//设置多个抄送 msg.addRecipients(RecipientType.BCC, ”itcast_cxf@hotmail.com”);//设置暗送 msg.setSubject(“这是一封测试邮件”);//设置主题（标题） msg.setContent(“当然是hello world!”, “text/plain;charset=utf-8”);//设置正文 &nbsp; 第三步：发送邮件 Transport.send(msg);//发送邮件 &nbsp; 4 JavaMail发送带有附件的邮件（了解） 一封邮件可以包含正文、附件N个，所以正文与N个附件都是邮件的一个部份。 上面的hello world案例中，只是发送了带有正文的邮件！所以在调用setContent()方法时直接设置了正文，如果想发送带有附件邮件，那么需要设置邮件的内容为MimeMultiPart。 MimeMulitpart parts = new MimeMulitpart();//多部件对象，可以理解为是部件的集合 msg.setContent(parts);//设置邮件的内容为多部件内容。 然后我们需要把正文、N个附件创建为“主体部件”对象（MimeBodyPart），添加到MimeMuiltPart中即可。 MimeBodyPart part1 = new MimeBodyPart();//创建一个部件 part1.setCotnent(“这是正文部分”, “text/html;charset=utf-8”);//给部件设置内容 parts.addBodyPart(part1);//把部件添加到部件集中。 &nbsp; 下面我们创建一个附件： MimeBodyPart part2 = new MimeBodyPart();//创建一个部件 part2.attachFile(“F:\\a.jpg”);//设置附件 part2.setFileName(“hello.jpg”);//设置附件名称 parts.addBodyPart(part2);//把附件添加到部件集中 &nbsp; 注意，如果在设置文件名称时，文件名称中包含了中文的话，那么需要使用MimeUitlity类来给中文编码： part2.setFileName(MimeUitlity.encodeText(“美女.jpg”)); &nbsp; &nbsp; &nbsp;[崔1]使用apache的commons的io组件，把流中的数据读取出来转换成字符串 &lt;![endif]&gt; &nbsp;[崔2]设置单个上传文件的上限为10KB，超出10KB，fileUploadRequest()方法就会抛出异常。 这条代码一定要在fileUploadRequest()方法之前调用。 &lt;![endif]&gt; &nbsp;[崔3]当抛出异常后，判断异常类型，如果是超出了文件大小限制，那么就转发到index.jsp页面显示错误信息。 &lt;![endif]&gt; &nbsp;[崔4]指定缓存大小为20KB，当上传的文件超出了20KB就会保存到临时目录。 临时目录为F:\\temp &lt;![endif]&gt; &nbsp;[崔5]生成文件的保存路径 &lt;![endif]&gt; &nbsp;[崔6]获取要下载的文件名称 &lt;![endif]&gt; &nbsp;[崔7]因为文件都存放在WEB-INF/uploads目录下，所以需要获取文件的真实路径 &lt;![endif]&gt; &nbsp;[崔8]判断文件是否存在，不存在，输出错误信息。 &lt;![endif]&gt; &nbsp;[崔9]把文件写入到response.getOutputStream()中。 &lt;![endif]&gt; &nbsp;[崔10]添加content-disposition头，指定了在下载框中显示的文件名称。 只要设置了这个头信息，浏览器就会弹出下载框，这就可以下载jpg和txt文件了。 &lt;![endif]&gt; var _self=\"undefined\"!=typeof window?window:\"undefined\"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\\blang(?:uage)?-(\\w+)\\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):\"Array\"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,\"&amp;\").replace(/","categories":[],"tags":[]},{"title":"","slug":"JavaScript/ajax-json-xstream","date":"2017-11-13T18:09:53.000Z","updated":"2017-11-13T18:09:53.000Z","comments":true,"path":"2017/11/14/JavaScript/ajax-json-xstream/","link":"","permalink":"http://io.stelawliet.top/2017/11/14/JavaScript/ajax-json-xstream/","excerpt":"","text":"ajax-json-xstream.mdhtml {overflow-x: initial !important;}.CodeMirror { height: auto; } .CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { padding: 4px 0px; } .CodeMirror pre { } .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler { background-color: white; } .CodeMirror-gutters { border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); background-color: rgb(247, 247, 247); white-space: nowrap; } .CodeMirror-linenumbers { } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .CodeMirror div.CodeMirror-cursor { border-left-width: 1px; border-left-style: solid; border-left-color: black; z-index: 3; } .CodeMirror div.CodeMirror-secondarycursor { border-left-width: 1px; border-left-style: solid; border-left-color: silver; } .CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor { width: auto; border: 0px; background-color: rgb(119, 238, 119); z-index: 1; background-position: initial initial; background-repeat: initial initial; } .CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite { } .cm-tab { display: inline-block; } .cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property { color: rgb(217, 79, 138); } .cm-s-typora-default pre.cm-header1:not(.cm-atom) :not(.cm-overlay) { font-size: 2rem; line-height: 2rem; } .cm-s-typora-default pre.cm-header2:not(.cm-atom) :not(.cm-overlay) { font-size: 1.4rem; line-height: 1.4rem; } .cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number { color: rgb(149, 132, 134); } .cm-s-typora-default .cm-table-row, .cm-s-typora-default .cm-block-start { font-family: monospace; } .cm-s-typora-default .cm-comment, .cm-s-typora-default .cm-code { color: rgb(74, 90, 159); font-family: monospace; } .cm-s-typora-default .cm-tag { color: rgb(169, 68, 66); } .cm-s-typora-default .cm-string { color: rgb(126, 134, 169); } .cm-s-typora-default .cm-link { color: rgb(196, 122, 15); text-decoration: underline; } .cm-s-typora-default .cm-variable-2, .cm-s-typora-default .cm-variable-1 { color: inherit; } .cm-s-typora-default .cm-overlay { font-family: monospace; } .CodeMirror.cm-s-typora-default div.CodeMirror-cursor { border-left-width: 3px; border-left-style: solid; border-left-color: rgb(228, 98, 154); } .cm-s-typora-default .CodeMirror-activeline-background { left: -60px; right: -30px; background-color: rgba(204, 204, 204, 0.2); background-position: initial initial; background-repeat: initial initial; } .cm-s-typora-default .CodeMirror-gutters { border-right-style: none; background-color: inherit; } .cm-s-typora-default .cm-trailing-space-new-line::after, .cm-startspace::after, .cm-starttab .cm-tab::after { content: '•'; position: absolute; left: 0px; opacity: 0; font-family: LetterGothicStd, monospace; } .os-windows .cm-startspace::after, .os-windows .cm-starttab .cm-tab::after { left: -0.1em; } .cm-starttab .cm-tab::after { content: ' '; } .cm-startspace, .cm-tab, .cm-starttab, .cm-trailing-space-a, .cm-trailing-space-b, .cm-trailing-space-new-line { font-family: monospace; position: relative; } .cm-s-typora-default .cm-trailing-space-new-line::after { content: '↓'; opacity: 0.3; } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: black; } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-property { color: black; } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: blue; } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: bold; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: rgb(255, 0, 0); } .cm-invalidchar { color: rgb(255, 0, 0); } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; background-position: inherit inherit; background-repeat: inherit inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { margin-bottom: -30px; margin-right: -30px; padding-bottom: 30px; padding-right: 30px; height: 100%; outline: none; position: relative; box-sizing: content-box; } .CodeMirror-sizer { position: relative; } .CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler { position: absolute; z-index: 6; display: none; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow-x: hidden; overflow-y: scroll; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow-y: hidden; overflow-x: scroll; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background-image: none !important; border: none !important; background-position: initial initial !important; background-repeat: initial initial !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; border-width: 0px; background-color: transparent; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; background-position: initial initial; background-repeat: initial initial; } .CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right-width: 30px; border-right-style: solid; border-right-color: transparent; width: -webkit-fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right-style: none; width: auto; } .CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-widget { } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right-style: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .CodeMirror-selected { background-color: rgb(217, 217, 217); background-position: initial initial; background-repeat: initial initial; } .CodeMirror-focused .CodeMirror-selected { background-color: rgb(215, 212, 240); background-position: initial initial; background-repeat: initial initial; } .cm-searching { background-color: rgba(255, 255, 0, 0.4); background-position: initial initial; background-repeat: initial initial; } .CodeMirror span { } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } .CodeMirror-lint-markers { width: 16px; } .CodeMirror-lint-tooltip { background-color: infobackground; border: 1px solid black; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; color: infotext; font-family: monospace; overflow: hidden; padding: 2px 5px; position: fixed; white-space: pre-wrap; z-index: 10000; max-width: 600px; opacity: 0; -webkit-transition: opacity 0.4s; transition: opacity 0.4s; font-size: 0.8em; } .CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning { background-position: 0% 100%; background-repeat: repeat no-repeat; } .CodeMirror-lint-mark-error { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==); } .CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning { cursor: pointer; display: inline-block; height: 16px; width: 16px; vertical-align: middle; position: relative; background-position: 50% 50%; background-repeat: no-repeat no-repeat; } .CodeMirror-lint-message-error, .CodeMirror-lint-message-warning { padding-left: 18px; background-position: 0% 0%; background-repeat: no-repeat no-repeat; } .CodeMirror-lint-marker-error, .CodeMirror-lint-message-error { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=); } .CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=); } .CodeMirror-lint-marker-multiple { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC); width: 100%; height: 100%; background-position: 100% 100%; background-repeat: no-repeat no-repeat; } :root { --bg-color: rgb(255, 255, 255); --text-color: rgb(51, 51, 51); --code-block-bg-color: inherit; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857143; overflow-x: hidden; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; background-position: inherit inherit; background-repeat: inherit inherit; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { background-color: rgb(181, 214, 252); text-shadow: none; background-position: initial initial; background-repeat: initial initial; } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } .typora-export #write { margin: 0px auto; } #write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; } #write li > table:first-child { margin-top: -20px; } img { max-width: 100%; vertical-align: middle; } input, button, select, textarea { color: inherit; font-family: inherit; font-size: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; line-height: inherit; } input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; } ::before, ::after, * { box-sizing: border-box; } #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; } #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; } .typora-export p { white-space: normal; } .mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.701961); color: rgb(85, 85, 85); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; } #write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; } tr { page-break-inside: avoid; page-break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; page-break-inside: auto; text-align: left; } table.md-table td { min-width: 80px; } .CodeMirror-gutters { border-right-width: 0px; background-color: inherit; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } pre { white-space: pre-wrap; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; page-break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: var(--code-block-bg-color); position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } .md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; } .md-fences.mock-cm { white-space: pre-wrap; } .show-fences-line-number .md-fences { padding-left: 0px; } .show-fences-line-number .md-fences.mock-cm { padding-left: 40px; } .footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; } .footnotes + .footnotes { margin-top: -1em; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background-color: transparent; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; background-position: initial initial; background-repeat: initial initial; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li p, li .mathjax-block { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; } @media print { html, body { border: 1px solid transparent; height: 99%; page-break-after: avoid; page-break-before: avoid; } .typora-export * { -webkit-print-color-adjust: exact; } h1, h2, h3, h4, h5, h6 { page-break-after: avoid; orphans: 2; } p { orphans: 4; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; page-break-after: avoid; } .typora-export #write::after { height: 0px; } @page { margin: 20mm 0mm; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; background-color: rgb(204, 204, 204); display: block; overflow-x: hidden; background-position: initial initial; background-repeat: initial initial; } p .md-image:only-child { display: inline-block; width: 100%; text-align: center; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .mathjax-block { white-space: pre; overflow: hidden; width: 100%; } p + .mathjax-block { margin-top: -1.143rem; } .mathjax-block:not(:empty)::after { display: none; } [contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus { outline: none; box-shadow: none; } .task-list { list-style-type: none; } .task-list-item { position: relative; padding-left: 1em; } .task-list-item input { position: absolute; top: 0px; left: 0px; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc::after, .md-toc-content::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: '.'; } .md-tag { opacity: 0.5; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: monospace; } code { text-align: left; } h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; } a.md-print-anchor { border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; background-color: transparent !important; text-shadow: initial !important; background-position: initial initial !important; background-repeat: initial initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: monospace; } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { -webkit-transition: none; transition: none; } .md-diagram-panel > svg { max-width: 100%; } [lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; } @include-when-export url(http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic,700italic); @include-when-export url(http://fonts.googleapis.com/css?family=Raleway:600,400&subset=latin,latin-ext); @charset \"UTF-8\"; @font-face { font-family: 'TeXGyreAdventor'; src: url('file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/texgyreadventor-regular.otf'); font-weight: normal; font-style: normal; } @charset \"UTF-8\"; @font-face { font-family: 'TeXGyreAdventor'; font-style: normal; font-weight: normal; src: url(file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/gothic/texgyreadventor-regular.otf); } @font-face { font-family: 'TeXGyreAdventor'; font-style: normal; font-weight: bold; src: url(file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/gothic/texgyreadventor-bold.otf); } @font-face { font-family: 'TeXGyreAdventor'; font-style: italic; font-weight: normal; src: url(file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/gothic/texgyreadventor-italic.otf); } @font-face { font-family: 'TeXGyreAdventor'; font-style: italic; font-weight: bold; src: url(file:///Users/zhaoziqi/Library/Application%20Support/abnerworks.Typora/themes/gothic/texgyreadventor-bolditalic.otf); } :root { --window-border: none; --typora-center-window-title: true; --active-file-bg-color: #f3f3f3; --bg-color: #fcfcfc; --control-text-color: #777; } .mac-seamless-mode #typora-sidebar { top: var(--mac-title-bar-height); padding-top: 0; height: calc(100% - var(--mac-title-bar-height)); } html, body, #write{ background: #fcfcfc; font-family: 'TeXGyreAdventor', \"Century Gothic\", 'Yu Gothic', 'Raleway', \"STHeiti\", sans-serif; font-weight: 400; } h1, h2, h3, h4, h5, h6 { color: #111; font-family: 'TeXGyreAdventor', \"Century Gothic\", 'Yu Gothic', 'Ubuntu', \"STHeiti\", sans-serif; } html { font-size:16px; } #write { max-width: 914px; text-align: justify; } #write>h1:first-child { margin-top: 2.75rem; } #write>h2:first-child { margin-top: 1.75rem; } #write>h3:first-child { margin-top: 1rem; } #write>h4:first-child { margin-top: 0.5rem; } h1 { font-weight: normal; line-height: 4rem; margin: 0 0 1.75rem; padding: 20px 30px; text-align: center; text-transform: uppercase; margin-top: 4rem; } h2 { font-weight: normal; line-height: 3rem; margin: 0 0 1.9375rem; padding: 0 30px; text-align: center; text-transform: uppercase; margin-top: 3rem } h3 { font-weight: normal; } h4 { font-weight: normal; } h5 { font-size: 1.125rem; font-weight: normal; } h6 { font-size: 1rem; font-weight: bold; } p { color: #111; font-size: 1rem; line-height: 1.75rem; margin: 0 0 1.25rem; } #write>h3.md-focus:before { left: -1.875rem; top: 0.5rem; padding: 2px; } #write>h4.md-focus:before { left: -1.875rem; top: 0.3125rem; padding: 2px; } #write>h5.md-focus:before { left: -1.875rem; top: 0.25rem; padding: 2px; } #write>h6.md-focus:before { left: -1.875rem; top: .125rem; padding: 2px; } /*@media screen and (min-width: 48em) { .h1, h1 { font-size: 3.250rem; } .h2, h2 { font-size: 2.298rem; } .h3, h3 { font-size: 1.625rem; } .h4, h4 { font-size: 1.250rem; } .h5, h5 { font-size: 1.150rem; } .h6, h6 { font-size: 1rem; } #write>h4.md-focus:before, #write>h5.md-focus:before, #write>h6.md-focus:before { top: 1px; } p { font-size: 1.25rem; line-height: 1.8; } table { font-size: 1.25rem; } }*/ @media screen and (max-width: 48em) { blockquote { margin-left: 1rem; margin-right: 0; padding: 0.5em; } .h1, h1 { font-size: 2.827rem; } .h2, h2 { font-size: 1.999rem; } .h3, h3 { font-size: 1.413rem; } .h4, h4 { font-size: 1.250rem; } .h5, h5 { font-size: 1.150rem; } .h6, h6 { font-size: 1rem; } } a, .md-def-url { color: #990000; text-decoration: none; } a:hover { text-decoration: underline; } table { margin-bottom: 20px } table th, table td { padding: 8px; line-height: 1.25rem; vertical-align: top; border-top: 1px solid #ddd } table th { font-weight: bold } table thead th { vertical-align: bottom } table caption+thead tr:first-child th, table caption+thead tr:first-child td, table colgroup+thead tr:first-child th, table colgroup+thead tr:first-child td, table thead:first-child tr:first-child th, table thead:first-child tr:first-child td { border-top: 0 } table tbody+tbody { border-top: 2px solid #ddd } code, .md-fences { padding: .5em; /*background: #f0f0f0;*/ border: 1px solid #ccc; padding: .1em; font-size: 0.9em; margin-left: 0.2em; margin-right: 0.2em; } .md-fences { margin: 0 0 20px; font-size: 1em; padding: 0.3em 1em; padding-top: 0.4em; } .task-list{ padding-left: 0; } .task-list-item { padding-left:2.125rem; } .task-list-item input { top: 3px; } .task-list-item input:before { content: \"\"; display: inline-block; width: 1rem; height: 1rem; vertical-align: middle; text-align: center; border: 1px solid gray; background-color: #fdfdfd; margin-left: 0; margin-top: -0.8rem; } .task-list-item input:checked:before, .task-list-item input[checked]:before{ content: '\\25FC'; /*◘*/ font-size: 0.8125rem; line-height: 0.9375rem; margin-top: -1rem; } /* Chrome 29+ */ @media screen and (-webkit-min-device-pixel-ratio:0) and (min-resolution:.001dpcm) { .task-list-item input:before { margin-top: -0.2rem; } .task-list-item input:checked:before, .task-list-item input[checked]:before { margin-top: -0.2rem; } } blockquote { margin: 0 0 1.11111rem; padding: 0.5rem 1.11111rem 0 1.05556rem; border-left: 1px solid gray; } blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; } #write pre.md-meta-block { min-height: 30px; background: #f8f8f8; padding: 1.5em; font-weight: 300; font-size: 1em; padding-bottom: 1.5em; padding-top: 3em; margin-top: -1.5em; color: #999; width: 100vw; max-width: calc(100% + 60px); margin-left: -30px; border-left: 30px #f8f8f8 solid; border-right: 30px #f8f8f8 solid; } .MathJax_Display { font-size: 0.9em; margin-top: 0.5em; margin-bottom: 0; } p.mathjax-block, .mathjax-block { padding-bottom: 0; } .mathjax-block>.code-tooltip { bottom: 5px; box-shadow: none; } .md-image>.md-meta { padding-left: 0.5em; padding-right: 0.5em; } .md-image>img { margin-top: 2px; } .md-image>.md-meta:first-of-type:before { padding-left: 4px; } #typora-source { color: #555; } /** ui for windows **/ #md-searchpanel { border-bottom: 1px solid #ccc; } #md-searchpanel .btn { border: 1px solid #ccc; } #md-notification:before { top: 14px; } #md-notification { background: #eee; } .megamenu-menu-panel .btn { border: 1px solid #ccc; } #typora-sidebar { box-shadow: none; } .file-list-item , .show-folder-name .file-list-item { padding-top: 20px; padding-bottom: 20px; line-height: 20px; } .file-list-item-summary { height: 40px; line-height: 20px; } ajaxajax发送异步请求（四步操作）响应内容为xml数据第五例：省市联动XStreamJSONjson-libajaxajax是什么?asynchronous javascript and xml：异步的js和xml它能使用js访问服务器，而且是异步访问！服务器给客户端的响应一般是整个页面，一个html完整页面！但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面！而只是数据！text：纯文本 xml：大家都熟悉！！！ json：它是js提供的数据交互格式，它在ajax中最受欢迎！异步交互和同步交互同步：发一个请求，就要等待服务器的响应结束，然后才能发第二个请求！中间这段时间就是一个字“卡” 刷新的是整个页面！异步：发一个请求后，无需等待服务器的响应，然后就可以发第二个请求！ 可以使用js接收服务器的响应，然后使用js来局部刷新！ajax应用场景百度的搜索框用户注册时（校验用户名是否被注册过）ajax的优缺点优点：异步交互：增强了用户的体验！性能：因为服务器无需再响应整个页面，只需要响应部份内容，所以服务器的压力减轻了！缺点：ajax不能应用在所有场景！ajax无端的增多了对服务器的访问次数，给服务器带来了压力！ajax发送异步请求（四步操作）第一步（得到XMLHttpRequest）ajax其实只需要学习一个对象：XMLHttpRequest，如果掌握了它，就掌握了ajax！！！得到XMLHttpRequest大多数浏览器都支持：var xmlHttp = new XMLHttpRequest();IE6.0：var xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);IE5.5以更早版本的IE：var xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);编写创建XMLHttpRequest对象的函数 xxxxxxxxxx161 &nbsp; &nbsp;function createXMLHttpRequest() {2 &nbsp; &nbsp; &nbsp;try {3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return new XMLHttpRequest();4 &nbsp; &nbsp; } catch(e) {5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;try {6 &nbsp; &nbsp; &nbsp; &nbsp;return new ActiveXObject(\"Msxml2.XMLHTTP\");7 &nbsp; } catch(e) {8 &nbsp; &nbsp; &nbsp; &nbsp;try {9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return new ActiveXObject(\"Microsoft.XMLHTTP\");10 &nbsp; &nbsp; &nbsp; } catch(e) {11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;alert(\"哥们儿，你用的是什么浏览器啊？\");12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;throw e;13 &nbsp; &nbsp; &nbsp; }14 &nbsp; }15 &nbsp; &nbsp; }16 &nbsp; }第二步（打开与服务器的连接）xmlHttp.open()：用来打开与服务器的连接，它需要三个参数：请求方式：可以是GET或POST 请求的URL：指定服务器端资源，例如；/day23_1/AServlet 请求是否为异步：如果为true表示发送异步请求，否则同步请求！xmlHttp.open(&quot;GET&quot;, &quot;/day23_1/AServlet&quot;, true);第三步（发送请求）xmlHttp.send(null)：如果不给可能会造成部份浏览器无法发送！参数：就是请求体内容！如果是GET请求，必须给出null。第四步（）在xmlHttp对象的一个事件上注册监听器：onreadystatechangexmlHttp对象一共有5个状态：0状态：刚创建，还没有调用open()方法; 1状态：请求开始：调用了open()方法，但还没有调用send()方法 2状态：调用完了send()方法了； 3状态：服务器已经开始响应，但不表示响应结束了！ 4状态：服务器响应结束！（通常我们只关心这个状态！！！）得到xmlHttp对象的状态：var state = xmlHttp.readyState;//可能是0、1、2、3、4得到服务器响应的状态码var status = xmlHttp.status;//例如为200、404、500得到服务器响应的内容1var content = xmlHttp.responseText;//得到服务器的响应的文本格式的内容 var content = xmlHttp.responseXML;//得到服务器的响应的xml响应的内容，它是Document对象了！ xxxxxxxxxx61 &nbsp;xmlHttp.onreadystatechange = function() {//xmlHttp的5种状态都会调用本方法2 &nbsp; &nbsp; &nbsp;if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {//双重判断：判断是否为4状态，而且还要判断是否为2003 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 获取服务器的响应内容4 &nbsp; &nbsp;var text = xmlHttp.responseText;5 &nbsp; &nbsp; }6 };第二例：发送POST请求(如果发送请求时需要带有参数，一般都用POST请求)open：xmlHttp.open(&quot;POST&quot; ....);添加一步：设置Content-Type请求头：xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);send：xmlHttp.send(&quot;username=zhangSan&amp;password=123&quot;);//发送请求时指定请求体第三例：注册表单之校验用户是否注册！编写页面：ajax3.jsp给出注册表单页面 给用户名文本框添加onblur事件的监听 获取文本框的内容，通过ajax4步发送给服务器，得到响应结果如果为1：在文本框后显示“用户名已被注册”如果为0：什么都不做！编写ServletValidateUsernameServlet获取客户端传递的用户名参数 判断是否为itcast是：返回1否：返回0响应内容为xml数据服务器端：设置响应头：ContentType，其值为：text/xml;charset=utf-8客户端：var doc = xmlHttp.responseXML;//得到的是Document对象！第四例：响应内容为xml数据第五例：省市联动页面 xxxxxxxxxx111&lt;select name=\"province\"&gt;2​3 &nbsp;&lt;option&gt;=请选择省份=&lt;/option&gt;4​5&lt;/select&gt;6​7&lt;select name=\"city\"&gt;8​9 &nbsp;&lt;option&gt;=请选择城市=&lt;/option&gt; &nbsp;10​11&lt;/select&gt;ProvinceServletProvinceServlet：当页面加载完毕后马上请求这个Servlet！它需要加载china.xml文件，把所有的省的名称使用字符串发送给客户端！页面的工作获取这个字符串，使用逗号分隔，得到数组循环遍历每个字符串（省份的名称），使用每个字符串创建一个&lt;option&gt;元素添加到&lt;select name=&quot;province&quot;&gt;这个元素中CityServletCityServlet：当页面选择某个省时，发送请求！得到省份的名称，加载china.xml文件，查询出该省份对应的元素对象！，把这个元素转换成xml字符串，发送给客户端页面的工作把&lt;select name=&quot;city&quot;&gt;中的所有子元素删除，但不要删除&lt;option&gt;===请选择城市===&lt;/option&gt;得到服务器的响应结果：doc！！！获取所有的&lt;city&gt;子元素，循环遍历，得到&lt;city&gt;的内容使用每个&lt;city&gt;的内容创建一个&lt;option&gt;元素，添加到&lt;select name=&quot;city&quot;&gt;XStream什么作用可以把JavaBean转换为（序列化为）xmlXStream的jar包核心JAR包：xstream-1.4.7.jar；必须依赖包：xpp3_min-1.1.4c（XML Pull Parser，一款速度很快的XML解析器）；使用步骤XStream xstream = new XStream();String xmlStr = xstream.toXML(javabean);使用细节别名：把类型对应的元素名修改了xstream.alias(&quot;china&quot;, List.class)：让List类型生成的元素名为china xstream.alias(&quot;province&quot;, Province.class)：让Province类型生成的元素名为province使用为属性：默认类的成员，生成的是元素的子元素！我们希望让类的成员生成元素的属性xstream.useAttributeFor(Province.class, &quot;name&quot;)：把Province类的名为name成员，生成&lt;province&gt;元素的name属性去除Collection类型的成名：我们只需要Collection的内容，而不希望Collection本身也生成一个元素xstream.addImplicitCollection(Province.class, &quot;cities&quot;)：让Province类的名为cities(它是List类型的，它的内容还会生成元素)的成名不生成元素去除类的指定成名，让其不生成xml元素xstream.omitField(City.class, &quot;description&quot;)：在生成的xml中不会出现City类的名为description的对应的元素！JSONjson是什么它是js提供的一种数据交换格式！json的语法{}：是对象！属性名必须使用双引号括起来！单引不行！！！ 属性值：null数值字符串数组：使用[]括起来boolean值：true和false应用jsonvar person = {&quot;name&quot;:&quot;zhangSan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;male&quot;};json与xml比较可读性：XML胜出解析难度：JSON本身就是JS对象（主场作战），所以简单很多流行度：XML已经流行好多年，但在AJAX领域，JSON更受欢迎。json-lib是什么？它可以把javabean转换成json串jar包略核心类JSONObject --&gt; MaptoString();JSONObject map = JSONObject.fromObject(person)：把对象转换成JSONObject对象JSONArray --&gt; ListtoString()JSONArray jsonArray = JSONObject.fromObject(list)：把list转换成JSONArray对象","categories":[],"tags":[]},{"title":"","slug":"彻底理解Git","date":"2017-11-13T10:46:05.000Z","updated":"2017-11-13T10:48:08.000Z","comments":true,"path":"2017/11/13/彻底理解Git/","link":"","permalink":"http://io.stelawliet.top/2017/11/13/彻底理解Git/","excerpt":"","text":"彻底理解Git翻译 2016年05月25日 23:24:14 标签： git **10903 Translated from http://maryrosecook.com/blog/post/git-from-the-inside-out. 本文原地址：https://github.com/pysnow530/git-from-the-inside-out/blob/master/README.md 本文主要解释git的工作原理。如果你是一个视频党，请移步youtube视频。 本文假设你已经了解Git，并可以使用它来对项目做版本控制。我们主要考察支撑Git的图结构和指导Git行为的图属性。在考察原理时，我们会创建真实的状态模型，而不是通过各种实验的结果妄做猜想。通过这个真实的状态模型，我们可以更直观地了解git已经做了什么，正在做什么，以及接下来要做什么。 本文结构组织为一系列的Git命令，针对一个单独的项目展开。在关键的地方，我们会观察Git当前状态的图结构，并解释图属性及其产生的行为。 如果你读完本文后仍意犹未尽，可以看一下maryrosecook对Git的JavaScript实现 ，里面包含了大量注释。 创建项目123~ $ mkdir alpha~ $ cd alpha123 创建项目目录alpha。 123~/alpha $ mkdir data~/alpha $ printf &apos;a&apos; &gt; data/letter.txt123 进入alpha目录，创建目录data。在data目录下，创建内容为a的文件letter.txt。现在，alpha的目录结构如下： 1234alpha└── data └── letter.txt1234 初始化仓库123~/alpha $ git initInitialized empty Git repository123 git init命令将当前目录添加到Git仓库。为此，它会在当前目录下创建一个.git目录并写入一批文件。这些文件记录了Git配置和版本历史的所有信息。它们都是一些普通的文件，并没什么特别。用户可以使用编辑器或shell命令对它们进行浏览或编辑。也就是说，用户可以像编辑他们的项目文件一样来浏览或编辑项目的版本历史。 现在，alpha的目录结构变成了这个样子： 1234567alpha├── data│ └── letter.txt└── .git ├── objects etc...1234567 .git目录和它的内容是由Git创建的。其它文件组成了工作区，是由用户创建的。 添加文件12~/alpha $ git add data/letter.txt12 添加data/letter.txt文件到Git。该操作有两个影响。 第一，它会在.git/objects/目录下创建一个新的blob文件。 这个blob文件包含了data/letter.txt文件压缩后的内容，文件名取自内容的哈希值。哈希意味着执行一段算法，将给定内容转换为更小的1，且能唯一2确定原内容的值的过程。例如，Git对a作哈希得到2e65efe2a145dda7ee51d1741299f848e5bf752e。哈希值的头两个字符用作对象数据库的目录名：.git/objects/2e/，剩下的字符用作blob文件的文件名：.git/objects/2e/65efe2a145dda7ee51d1741299f848e5bf752e。 注意刚才添加文件时，Git将它的内容保存到objects目录的过程。即使我们从工作区把data/letter.txt文件删掉，它的内容仍然可以在Git中找回。 第二，它会将data/letter.txt文件添加到index。index是一个列表，它记录有我们想要跟踪的所有文件。该列表保存在.git/index文件内，每一行维护一个文件名到（添加到index时的）文件内容哈希值的映射。执行git add命令后的index如下： 12data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e12 创建一个内容为1234的文件data/number.txt。 12~/alpha $ printf &apos;1234&apos; &gt; data/number.txt12 现在工作区的目录结构如下： 12345alpha└── data ├── letter.txt └── number.txt12345 将data/number.txt添加到Git。 12~/alpha $ git add data12 git add命令创建一个包含data/number.txt内容的blob对象，然后添加一个index项，将data/number.txt指向刚刚创建的blob对象。执行完后的index如下： 123data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752edata/number.txt 274c0052dd5408f8ae2bc8440029ff67d79bc5c3123 注意，虽然我们执行的是git add data，但只有data目录内的文件被加到index，data不会被加入。 123~/alpha $ printf &apos;1&apos; &gt; data/number.txt~/alpha $ git add data123 我们原打算在data/number.txt内写入1而不是刚才的1234，现在修正一下，然后将文件重新加到index。这条命令会为新的内容重新生成一个blob文件，并更新data/number.txt在index中的指向。 创建提交123~/alpha $ git commit -m &apos;a1&apos; [master (root-commit) 774b54a] a1123 创建一个提交a1。Git会打印出此次提交的简短描述。 提交命令对应三个步骤。创建提交版本对应文件的树图（tree graph），创建一个提交对象，然后将当前分支指向该提交。 创建树图树图记录着index内对应文件 (即项目文件) 的位置和内容，Git通过树图来记录项目的当前状态。 树图由两类对象组成：blob和tree。 blob是在执行git add命令时创建的，用来保存项目文件的内容。 tree是在创建提交时产生的，一个tree对应工作区的一个目录。 创建提交后，对应data目录的tree如下： 123100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt100664 blob 56a6051ca2b02b04ef92d5150c9ef600403cb1de number.txt123 第一行记录了恢复data/letter.txt文件需要的所有信息。第一部分表示该文件的权限，第二部分表示该行记录的是一个blob对象，第三部分表示该blob的哈希值，第四部分记录了文件名。 第二行是data/number.txt的信息。 下面是对应alpha目录（项目根目录）的tree： 12040000 tree 0eed1217a2947f4930583229987d90fe5e8e0b74 data12 这仅有的一行指向data这个树对象。 Tree graph for the a1 commit 上图中，root tree指向了data，而data tree指向了data/letter.txt和data/number.txt这两个blob。 创建提交对象git commit在创建完树图后会创建一个提交对象。提交对象是.git/objects/目录下的另一种文本文件： 123456tree ffe298c3ce8bb07326f888907996eaa48d266db4author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500a1123456 第一行指向一个tree对象。通过这里的哈希值，我们可以找到一个指向工作区根目录（即alpha目录）的tree对象。最后一行是提交信息。 a1 commit object pointing at its tree graph 将当前分支指向新提交最后，commit命令将当前分支指向新的提交。 那么，哪个是当前分支呢？Git查看保存HEAD的文件.git/HEAD，此时它的内容是： 12ref: refs/heads/master12 好了，HEAD现在指向master，master就是我们的当前分支。 HEAD和master都是引用。引用是一个标记，Git或用户可以通过它找到某个提交。 代表master引用的文件还不存在，因为这是我们在该仓库的第一个提交。不过不用担心，Git会创建该文件.git/refs/heads/master并写入提交对象的哈希值： 1274ac3ad9cde0b265d2b4f1c778b283a6e2ffbafd12 注意：如果你跟着本文边读边敲，你的a1提交生成的哈希值会跟上值不同。像blob和tree这样以内容计算哈希的对象，它们的哈希值与本文相同。提交不然，因为它的哈希值包含了提交日期和作者的信息。 现在把HEAD和master添加到我们的图里： HEAD pointing at master and master pointing at the a1 commit HEAD指向master，这跟提交前一样。但是master现在已经存在了，而且它指向了新的提交对象。 创建第二个提交12下图是提交`a1`后的Git状态图（包含工作区和index）：12 a1 commit shown with the working copy and index 注意，data/letter.txt和data/number.txt的内容在工作区、index和a1是一致的。index和HEAD都通过哈希值指向blob对象，而在工作区，内容直接保存在文件里。 12~/alpha $ printf &apos;2&apos; &gt; data/number.txt12 将data/number.txt的内容更新为2。这个操作只修改了工作区，index和HEAD不变。 data/number.txt set to 2 in the working copy 12~/alpha $ git add data/number.txt12 将文件添加到Git。此操作将在objects目录下添加一个内容为2的blob对象，然后将index中的data/number.txt项指向该blob对象。 data/number.txt set to 2 in the working copy and index 123~/alpha $ git commit -m &apos;a2&apos; [master f0af7e6] a2123 提交此次变更。Git在这里做的操作跟之前第一次提交时相同。 第一步，创建包含index文件列表的树图。 index中的data/number.txt项已经更新，老的data tree不能再反映data目录现在的状态了，此时一个新的data tree会被创建： 123100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt100664 blob d8263ee9860594d2806b0dfd1bfd17528b0ba2a4 number.txt123 新的data tree和之前的data tree有不同的哈希值，为记录这一变化，新的root tree被创建： 12040000 tree 40b0318811470aaacc577485777d7a6780e51f0b data12 第二步，一个新的commit对象被创建。 1234567tree ce72afb5ff229a39f6cce47b00d1b0ed60fe3556parent 774b54a193d6cfdd081e581a007d2e11f784b9feauthor Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500a21234567 commit对象的第一行指向新的root tree，第二行指向父提交a1。Git会查看HEAD，找到当前分支master，进而找到父提交的哈希值。 第三步，新创建的提交的哈希值被写入记录master分支的文件。 a2 commit Git graph without the working copy and index 图属性：项目内容被保存到blob和tree对象组成的树形结构里。这意味着只有变化的文件才被保存到对象数据库。看上图，a2重用了a1提交前生成的a blob。同样的，如果一个目录在提交前后没有变化，那么这个目录及其子目录的tree对象和blob对象都可以重用。通常，我们的单个提交只包含极少的变化文件，这意味着Git可以使用少量磁盘空间保存大量提交历史。 图属性：每个提交都有一个父提交。这意味着仓库可以记录项目提交历史。 译者注：仓库的第一个提交是没有父提交的（或者说父提交为空）。 图属性：ref是某段提交历史的入口。这意味着我们可以给某个提交一个有意义的名字。用户将工作组织成不同版本线，并赋予有意义的ref，如fix-for-bug-376。Git使用符号链接来操作提交历史，如HEAD、MERGE_HEAD和FETCH_HEAD。 图属性：objects/目录下的结点是不可变的。这意味着它的内容可以编辑，但不能删除。添加的文件内容和创建的提交都保存在objects目录3下。 图属性：ref是可变的。因此，一个分支的状态是可以修改的。master分支指向的提交可能是项目当前最好的版本，但它会被一个新的更好的提交取代。 图属性：工作区和ref指向的提交更容易被访问到，其它提交会麻烦一点。这意味着最近的提交历史更容易被访问，但它们更经常被修改。或者说，Git has a fading memory that must be jogged with increasingly vicious prods。 工作区是在历史里最容易找到的，它就在仓库的根目录，不需要执行Git命令。它也是在历史里我们最经常修改的，用户可以针对一个文件修改N个版本，但Git只记录执行add命令时的版本。 HEAD指向的提交很容易找到，它就是当前分支的最近一个提交。执行git statsh4命令后的工作区就是它的内容。同时，HEAD也是我们最经常修改的ref。 其它ref指向的提交也很容易找到，我们只要把它们检出就可以了。修改其它分支没有修改HEAD来得经常，但当修改其它分支涉及到的功能时，它们就会变得非常有用。 没有被ref指向的提交是很难找到的。在某个ref上的提交越多，操作之前的提交就越不容易。但我们通常很少操作很久之前的提交5。 检出提交123~/alpha $ git checkout 37888c2 You are in &apos;detached HEAD&apos; state...123 使用a2的哈希值检出该提交。(此命令不能直接运行，请先使用git log找到你仓库里a2的哈希值。) 检出操作分四步。 第一步，Git找到a2指向的树图。 第二步，将树图里对应的文件写到工作区。这一步不会产生任何变化。工作区的内容已经和树图保持一致了，因为我们的HEAD之前就已经通过master指向a2提交了。 第三步，将树图里对应的文件写到index。这一步也不会产生任何变化。index也已经跟树图的内容保持一致了。 第四步，将a2的哈希值写入HEAD: 12f0af7e62679e144bb28c627ee3e8f7bdb235eee912 将HEAD内容设置为某个哈希值会导致仓库进入detached HEAD状态。注意下图中的HEAD，它直接指向a2提交，而不再指向master。 Detached HEAD on a2 commit 12345~/alpha $ printf &apos;3&apos; &gt; data/number.txt~/alpha $ git add data/number.txt~/alpha $ git commit -m &apos;a3&apos; [detached HEAD 3645a0e] a312345 将data/number.txt的内容修改为3，然后提交。Git查看HEAD来确定a3的父提交，它没有发现分支，而是找到了a2的哈希值。 Git将HEAD更新为a3的哈希值。此时仓库仍然处于detached HEAD状态，而没有在一个分支上，因为没有ref指向a3或它之后的提交。这意味着它很容易丢失。 从现在起，我们将在Git的状态图中忽略tree和blob。 a3 commit that is not on a branch 创建分支12~/alpha $ git branch deputy12 创建一个新分支deputy。该操作只是创建一个新文件.git/refs/heads/deputy，并把HEAD指向的a3的哈希值写入该文件。 图属性：分支只是ref，而ref只是文件。这意味着Git的分支是很轻量的。 创建deputy分支使得a3附属到了该分支上，a3现在安全了。HEAD仍然处于detached状态，因为它仍直接指向一个提交。 a3 commit now on the deputy branch 检出分支123~/alpha $ git checkout master Switched to branch &apos;master&apos;123 检出master分支。 第一步，Git会获取master指向的提交a2，根据a2获取该分支指向的树图。 第二步，Git将树图对应的文件写入工作区。此步会将data/number.txt的内容修改为2。 第三步，Git将树图对应的文件写入index。此步会将index内的data/number.txt更新为2这个blob的哈希值。 第四步，Git将HEAD指向master，即将HEAD内容由哈希值改为： 12ref: refs/heads/master12 master checked out and pointing at the a2 commit 检出与工作区有冲突的分支12345678~/alpha $ printf &apos;789&apos; &gt; data/number.txt~/alpha $ git checkout deputy Your changes to these files would be overwritten by checkout: data/number.txt Commit your changes or stash them before you switch branches.12345678 用户小手一抖，将data/number.txt文件的内容改成了789，然后试图检出deputy。Git阻止了这场血案。 HEAD通过master指向a2，data/number.txt在a2提交时的内容是2。deputy指向a3，该文件在a3提交时的内容是3。而在工作区中，该文件内容是789。这些版本的文件内容都不相同，我们必须先解决这些差异。 Git可以使用要检出的文件内容替换工作区的文件内容，但这样会导致文件内容的丢失。 Git也可以把要检出的文件内容合并到工作区，但这要复杂的多。 所以Git终止了检出操作。 1234~/alpha $ printf &apos;2&apos; &gt; data/number.txt~/alpha $ git checkout deputy Switched to branch &apos;deputy&apos;1234 现在我们意识到了这次失误，将文件改回原内容。现在可以成功检出deputy了。 deputy checked out 合并祖先提交123~/alpha $ git merge master Already up-to-date.123 将master合并到deputy。合并两个分支就是合并他们的提交。deputy指向合并的目的提交，master指向合并的源提交。Git不会对本次合并做任何操作，只是提示Already up-to-date.。 图属性：提交序列被解释为对项目内容的一系列更改。这意味着，如果源提交是目的提交的祖先提交，Git将不会做合并操作。这些修改已经被合并过了。 合并后代提交123~/alpha $ git checkout master Switched to branch &apos;master&apos;123 检出master。 master checked out and pointing at the a2 commit 123~/alpha $ git merge deputy Fast-forward123 将deputy合并到master。Git发现目的提交a2是源提交a3的祖先提交。Git使用了fast-forward合并。 Git获取源提交和它指向的树图，将树图中的文件写入工作区和index。然后使用”fast-forward”技术将master指向a3。 a3 commit from deputy fast-forward merged into master 图属性：提交序列被解释为对仓库内容的一系列更改。这意味着，如果源提交是目的提交的后代提交，提交历史是不会改变的，因为已经存在一段提交来描述目的提交和源提交之间的变化。但是Git的状态图是会改变的。HEAD指向的ref会更新为源提交。 合并不同提交线的两个提交12345~/alpha $ printf &apos;4&apos; &gt; data/number.txt~/alpha $ git add data/number.txt~/alpha $ git commit -m &apos;a4&apos; [master 7b7bd9a] a412345 将data/number.txt内容修改为4，然后提交。 1234567~/alpha $ git checkout deputy Switched to branch &apos;deputy&apos; ~/alpha $ printf &apos;b&apos; &gt; data/letter.txt ~/alpha $ git add data/letter.txt ~/alpha $ git commit -m &apos;b3&apos; [deputy 982dffb] b31234567 检出到deputy，将data/letter.txt内容修改为b，然后提交。 a4 committed to master, b3 committed to deputy and deputy checked out 图属性：多个提交可以共用一个父提交，这意味着我们可以在提交历史里创建新的提交线。 图属性：一个提交可以有多个父提交，这意味着我们可以通过创建一个合并提交来合并两个不同的提交线。 123~/alpha $ git merge master -m &apos;b4&apos; Merge made by the &apos;recursive&apos; strategy.123 合并master到deputy。 Git发现目的提交b3和源提交a4在两个不同的提交线上，它创建了一个合并提交。这个过程总共分八步。 第一步，Git将源提交的哈希值写入文件alpha/.git/MERGE_HEAD。若此文件存在，说明Git正在做合并操作。 第二步，Git查找源提交和目的提交的最近一个公共父提交，即基提交。 a3, the base commit of a4 and b3 图属性：每个提交都有一个父提交。这意味着我们可以发现两个提交线分开自哪个提交。Git查找b3和a4的所有祖先提交，发现了最近的公共父提交a3。这正是他们的基提交。 第三步，Git为基提交、源提交和目的提交创建索引。 第四步，Git创建源提交和目的提交相对于基提交的差异，此处的差异是一个列表，每一项由文件路径以及文件状态组成。状态包括：添加、移除、修改、冲突。 Git获取基提交、源提交和目的提交的文件列表，然后针对每一个文件，通过对比index来判断它的状态。Git将文件列表及状态写入差异列表。在我们的例子中，差异包含两个条目。 第一项记录data/letter.txt的状态。在基提交、目的提交和源提交中，该文件内容分别是a、b和a。文件内容在基提交和目的提交不同，但在基提交和源提交相同。Git发现文件内容被目的提交修改了，而在源提交中没有被修改。所以data/letter.txt项的状态是修改，而不是冲突。 第二项记录data/number.txt的状态。在我们的例子中，该文件内容在基提交和目的提交相同，但在基提交和源提交不同。这个条目的状态也是修改。 图属性：查找一个合并操作的基提交是可行的。这意味着，如果基提交中的一个文件只在源提交或目的提交做了修改，Git可以自动合并该文件，这样就减少了用户的工作量。 第五步，Git将差异中的项更新到工作区。data/letter.txt内容被修改为b，data/number.txt内容被修改为4。 第六步，Git将差异中的项更新到index。data/letter.txt会指向内容为b的blob，data/number.txt会指向内容为4的blob。 第七步，更新后的index被提交： 12345678tree 20294508aea3fb6f05fcc49adaecc2e6d60f7e7dparent 982dffb20f8d6a25a8554cc8d765fb9f3ff1333bparent 7b7bd9a5253f47360d5787095afc5ba56591bfe7author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500b412345678 注意，这个提交有两个父提交。 第八步，Git将当前分支deputy指向新创建的提交。 b4, the merge commit resulting from the recursive merge of a4 into b3 合并不同提交线且有相同修改文件的两个提交12345~/alpha $ git checkout master Switched to branch &apos;master&apos;~/alpha $ git merge deputy Fast-forward12345 检出master，将deputy合并到master。此操作将使用fast-forwards将master指向b4。现在，master和deputy指向了相同的提交。 deputy merged into master to bring master up to the latest commit, b4 1234567~/alpha $ git checkout deputy Switched to branch &apos;deputy&apos;~/alpha $ printf &apos;5&apos; &gt; data/number.txt~/alpha $ git add data/number.txt~/alpha $ git commit -m &apos;b5&apos; [deputy bd797c2] b51234567 检出deputy。将data/number.txt内容修改为5，然后提交。 1234567~/alpha $ git checkout master Switched to branch &apos;master&apos;~/alpha $ printf &apos;6&apos; &gt; data/number.txt~/alpha $ git add data/number.txt~/alpha $ git commit -m &apos;b6&apos; [master 4c3ce18] b61234567 检出master。将data/number.txt内容修改为6，然后提交。 b5 commit on deputy and b6 commit on master 12345~/alpha $ git merge deputy CONFLICT in data/number.txt Automatic merge failed; fix conflicts and commit the result.12345 将deputy合并到master。合并因冲突中止。对于有冲突的合并操作，执行步骤的前六步跟没有冲突的合并是相同的：写入.git/MERGE_HEAD，查找基提交，创建基提交、目的提交和源提交的索引，生成差异，更新工作区，更新index。由于发生了冲突，第七步（创建提交）和第八步（更新ref）不再执行。让我们再来看看这些步骤，观察到底发生了什么。 第一步，Git将源提交的哈希值写入.git/MERGE_HEAD。 MERGE_HEAD written during merge of b5 into b6 第二步，Git查找到基提交b4。 第三步，Git创建基提交、目的提交和源提交的索引。 第四步，Git生成目的提交和源提交相对于基提交的差异列表，每一项包含文件路径和该文件的状态：添加、移除、修改或冲突。 在本例中，差异列表仅包含一项：data/number.txt。由于它的内容在源提交和目的提交中都是变化的（相对于基提交），它的状态被标为冲突。 第五步，差异列表中的文件被写入工作区。对于冲突的部分，Git将两个版本都写入工作区。data/number.txt的内容变为： 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD6=======5&gt;&gt;&gt;&gt;&gt;&gt;&gt; deputy123456 第六步，差异列表中的文件被写入index。index中的项被文件路径和stage的组合唯一标识。没有冲突的项stage为0。在本次合并前，index看起来像下面的样子（标有0的一列是stage）： 1230 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea7480 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb123 差异列表写入index后，index变成： 123450 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea7481 data/number.txt bf0d87ab1b2b0ec1a11a3973d2845b42413d97672 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb3 data/number.txt 7813681f5b41c028345ca62a2be376bae70b7f6112345 stage 0的data/letter.txt项跟合并前一样。stage 0的data/number.txt项已经不复存在，取而代之的是三个新项。stage 1的项包含该文件在基提交中内容的哈希值，stage 2包含目的提交的哈希值，stage 3包含源提交的哈希值。这三项表明文件data/number.txt存在冲突。 合并中止了。 123~/alpha $ printf &apos;11&apos; &gt; data/number.txt~/alpha $ git add data/number.txt123 将两个有冲突的文件合并，这里我们将data/number.txt的内容修改为11，然后将文件添加到index，以告诉Git冲突已经解决了。Git为11创建一个blob，移除index中的三项data/number.txt，并添加stage为0的data/number.txt项，该项指向新创建blob。现在index变成了： 1234560 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea7480 data/number.txt 9d607966b721abde8931ddd052181fae905db503~/alpha $ git commit -m &apos;b11&apos; [master 251a513] b11123456 第七步，提交。Git发现存在.git/MERGE_HEAD，也就是说合并还在进行。通过检查index，发现没有冲突。它创建了一个新提交b11，用来记录合并后的内容。然后删除.git/MERGE_HEAD。此次合并完成。 第八步，Git将当前分支master指向新提交。 b11, the merge commit resulting from the conflicted, recursive merge of b5 into b6 移除文件下图是当前Git的状态图，其中包含了提交历史、最后提交的tree和blob、工作区以及index： The working copy, index, b11 commit and its tree graph 123~/alpha $ git rm data/letter.txt rm &apos;data/letter.txt&apos;123 使用Git移除data/letter.txt。Git将该文件从工作区和index删除。 After data/letter.txt rmed from working copy and index 123~/alpha $ git commit -m &apos;11&apos; [master d14c7d2] 11123 提交变更。按照惯例，Git为index创建一个树图。该树图不再包含data/letter.txt，因为它已经从index删除了。 11 commit made after data/letter.txt rmed 拷贝仓库123~/alpha $ cd .. ~ $ cp -R alpha bravo123 将alpha/拷贝到bravo/。此时将出现下面的目录结构： 12345678~├── alpha│ └── data│ └── number.txt└── bravo └── data └── number.txt12345678 现在bravo目录存在另一个Git状态图： New graph created when alpha cped to bravo 关联其它仓库123 ~ $ cd alpha~/alpha $ git remote add bravo ../bravo123 回到alpha仓库，将bravo设置为alpha仓库的远程仓库。该操作将在alpha/.git/config添加两行内容： 123[remote &quot;bravo&quot;] url = ../bravo/123 这两行说明，存在一个远程仓库bravo，该仓库位于../bravo目录。 从远程仓库获取分支123456~/alpha $ cd ../bravo~/bravo $ printf &apos;12&apos; &gt; data/number.txt~/bravo $ git add data/number.txt~/bravo $ git commit -m &apos;12&apos; [master 94cd04d] 12123456 进入bravo仓库，将data/number.txt内容修改为12并提交到master。 12 commit on bravo repository 123456~/bravo $ cd ../alpha~/alpha $ git fetch bravo master Unpacking objects: 100% From ../bravo * branch master -&gt; FETCH_HEAD123456 进入alpha仓库，将bravo的master分支取回到alpha。该操作分四步。 第一步，Git获取bravo仓库中master指向提交的哈希值，也就是提交12的哈希值。 第二步，Git创建一个包含了12提交依赖的所有对象的列表，包括提交对象本身和祖先提交，以及它们的树图内的所有对象。它将alpha对象数据库中已经存在的对象从列表中移除。然后将列表的对象拷贝到alpha/.git/objects/。 第三步，Git将ref文件alpha/.git/refs/remotes/bravo/master的内容更新为提交12的哈希值。 第四步，alpha/.git/FETCH_HEAD的内容被设置为： 1294cd04d93ae88a1f53a4646532b1e8cdfbc0977f branch &apos;master&apos; of ../bravo12 这表示最近一次执行fetch命令获取的是bravo中master分支的提交12。 alpha after bravo/master fetched 图属性：对象可以被拷贝。这意味着提交历史可以被不同仓库共享。 图属性：仓库可以保存远程分支的ref，如alpha/.git/refs/remotes/bravo/master。这意味着仓库可以将远程仓库的分支状态记录到本地。在获取该分支时，它将会被修正，但如果远程分支修改了，它就会过期。 合并FETCH_HEAD1234~/alpha $ git merge FETCH_HEAD Updating d14c7d2..94cd04d Fast-forward1234 合并FETCH_HEAD。FETCH_HEAD只是另一个ref，它解析到源提交12。HEAD指向目的提交11。Git使用fast-forward合并将master指向12提交。 alpha after FETCH_HEAD merged 从远程仓库拉取分支123~/alpha $ git pull bravo master Already up-to-date.123 将bravo仓库的master分支拉取到alpha仓库。pull是”fetch and merge FETCH_HEAD“的简写。Git执行这条命令然后报告master分支Already up-to-date。 克隆仓库1234~/alpha $ cd .. ~ $ git clone alpha charlie Cloning into &apos;charlie&apos;1234 进入上层目录，克隆alpha到charlie。克隆到charlie和我们之前使用cp拷贝bravo仓库的结果是相同的。Git首先创建一个目录charlie，然后将charlie初始化为一个Git仓库，将alpha添加为一个远程仓库origin，获取origin并合并到FETCH_HEAD。 推送分支到远程仓库的已检出分支123456 ~ $ cd alpha~/alpha $ printf &apos;13&apos; &gt; data/number.txt~/alpha $ git add data/number.txt~/alpha $ git commit -m &apos;13&apos; [master 3238468] 13123456 返回alpha仓库，将data/number.txt修改为13，然后提交到alpha仓库的master分支。 12~/alpha $ git remote add charlie ../charlie12 将charlie设为alpha仓库的远程分支。 123456~/alpha $ git push charlie master Writing objects: 100% remote error: refusing to update checked out branch: refs/heads/master because it will make the index and work tree inconsistent123456 将master推送到charlie仓库。 13提交依赖的所有对象都被拷贝到charlie仓库。 此时，推送操作中止了。Git给出了出错信息，它拒绝将分支推送到远程已检出的分支上。这在情理之中，因为如果推送成功，远程分支的index和HEAD将会改变。如果此时有人正在编辑远程分支的工作区，他就懵b了。 此时，我们可以创建一个新的分支，将13提交合并进来，然后推到charlie。但是我们往往希望仓库可以随时提交。我们希望有一个中心仓库可以用来做同步，而又没有人可以直接在远程仓库仓库，就像Github一样。这时我们就需要一个裸仓库(bare repository)。 克隆裸仓库1234~/alpha $ cd .. ~ $ git clone alpha delta --bare Cloning into bare repository &apos;delta&apos;1234 返回上层目录，克隆出一个裸仓库delta。这跟普通的克隆只有两点不同：config文件会指明该仓库是一个裸仓库，之前在.git目录的文件现在直接放在仓库目录下： 123456delta├── HEAD├── config├── objects└── refs123456 alpha and delta graphs after alpha cloned to delta 推送分支到裸仓库123 ~ $ cd alpha~/alpha $ git remote add delta ../delta123 回到alpha仓库，将delta仓库设为alpha的远程仓库。 12345~/alpha $ printf &apos;14&apos; &gt; data/number.txt~/alpha $ git add data/number.txt~/alpha $ git commit -m &apos;14&apos; [master cb51da8] 1412345 将data/number.txt内容修改为14并提交到alpha的master分支。 14 commit on alpha 12345~/alpha $ git push delta master Writing objects: 100% To ../delta 3238468..cb51da8 master -&gt; master12345 将master推送到delta。此操作分三步。 第一步，master分支上14提交依赖的所有对象都被从alpha/.git/objects/拷贝到delta/objects。 第二步，delta/refs/heads/master更新为14提交。 第三步，alpha/.git/refs/remotes/delta/master更新为14提交。alpha记录了delta更新后的状态。 14 commit pushed from alpha to delta 总结Git构建在图上，几乎所有的Git命令都是在操作这个图。想要深入了解Git，关注图属性而不是执行流程或命令。 想要学习更多Git知识，可以研究一下.git目录。没什么可怕的。看看它里面有哪些东西。修改文件内容，观察发生了什么。手动创建一个提交，看看你能把仓库搞得多惨。然后试着修复它。 脚注 在这个例子中，哈希值内容比原文件更长。不管是否能节约空间，Git始终选择使用哈希值作为文件名。 也有可能两个不同的内容有相同的哈希值，但这个可能性很低。 git prune删除所有不能被ref访问到的对象。执行此命令可能会丢失数据。 git stash将工作区和HEAD提交的所有差异保存到一个安全的地方。它们可以在以后取回。 rebase命令可以用来添加、编辑或删除历史提交。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/文件上传","date":"2017-11-12T15:36:19.000Z","updated":"2017-11-12T16:14:37.000Z","comments":true,"path":"2017/11/12/Java/JavaEE/文件上传/","link":"","permalink":"http://io.stelawliet.top/2017/11/12/Java/JavaEE/文件上传/","excerpt":"","text":"day22总结文件上传概述1 文件上传的作用例如网络硬盘！就是用来上传下载文件的。 在智联招聘上填写一个完整的简历还需要上传照片呢。 2 文件上传对页面要求上传文件的要求： 必须使用表单，而不能是超链接； 表单的method必须是POST，而不能是GET； 表单的enctype必须是multipart/form-data； 在表单中添加file表单字段，即\\ 1234567&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/FileUploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 文件1：&lt;input type=\"file\" name=\"file1\"/&gt;&lt;br/&gt; 文件2：&lt;input type=\"file\" name=\"file2\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; 3** 比对文件上传表单和普通文本表单的区别** 通过httpWatch查看“文件上传表单”和“普通文本表单”的区别。 文件上传表单的enctype=”multipart/form-data”，表示多部件表单数据； 普通文本表单可以不设置enctype属性： 当method=”post”时，enctype的默认值为application/x-www-form-urlencoded，表示使用url编码正文； 当method=”get”时，enctype的默认值为null，没有正文，所以就不需要enctype了。 对普通文本表单的测试： 123456&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/FileUploadServlet\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 文件1：&lt;input type=\"file\" name=\"file1\"/&gt;&lt;br/&gt; 文件2：&lt;input type=\"file\" name=\"file2\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; day22-1 day22-2 通过httpWatch测试，查看表单的请求数据正文，我们发现请求中只有文件名称，而没有文件内容。也就是说，当表单的enctype不是multipart/form-data时，请求中不包含文件内容，而只有文件的名称，这说明普通文本表单中input:file与input:text没什么区别了。 对文件上传表单的测试： 123456&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/FileUploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 文件1：&lt;input type=\"file\" name=\"file1\"/&gt;&lt;br/&gt; 文件2：&lt;input type=\"file\" name=\"file2\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; day22-4 通过httpWatch测试，查看表单的请求数据正文部分，发现正文部分是由多个部件组成，每个部件对应一个表单字段，每个部件都有自己的头信息。头信息下面是空行，空行下面是字段的正文部分。多个部件之间使用随机生成的分隔线隔开。 文本字段的头信息中只包含一条头信息，即Content-Disposition，这个头信息的值有两个部分，第一部分是固定的，即form-data，第二部分为字段的名称。在空行后面就是正文部分了，正文部分就是在文本框中填写的内容。 文件字段的头信息中包含两条头信息，Content-Disposition和Content-Type。Content-Disposition中多出一个filename，它指定的是上传的文件名称。而Content-Type指定的是上传文件的类型。文件字段的正文部分就是文件的内容。 请注意，因为我们上传的文件都是普通文本文件，即txt文件，所以在httpWatch中是可以正常显示的，如果上传的是exe、mp3等文件，那么在httpWatch看到的就是乱码了。 4 文件上传对Servlet的要求当提交的表单是文件上传表单时，那么对Servlet也是有要求的。 首先我们要肯定一点，文件上传表单的数据也是被封装到request对象中的。 request.getParameter(String)**方法获取指定的表单字段字符内容，但文件上传表单已经不在是字符内容，而是字节内容，所以失效。** 这时可以使用request的getInputStream()方法获取ServletInputStream对象，它是InputStream的子类，这个ServletInputStream对象对应整个表单的正文部分（从第一个分隔线开始，到最后），这说明我们需要的解析流中的数据。当然解析它是很麻烦的一件事情，而Apache已经帮我们提供了解析它的工具：commons-fileupload。 可以尝试把request.getInputStream()这个流中的内容打印出来，再对比httpWatch中的请求数据。 12345678910111213141516171819202122 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; InputStream in = request.getInputStream();//使用apache的commons-io组件，把流中的数据读取出来转换成字符串 String s = IOUtils.toString(in); System.out.println(s); &#125;-----------------------------7ddd3370ab2Content-Disposition: form-data; name=\"username\"hello-----------------------------7ddd3370ab2Content-Disposition: form-data; name=\"file1\"; filename=\"a.txt\"Content-Type: text/plainaaa-----------------------------7ddd3370ab2Content-Disposition: form-data; name=\"file2\"; filename=\"b.txt\"Content-Type: text/plainbbb-----------------------------7ddd3370ab2-- commons-fileupload为什么使用fileupload： 上传文件的要求比较多，需要记一下： l 必须是POST表单； l 表单的enctype必须是multipart/form-data； l 在表单中添加file表单字段，即 Servlet的要求： l 不能再使用request.getParameter()来获取表单数据； l 可以使用request.getInputStream()得到所有的表单数据，而不是一个表单项的数据； l 这说明不使用fileupload，我们需要自己来对request.getInputStream()的内容进行解析！！！ 1 fileupload概述fileupload是由apache的commons组件提供的上传组件。它最主要的工作就是帮我们解析request.getInputStream()。 fileupload组件需要的JAR包有： l commons-fileupload.jar，核心包； l commons-io.jar，依赖包。 2 fileupload简单应用 fileupload的核心类有：DiskFileItemFactory、ServletFileUpload、FileItem。 使用fileupload组件的步骤如下： 创建工厂类DiskFileItemFactory对象：DiskFileItemFactoryfactory = new DiskFileItemFactory() 使用工厂创建解析器对象：ServletFileUpload fileUpload = new ServletFileUpload(factory) 使用解析器来解析request对象：Listlist = fileUpload.parseRequest(request) 隆重介绍FileItem类，它才是我们最终要的结果。一个FileItem对象对应一个表单项（表单字段）。一个表单中存在文件字段和普通字段，可以使用FileItem类的isFormField()方法来判断表单字段是否为普通字段，如果不是普通字段，那么就是文件字段了。 String getName()：获取文件字段的文件名称； String getString()：获取字段的内容，如果是文件字段，那么获取的是文件内容，当然上传的文件必须是文本文件； String getFieldName()：获取字段名称，例如：&lt;inputtype=”text” name=”username”/&gt;，`返回的是username； String getContentType()：获取上传的文件的类型，例如：text/plain。 int getSize()：获取上传文件的大小； boolean isFormField()：判断当前表单字段是否为普通文本字段，如果返回false，说明是文件字段； InputStream getInputStream()：获取上传文件对应的输入流； void write(File)：把上传的文件保存到指定文件中。 3 简单上传示例写一个简单的上传示例： 表单包含一个用户名字段，以及一个文件字段； Servlet保存上传的文件到uploads目录，显示用户名，文件名，文件大小，文件类型。 第一步： 完成index.jsp，只需要一个表单。注意表单必须是post的，而且enctype必须是mulitpart/form-data的。 12345&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/FileUploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 文件1：&lt;input type=\"file\" name=\"file1\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; 第二步： 完成FileUploadServlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 因为要使用response打印，所以设置其编码 response.setContentType(\"text/html;charset=utf-8\"); // 创建工厂 DiskFileItemFactory dfif = new DiskFileItemFactory(); // 使用工厂创建解析器对象 ServletFileUpload fileUpload = new ServletFileUpload(dfif); try &#123; // 使用解析器对象解析request，得到FileItem列表 List&lt;FileItem&gt; list = fileUpload.parseRequest(request); // 遍历所有表单项 for(FileItem fileItem : list) &#123; // 如果当前表单项为普通表单项 if(fileItem.isFormField()) &#123; // 获取当前表单项的字段名称 String fieldName = fileItem.getFieldName(); // 如果当前表单项的字段名为username if(fieldName.equals(\"username\")) &#123; // 打印当前表单项的内容，即用户在username表单项中输入的内容 response.getWriter(). print(\"用户名：\" + fileItem.getString() + \"&lt;br/&gt;\"); &#125; &#125; else &#123;//如果当前表单项不是普通表单项，说明就是文件字段 String name = fileItem.getName();//获取上传文件的名称 // 如果上传的文件名称为空，即没有指定上传文件 if(name == null || name.isEmpty()) &#123; continue; &#125; // 获取真实路径，对应$&#123;项目目录&#125;/uploads，当然，这个目录必须存在 String savepath = this.getServletContext().getRealPath(\"/uploads\"); // 通过uploads目录和文件名称来创建File对象 File file = new File(savepath, name); // 把上传文件保存到指定位置 fileItem.write(file); // 打印上传文件的名称 response.getWriter().print(\"上传文件名：\" + name + \"&lt;br/&gt;\"); // 打印上传文件的大小 response.getWriter(). print(\"上传文件大小：\" + fileItem.getSize() + \"&lt;br/&gt;\"); // 打印上传文件的类型 response.getWriter(). print(\"上传文件类型：\" + fileItem.getContentType() + \"&lt;br/&gt;\"); &#125; &#125; &#125; catch (Exception e) &#123; throw new ServletException(e); &#125; &#125; 文件上传之细节1 把上传的文件放到WEB-INF目录下如果没有把用户上传的文件存放到WEB-INF目录下，那么用户就可以通过浏览器直接访问上传的文件，这是非常危险的。 假如说用户上传了一个a.jsp文件，然后用户在通过浏览器去访问这个a.jsp文件，那么就会执行a.jsp中的内容，如果在a.jsp中有如下语句：Runtime.getRuntime().exec(“shutdown –s –t 1”);，那么你就会… 通常我们会在WEB-INF目录下创建一个uploads目录来存放上传的文件，而在Servlet中找到这个目录需要使用ServletContext的getRealPath(String)方法，例如在我的upload1项目中有如下语句： ServletContextservletContext = this.getServletContext(); String savepath= servletContext.getRealPath(“/WEB-INF/uploads”); 其中savepath为：F:\\tomcat6_1\\webapps\\upload1\\WEB-INF\\uploads。 2 文件名称（完整路径、文件名称）上传文件名称可能是完整路径： IE6获取的上传文件名称是完整路径，而其他浏览器获取的上传文件名称只是文件名称而已。浏览器差异的问题我们还是需要处理一下的。 String name =file1FileItem.getName(); response.getWriter().print(name); 使用不同浏览器测试，其中IE6就会返回上传文件的完整路径，不知道IE6在搞什么，这给我们带来了很大的麻烦，就是需要处理这一问题。 处理这一问题也很简单，无论是否为完整路径，我们都去截取最后一个“\\”后面的内容就可以了。 123456String name = file1FileItem.getName(); int lastIndex = name.lastIndexOf(\"\\\\\");//获取最后一个“\\”的位置 if(lastIndex != -1) &#123;//注意，如果不是完整路径，那么就不会有“\\”的存在。 name = name.substring(lastIndex + 1);//获取文件名称 &#125; response.getWriter().print(name);","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Servlet作用域","date":"2017-11-10T05:51:50.000Z","updated":"2017-11-10T05:54:03.000Z","comments":true,"path":"2017/11/10/Java/JavaEE/Servlet作用域/","link":"","permalink":"http://io.stelawliet.top/2017/11/10/Java/JavaEE/Servlet作用域/","excerpt":"","text":"javaweb开发中Servlet三大域对象的应用 （request、session、application（ServletContext））。 requestrequest是表示一个请求，只要发出一个请求就会创建一个request，它的作用域：仅在当前请求中有效。用处：常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。方法：request.setAttribute(); request.getAttribute(); request.removeAttribute(); request.getParameter(). session服务器会为每个会话创建一个session对象，所以session中的数据可供当前会话中所有servlet共享。会话：用户打开浏览器会话开始，直到关闭浏览器会话才会结束。一次会话期间只会创建一个session对象。用处：常用于web开发中的登陆验证界面（当用户登录成功后浏览器分配其一个session键值对）。方法：session.setAttribute(); session.getAttribute(); session.removeAttribute();获得session对象方法： 在Servlet中：HttpSession session = request.getSession(); 由于session属于jsp九大内置对象之一，当然可以直接使用。例如：&lt;%session.serAttribute(“name”,”admin”)%&gt;。 session被销毁​ 1)session超时;​ 2)客户端关闭后，再也访问不到和该客户端对应的session了，它会在超时之后被销毁;​ 3)调用session. invalidate();备注： session是服务器端对象，保存在服务器端。并且服务器可以将创建session后产生的sessionid通过一个cookie返回给客户端，以便下次验证。（session底层依赖于cookie） Application（ServletContext）作用范围：所有的用户都可以取得此信息，此信息在整个服务器上被保留。Application属性范围值，只要设置一次，则所有的网页窗口都可以取得数据。ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象，所有的客户端在访问服务器时都共享同一个ServletContext对象;ServletContext对象一般用于在多个客户端间共享数据时使用;获取Application对象方法（Servlet中）：​ ServletContext app01 = this.getServletContext();​ app01.setAttribute(“name”, “kaixuan”); //设置一个值进去​ ServletContext app02 = this.getServletContext();​ app02.getAttribute(“name”); //获取键值对ServletContext同属于JSP九大内置对象之一，故可以直接使用备注：服务器只会创建一个ServletContext 对象，所以app01就是app02，通过app01设置的值当然可以通过app02获取。 总结：1.作用域： request session application 使用作用域传递数据和存储数据 使用作用域传递数据时，必须掌握作用域对应的生命周期和作用范围 2. * 生命周期 (1) request:只限于一次请求 (2) session：一次会话（多次请求） 开始 用户向服务器发送请求的时候 结束 客户端 丢失JsessionId值的时候（关闭浏览器） 服务器端 关闭服务器 超过会话的不活动周期时间 (3) application:项目的加载到卸载 *3.作用范围 (1) requset：所有被请求转发的Servlet (2) session:所有的Servlet (3)application：所有的Servlet(换一个浏览器演示，跟session作用域区分) 4.*如何正确的选择作用域 *(1) request：跟当前操作功能相关 (2) session: 跟用户信息相关 (3) application：跟项目全局信息相关—-》京东配送地址 5.如何正确的选择作用域不正确，会出现什么情况 内存浪费","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Filter","date":"2017-11-09T15:42:14.000Z","updated":"2017-11-09T15:42:14.000Z","comments":true,"path":"2017/11/09/Java/JavaEE/Filter/","link":"","permalink":"http://io.stelawliet.top/2017/11/09/Java/JavaEE/Filter/","excerpt":"","text":"Filter","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/jar包添加Maven","date":"2017-11-07T14:50:00.000Z","updated":"2017-11-07T14:52:09.000Z","comments":true,"path":"2017/11/07/Java/JavaEE/jar包添加Maven/","link":"","permalink":"http://io.stelawliet.top/2017/11/07/Java/JavaEE/jar包添加Maven/","excerpt":"","text":"手动将本地jar添加到Maven仓库原创 2016年04月07日 13:30:53 标签： maven / 依赖本地jar包 / 添加本地jar包到maven仓库 / maven项目依赖本地jar包 **15295 一、将jar添加到本地仓库的做法：以下面pom.xml依赖的jar包为例： 实际项目中pom.xml依赖写法：1234567**[html]** [view plain](http://blog.csdn.net/a491857321/article/details/51085167#) [copy](http://blog.csdn.net/a491857321/article/details/51085167#)&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;3.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; Maven 安装 JAR 包的命令是： [html] view plain copy mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar 例如我的这个spring-context-support-3.1.0.RELEASE.jar 文件放在了”D:\\mvn\\”中 则命令为：1234567891011mvn install:install-file **-Dfile=D:\\mvn\\spring-context-support-3.1.0.RELEASE.jar ****-DgroupId=org.springframework ****-DartifactId=spring-context-support ****-Dversion=3.1.0.RELEASE ****-Dpackaging=jar** 注意：任何路径和名称不要有中文和空格，以防出现莫名其妙的错误。 二、不讲jar包添加到本地仓库也可在maven工程中使用外部jar包的做法：假设将包htmlparser.jar放入了项目下的lib目录中 ： -&gt; ${project}/lib/htmlparser.jar 则pom.xml文件中依赖可以如下： [html] view plain copy1234567 &lt;dependency&gt; &lt;groupId&gt;com.htmlparser&lt;/groupId&gt; &lt;artifactId&gt;htmlparser&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/htmlparser.jar&lt;/systemPath&gt; &lt;/dependency&gt;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/wait:notify:notifyAll实现线程间通信","date":"2017-11-07T08:44:54.000Z","updated":"2017-11-07T08:44:54.000Z","comments":true,"path":"2017/11/07/Java/JavaEE/wait:notify:notifyAll实现线程间通信/","link":"","permalink":"http://io.stelawliet.top/2017/11/07/Java/JavaEE/wait:notify:notifyAll实现线程间通信/","excerpt":"","text":"【Java并发编程】之十：使用wait/notify/notifyAll实现线程间通信的几点重要说明转载 2015年11月17日 09:34:57 标签： JAVA / notify / wait / 线程间通信 / notifyAll 在Java中，可以通过配合调用Object对象的wait（）方法和notify（）方法或notifyAll（）方法来实现线程间的通信。在线程中调用wait（）方法，将阻塞等待其他线程的通知（其他线程调用notify（）方法或notifyAll（）方法），在线程中调用notify（）方法或notifyAll（）方法，将通知其他线程从wait（）方法处返回。 ​ Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify（）、notifyAll（）、wait（）、wait（long）和wait（long，int）。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。 ​ 这里详细说明一下各个方法在使用中需要注意的几点： ​ 1、wait（） ​ public final void wait() throws InterruptedException,IllegalMonitorStateException ​ 该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。进入wait（）方法后，当前线程释放锁。在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 ​ 2、notify（） ​ public final native void notify() throws IllegalMonitorStateException ​ 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。 ​ 该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的notifyAll（）方法执行后的情况不同。 ​ 3、notifyAll（） ​ public final native void notifyAll() throws IllegalMonitorStateException ​ 该方法与notify（）方法的工作方式相同，重要的一点差异是： ​ notifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 ​ 4、wait（long）和wait（long,int） ​ 显然，这两个方法是设置等待超时时间的，后者在超值时间上加上ns，精度也难以达到，因此，该方法很少使用。对于前者，如果在等待线程接到通知或被中断之前，已经超过了指定的毫秒数，则它通过竞争重新获得锁，并从wait（long）返回。另外，需要知道，如果设置了超时时间，当wait（）返回时，我们不能确定它是因为接到了通知还是因为超时而返回的，因为wait（）方法不会返回任何相关的信息。但一般可以通过设置标志位来判断，在notify之前改变标志位的值，在wait（）方法后读取该标志位的值来判断，当然为了保证notify不被遗漏，我们还需要另外一个标志位来循环判断是否调用wait（）方法。 深入理解： 如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java-wait&notify","date":"2017-11-07T07:36:22.000Z","updated":"2017-11-07T07:37:07.000Z","comments":true,"path":"2017/11/07/Java/JavaEE/Java-wait&notify/","link":"","permalink":"http://io.stelawliet.top/2017/11/07/Java/JavaEE/Java-wait&notify/","excerpt":"","text":"wait()方法与notify()必须要与synchronized(resource)一起使用。 也就是wait与notify针对已经获取了resource锁的线程进行操作， 从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。 从功能上来说wait()线程在获取对象锁后，主动释放CPU控制权，主动释放对象锁，同时本线程休眠。 直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。 相应的notify()就是对对象锁的释放操作。 【因此，我们可以发现，wait和notify方法均可释放对象的锁，但wait同时释放CPU控制权，即它后面的代码停止执行，线程进入阻塞状态，而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束，再自动释放锁。】 释放锁后，JVM会在等待resoure的线程中选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。 Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制，而在同步块中的Thread.sleep()方法并不释放锁，仅释放CPU控制权","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/JavaWeb3大域生命","date":"2017-11-03T07:29:38.000Z","updated":"2017-11-03T07:39:16.000Z","comments":true,"path":"2017/11/03/Java/JavaEE/JavaWeb3大域生命/","link":"","permalink":"http://io.stelawliet.top/2017/11/03/Java/JavaEE/JavaWeb3大域生命/","excerpt":"","text":"ServletContext服务器启动 开始 服务器关闭 消失 HttpSessionrequest.getSession(); 第一次访问创建 或是 第一次访问Jsp。（jsp内置对象默认调用request.getSession()） HTTPRequest","categories":[],"tags":[]},{"title":"","slug":"MD/A1-Study","date":"2017-11-02T15:59:48.000Z","updated":"2018-06-29T13:38:35.000Z","comments":true,"path":"2017/11/02/MD/A1-Study/","link":"","permalink":"http://io.stelawliet.top/2017/11/02/MD/A1-Study/","excerpt":"","text":"[TOC] Jsp foreach标签 ==\\&lt;c:if test = “${ }”&gt;&lt;c:choose&gt; \\&lt;c:when&gt;\\&lt;c:set&gt;\\&lt;c:otherwise&gt;== include.转发.重定向复习 baseServlet arrylist to string 12345678910@Test public void fun1()&#123; List&lt;String&gt; listS = new ArrayList&lt;&gt;(); //Set&lt;String&gt; listS = new LinkedHashSet&lt;&gt;(); for (int i = 0; i &lt;5 ; i++) &#123; listS.add(\"00\"+i); &#125; System.out.println(Arrays.toString(listS.toArray())); &#125; ​ 反射invoke的method调用 123456789101112131415161718@Test public void fun2() throws Exception &#123; Class c = Class.forName(\"Sky.Domain.Student\"); Object o = c.newInstance(); Method method0 = c.getMethod(\"setAge\", String.class); method0.invoke(o,\"10\"); System.out.println(o); Method method1= c.getMethod(\"setSname\", String.class); method1.invoke(o,\"zzq0\"); System.out.println(o); Method method2 =c.getMethod(\"getSname\"); Object sname = method2.invoke(o); System.out.println(sname); Student student = (Student)o; System.out.println(student.getAge()); &#125;@Test public void fun() throws Exception &#123;&#125; ​ io ==nio??== 事务 exquery Object序列化 国际化 Locale ResourceBundle 过滤器的测试。。多个request。forword include error IP统计 过滤器和监听器应用。（3个域复习。。笔记） HTML静态化。(过滤器先拦截。response 包装类复写getWriter（）到HTML。) 文件上传。（DiskFileItemFactory。ServletUpload。FileitemParse 上传 下载 ==上传进度监听== 装饰者模式练习（buffreader的readline增强） gzip压缩 post请求格式化编码 ajax post get Ajax username异步校验。 ajax xml响应 ​ html5 css3 ==index== css div float css table ​ jQuery dom add remove change replace 固定导航 小火箭top 弹幕 jQuery cookie add get set ​ 事件绑定不同 bind click delegate ​ jQuery ipa复习（event，css，atrr） cookie ==JavaScript RegExp== CSS 简单主页 jd.com/index.html ssm框架学习 spring h spring mvc ​ mybitas vue.js webpack ​ node.js a.js myblog 购买域名 GitHub Page MD整理 git练习 Skll yml学习 python ​ ios mac swift oc ​ ​ ​","categories":[],"tags":[]},{"title":"c3p0-config.xml","slug":"Java/JavaEE/c3p0-config.xml","date":"2017-10-30T09:08:29.000Z","updated":"2018-07-04T11:36:14.000Z","comments":true,"path":"2017/10/30/Java/JavaEE/c3p0-config.xml/","link":"","permalink":"http://io.stelawliet.top/2017/10/30/Java/JavaEE/c3p0-config.xml/","excerpt":"","text":"c3p0-config.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt;&lt;named-config name=\"mysql\"&gt; &lt;!-- 配置数据库用户名 --&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;!-- 配置数据库密码 --&gt; &lt;property name=\"password\"&gt;&lt;/property&gt; &lt;!-- 配置数据库链接地址 --&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/cdcol?useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/property&gt; &lt;!-- 配置数据库驱动 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 数据库连接池一次性向数据库要多少个连接对象 --&gt; &lt;property name=\"acquireIncrement\"&gt;20&lt;/property&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt; &lt;!-- 最小连接数 --&gt; &lt;property name=\"minPoolSize\"&gt;5&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name=\"maxPoolSize\"&gt;30&lt;/property&gt; &lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default:0 --&gt; &lt;property name=\"maxStatements\"&gt;0&lt;/property&gt; &lt;!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 --&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;0&lt;/property&gt; &lt;!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default:3 --&gt; &lt;property name=\"numHelperThreads\"&gt;3&lt;/property&gt; &lt;!--用户修改系统配置参数执行前最多等待300秒。Default: 300 --&gt; &lt;property name=\"propertyCycle\"&gt;3&lt;/property&gt; &lt;!-- 获取连接超时设置 默认是一直等待单位毫秒 --&gt; &lt;property name=\"checkoutTimeout\"&gt;1000&lt;/property&gt; &lt;!--每多少秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name=\"idleConnectionTestPeriod\"&gt;3&lt;/property&gt; &lt;!--最大空闲时间,多少秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name=\"maxIdleTime\"&gt;10&lt;/property&gt; &lt;!--配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。 --&gt; &lt;property name=\"maxIdleTimeExcessConnections\"&gt;5&lt;/property&gt; &lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt; &lt;property name=\"acquireRetryDelay\"&gt;1000&lt;/property&gt; &lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null --&gt; &lt;property name=\"automaticTestTable\"&gt;Test&lt;/property&gt; &lt;!-- 获取connnection时测试是否有效 --&gt; &lt;property name=\"testConnectionOnCheckin\"&gt;true&lt;/property&gt;&lt;/named-config&gt;&lt;/c3p0-config&gt;","categories":[{"name":"sql","slug":"sql","permalink":"http://io.stelawliet.top/categories/sql/"},{"name":"连接池","slug":"sql/连接池","permalink":"http://io.stelawliet.top/categories/sql/连接池/"}],"tags":[{"name":"c3p0","slug":"c3p0","permalink":"http://io.stelawliet.top/tags/c3p0/"},{"name":"sql","slug":"sql","permalink":"http://io.stelawliet.top/tags/sql/"}]},{"title":"","slug":"Java/JavaEE/MAVEN/intellij idea中使用maven创建web项目","date":"2017-10-29T09:01:32.000Z","updated":"2017-10-29T09:05:32.000Z","comments":true,"path":"2017/10/29/Java/JavaEE/MAVEN/intellij idea中使用maven创建web项目/","link":"","permalink":"http://io.stelawliet.top/2017/10/29/Java/JavaEE/MAVEN/intellij idea中使用maven创建web项目/","excerpt":"","text":"intellij idea中使用maven创建web项目intellij idea中使用maven创建web项目 ​ 不选择模板创建web项目 Create New Project或者File-&gt;New-&gt;Project，如图： img 点击maven,(不用选择Create from archetype,因为此处讲解不使用maven模板创建web项目)，点击next，如图： img 填写GroupId和ArtifactId,点击next，如图： img 填写项目名称，点击Finish，如图： img 此时的目录结构如图所示：可以看到这里只创建了java的文件目录，没有创建web的文件目录。 img idea会有一个提示，自动引入，点击它： img 部署项目，File-&gt;Project Structure或点击如图所示的图标： img 设置SDK，选择自己电脑上安装的SDK版本。设置Project compiler output,通常选择默认，这里是编译后的文件目录，如图： img 点击Modules,可以看到这里没有任何模板服务，在这里创建一个web服务，点击+，选择web img 设置webapp。双击Web Resource Directory,在弹出的窗口路径中选择src\\main，然后在后面添加\\webapp,点击ok。如图： img 给web文件目录设置web.xml，如图： img 设置好后点击应用： img 添加tomcat依赖，如图所示： img 在弹出的窗口中选择tomcat,点击添加，如图所示： img 点击Artifacts,这里设置当前项目发布信息。点击+，选择From Modules…在弹出的窗口中点击ok， img 如图所示，点击应用 img 当前目录如图所示，多了webapp： img 设置tomcat：点击如图所示图标： img 点击+，选择Tomcat Server -&gt;Local.如图： img 如图所示，第一次进入会隐藏热部署设置，需要下次进来设置。 img 选择Deployment-&gt;+-&gt;Artifact.如图； img 如图所示，这里我使用默认： img 现在反回Server，如图在On frame deactivation中选择Update classes and resources;设置热部署 img 点击应用或，ok。 在webapp下面新建index.jsp页面，如图； img 在web.xml中添加欢迎节点，如图: img 启动程序，如图所示； img 成功后，浏览器输出hello Word，如图： img ok，到这里，web项目设置完成。最终目录结构如图： img web模板创建文项目 Create New Project或者File-&gt;New-&gt;Project，如图： img 勾上Create frome archetype，选择maven-archetype-webapp模板，点击下一步，如图： img 填写GroupId和ArtifactId，如图所示： img 选择中央仓库的地址，点击+，添加一个Add Maven Property属性， 这里在Properties中添加一个参数archetypeCatalog=internal，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。 来自网上的解释：archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。如图： img 填写项目名称，点击finish，如图所示： img idea为我们创建好的目录结构如图所示：少java文件： img 启动java web，打开project structure，如图所示： img 选择Project，Project SDK是java jdk安装选择，Project language level是选择语言版本，Project compileroutput 是编译后的文件目录，这里我们的使用默认，你也可以根据需要填写。如图 img 选择Facets,点击+，选择web，如图所示： img 在弹出的窗口中选择项目，点击ok，如图所示； img 设置web.xml文件目录，按如图所示的步骤选择，如图所示： img 选择Web Resource 目录，按如图所示的步骤选择，如图： img 选择Artifacts,点击+，选择Frome Madules….，在弹出的窗口中选择ok，点击Apply。如图所示： img 添加java文件目录，因为maven模板创建的web项目中少java文件目录，所以要自己创建，回到Module-&gt;选择项目名-&gt;Sources-&gt;main右击-&gt;New Folder…,在弹出的文件夹中填写java点击ok如图所示： img 将刚才新建的普通java文件夹变为Sources文件夹，点击Apply，再点击ok。如图所示步骤： img 当集成项目，项目中引入jar包时，启动项目如果报下面的错误，表明找不到jar包，我们要手动建立lib来放jar包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535403-Dec-2016 09:37:44.044 SEVERE [RMI TCP Connection(2)-127.0.0.1] org.apache.catalina.core.StandardContext.listenerStart Error configuring application listener of class org.springframework.web.context.ContextLoaderListener java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1285) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1119) at org.apache.catalina.core.DefaultInstanceManager.loadClass(DefaultInstanceManager.java:520) at org.apache.catalina.core.DefaultInstanceManager.loadClassMaybePrivileged(DefaultInstanceManager.java:501) at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:118) at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4649) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5189) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:724) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:700) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734) at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1702) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1468) at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76) at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1309) at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1401) at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:829) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:324) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:683) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)03-Dec-2016 09:37:44.045 SEVERE [RMI TCP Connection(2)-127.0.0.1] org.apache.catalina.core.StandardContext.listenerStart Skipped installing application listeners due to previous error(s) 手动新建lib： 在WEB-INF下面新建一个lib目录，如图； img 根据如图所示的步骤找到刚才所建立的lib目录，如图： img 找到lib后在弹出的框中选择Jar Directory点击ok，如图 img 进入Artifacts,选中右边项目中的jar包，右击选择Put /WEB-INF/lib,ok,如图 img 打开“Edit Configurations”，如图所示： img 按照如图所示步骤进行选择，如图： img 选择Deployment-&gt;+-&gt;Artifact….,点击应用，如图所示： img 进行热部署,选择server-&gt;On frame deactiveation中选择-&gt;Update classes and resources,点击应用，点击ok。如图： img 点击启动程序，如图所示，web项目搭建成功： img 最终的目录结构如图所示:","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/MAVEN/setting.xml配置文件","date":"2017-10-29T08:47:53.000Z","updated":"2017-10-29T08:51:51.000Z","comments":true,"path":"2017/10/29/Java/JavaEE/MAVEN/setting.xml配置文件/","link":"","permalink":"http://io.stelawliet.top/2017/10/29/Java/JavaEE/MAVEN/setting.xml配置文件/","excerpt":"","text":"setting.xml配置文件maven的配置文件settings.xml存在于两个地方： 1.安装的地方：${M2_HOME}/conf/settings.xml 2.用户的目录：${user.home}/.m2/settings.xml 前者又被叫做全局配置，对操作系统的所有使用者生效；后者被称为用户配置，只对当前操作系统的使用者生效。如果两者都存在，它们的内容将被合并，并且用户范围的settings.xml会覆盖全局的settings.xml。 Maven安装后，用户目录下不会自动生成settings.xml，只有全局配置文件。如果需要创建用户范围的settings.xml，可以将安装路径下的settings复制到目录${user.home}/.m2/。Maven默认的settings.xml是一个包含了注释和例子的模板，可以快速的修改它来达到你的要求。 全局配置一旦更改，所有的用户都会受到影响，而且如果maven进行升级，所有的配置都会被清除，所以要提前复制和备份${M2_HOME}/conf/settings.xml文件，一般情况下不推荐配置全局的settings.xml。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;settings xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!--本地仓库。该值表示构建系统本地仓库的路径。其默认值为$&#123;user.home&#125;/.m2/repository。 --&gt; &lt;localRepository&gt;usr/local/maven&lt;/localRepository&gt; &lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。 --&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。 --&gt; &lt;!--如果设置为true，则在&#123;user.home&#125;/.m2下需要有一个plugin-registry.xml来对plugin的版本进行管理 --&gt; &lt;!--默认为false。 --&gt; &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; &lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。 --&gt; &lt;!--当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。 --&gt; &lt;!--该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。 --&gt; &lt;!--当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。 --&gt; &lt;!--默认情况下该列表包含了org.apache.maven.plugins。 --&gt; &lt;pluginGroups&gt; &lt;!--plugin的组织Id（groupId） --&gt; &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;!--用来配置不同的代理，多代理profiles可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --&gt; &lt;proxies&gt; &lt;!--代理元素包含配置代理时需要的信息 --&gt; &lt;proxy&gt; &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt; &lt;id&gt;myproxy&lt;/id&gt; &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt; &lt;active&gt;true&lt;/active&gt; &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;protocol&gt;http://…&lt;/protocol&gt; &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;host&gt;proxy.somewhere.com&lt;/host&gt; &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;password&gt;somepassword&lt;/password&gt; &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt; &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; &lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt; &lt;servers&gt; &lt;!--服务器元素包含配置服务器时需要的信息 --&gt; &lt;server&gt; &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt; &lt;id&gt;server001&lt;/id&gt; &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;username&gt;my_login&lt;/username&gt; &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;password&gt;my_password&lt;/password&gt; &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密钥 --&gt; &lt;!--将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;!--鉴权时使用的私钥密码。 --&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。--&gt; &lt;!--这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;!--目录被创建时的权限。 --&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;!--传输层额外的配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!--为仓库列表配置的下载镜像列表。 --&gt; &lt;mirrors&gt; &lt;!--给定仓库的下载镜像。 --&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;planetmirror.com&lt;/id&gt; &lt;!--镜像名称 --&gt; &lt;name&gt;PlanetMirror Australia&lt;/name&gt; &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt; &lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，--&gt; &lt;!--就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。--&gt; &lt;!--它包含了id，activation, repositories, pluginRepositories和 properties元素。--&gt; &lt;!--这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。--&gt; &lt;!--如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt; &lt;profiles&gt; &lt;!--根据环境参数来调整的构件的配置 --&gt; &lt;profile&gt; &lt;!--该配置的唯一标识符。 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt; &lt;!--如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。--&gt; &lt;!--activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。--&gt; &lt;!--profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。--&gt; &lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。--&gt; &lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记$&#123;X&#125;来使用，这里X是指属性的名称。--&gt; &lt;!--属性有五种不同的形式，并且都能在settings.xml文件中访问。 --&gt; &lt;!--1. env.X: 在一个变量前加上\"env.\"的前缀，会返回一个shell环境变量。例如,\"env.PATH\"指代了$path环境变量（在Windows上是%PATH%）。 --&gt; &lt;!--2. project.x：指代了POM中对应的元素值。 --&gt; &lt;!--3. settings.x: 指代了settings.xml中对应元素的值。 --&gt; &lt;!--4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， --&gt; &lt;!-- 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 --&gt; &lt;!--5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。 --&gt; &lt;properties&gt; &lt;!-- 如果这个profile被激活，那么属性$&#123;user.install&#125;就可以被访问了 --&gt; &lt;user.install&gt;usr/local/winner/jobs/maven-guide&lt;/user.install&gt; &lt;/properties&gt; &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识 --&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：--&gt; &lt;!--always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做:--&gt; &lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。--&gt; &lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。--&gt; &lt;!--Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。--&gt; &lt;!--Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。--&gt; &lt;!--每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。--&gt; &lt;!--任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。--&gt; &lt;!--如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。--&gt; &lt;!--如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;env-test&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;/settings&gt; 上面的配置文件对各个节点的含义及作用都有注解。实际应用中，经常使用的是\\、\\、\\、\\有限几个节点，其他节点使用默认值足够应对大部分的应用场景。 \\节点在仓库的配置一节中，已经对setting.xml中的常用节点做了详细的说明。在这里需要特别介绍一下的是节点的配置，profile是maven的一个重要特性。 \\节点包含了激活(activation)，仓库(repositories)，插件仓库(pluginRepositories)和属性(properties)共四个子元素元素。profile元素仅包含这四个元素是因为他们涉及到整个的构建系统，而不是个别的项目级别的POM配置。 profile可以让maven能够自动适应外部的环境变化，比如同一个项目，在Linux下编译linux的版本，在win下编译win的版本等。一个项目可以设置多个profile，也可以在同一时间设置多个profile被激活（active）的。自动激活的 profile的条件可以是各种各样的设定条件，组合放置在activation节点中，也可以通过命令行直接指定。如果认为profile设置比较复杂，可以将所有的profiles内容移动到专门的 profiles.xml 文件中，不过记得和pom.xml放在一起。 activation节点是设置该profile在什么条件下会被激活，常见的条件有如下几个： os 判断操作系统相关的参数，它包含如下可以自由组合的子节点元素 message - 规则失败之后显示的消息 arch - 匹配cpu结构，常见为x86 family - 匹配操作系统家族，常见的取值为：dos，mac，netware，os/2，unix，windows，win9x，os/400等 name - 匹配操作系统的名字 version - 匹配的操作系统版本号 display - 检测到操作系统之后显示的信息 jdk 检查jdk版本，可以用区间表示。 property 检查属性值，本节点可以包含name和value两个子节点。 file 检查文件相关内容，包含两个子节点：exists和missing，用于分别检查文件存在和不存在两种情况。 如果settings中的profile被激活，那么它的值将覆盖POM或者profiles.xml中的任何相等ID的profiles。 如果想要某个profile默认处于激活状态，可以在\\中将该profile的id放进去。这样，不论环境设置如何，其对应的 profile都会被激活。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/MAVEN/maven pom.xml文件详解","date":"2017-10-29T07:55:30.000Z","updated":"2017-10-29T07:55:30.000Z","comments":true,"path":"2017/10/29/Java/JavaEE/MAVEN/maven pom.xml文件详解/","link":"","permalink":"http://io.stelawliet.top/2017/10/29/Java/JavaEE/MAVEN/maven pom.xml文件详解/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd \"&gt; &lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!-- 被继承的父项目的构件标识符 --&gt; &lt;artifactId /&gt; &lt;!-- 被继承的父项目的全球唯一标识符 --&gt; &lt;groupId /&gt; &lt;!-- 被继承的父项目的版本 --&gt; &lt;version /&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt; 4.0.0 &lt;/modelVersion&gt; &lt;!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt; asia.banseon &lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt; banseon-maven2 &lt;/artifactId&gt; &lt;!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt; jar &lt;/packaging&gt; &lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt; 1.0-SNAPSHOT &lt;/version&gt; &lt;!-- 项目的名称, Maven产生的文档用 --&gt; &lt;name&gt; banseon-maven &lt;/name&gt; &lt;!-- 项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt; http://www.baidu.com/banseon &lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt; A maven project to study maven. &lt;/description&gt; &lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!-- 问题管理系统（例如jira）的名字， --&gt; &lt;system&gt; jira &lt;/system&gt; &lt;!-- 该项目使用的问题管理系统的URL --&gt; &lt;url&gt; http://jira.baidu.com/banseon &lt;/url&gt; &lt;/issueManagement&gt; &lt;!-- 项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!-- 持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!-- 传送通知的途径 --&gt; &lt;type /&gt; &lt;!-- 发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!-- 构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!-- 构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!-- 发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!-- 不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!-- 扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!-- 项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!-- 邮件的名称 --&gt; &lt;name&gt; Demo &lt;/name&gt; &lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt; banseon@126.com &lt;/post&gt; &lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt; banseon@126.com &lt;/subscribe&gt; &lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt; banseon@126.com &lt;/unsubscribe&gt; &lt;!-- 你可以浏览邮件信息的URL --&gt; &lt;archive&gt; http:/hi.baidu.com/banseon/demo/dev/ &lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!-- 项目开发者列表 --&gt; &lt;developers&gt; &lt;!-- 某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!-- SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt; HELLO WORLD &lt;/id&gt; &lt;!-- 项目开发者的全名 --&gt; &lt;name&gt; banseon &lt;/name&gt; &lt;!-- 项目开发者的email --&gt; &lt;email&gt; banseon@126.com &lt;/email&gt; &lt;!-- 项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager &lt;/role&gt; &lt;role&gt; Architect &lt;/role&gt; &lt;/roles&gt; &lt;!-- 项目开发者所属组织 --&gt; &lt;organization&gt; demo &lt;/organization&gt; &lt;!-- 项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt; http://hi.baidu.com/banseon &lt;/organizationUrl&gt; &lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt; -5 &lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!-- 项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt;&lt;email /&gt;&lt;url /&gt;&lt;organization /&gt;&lt;organizationUrl /&gt;&lt;roles /&gt;&lt;timezone /&gt;&lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!-- license用于法律上的名称 --&gt; &lt;name&gt; Apache 2 &lt;/name&gt; &lt;!-- 官方的license正文页面的URL --&gt; &lt;url&gt; http://www.baidu.com/banseon/LICENSE-2.0.txt &lt;/url&gt; &lt;!-- 项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt; repo &lt;/distribution&gt; &lt;!-- 关于license的补充信息 --&gt; &lt;comments&gt; A business-friendly OSS license &lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt; http://svn.baidu.com/banseon &lt;/url&gt; &lt;/scm&gt; &lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!-- 组织的全名 --&gt; &lt;name&gt; demo &lt;/name&gt; &lt;!-- 组织主页的URL --&gt; &lt;url&gt; http://www.baidu.com/banseon &lt;/url&gt; &lt;/organization&gt; &lt;!-- 构建项目需要的信息 --&gt; &lt;build&gt; &lt;!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory /&gt; &lt;!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory /&gt; &lt;!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory /&gt; &lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory /&gt; &lt;!-- 被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory /&gt; &lt;!-- 使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!-- 描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!-- 构建扩展的groupId --&gt; &lt;groupId /&gt; &lt;!-- 构建扩展的artifactId --&gt; &lt;artifactId /&gt; &lt;!-- 构建扩展的版本 --&gt; &lt;version /&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal /&gt; &lt;!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!-- 包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!-- 排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;targetPath /&gt;&lt;filtering /&gt;&lt;directory /&gt;&lt;includes /&gt;&lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!-- 构建产生的所有文件存放的目录 --&gt; &lt;directory /&gt; &lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName /&gt; &lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters /&gt; &lt;!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!-- 使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!-- 插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!-- 插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!-- 被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!-- execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id /&gt; &lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase /&gt; &lt;!-- 配置的执行目标 --&gt; &lt;goals /&gt; &lt;!-- 配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- 项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 使用的插件列表 --&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt;&lt;artifactId /&gt;&lt;version /&gt;&lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt;&lt;phase /&gt;&lt;goals /&gt;&lt;inherited /&gt;&lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt;&lt;inherited /&gt;&lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id /&gt; &lt;!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!-- profile默认是否激活的标志 --&gt; &lt;activeByDefault /&gt; &lt;!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt; &lt;jdk /&gt; &lt;!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!-- 激活profile的操作系统的名字 --&gt; &lt;name&gt; Windows XP &lt;/name&gt; &lt;!-- 激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt; Windows &lt;/family&gt; &lt;!-- 激活profile的操作系统体系结构 --&gt; &lt;arch&gt; x86 &lt;/arch&gt; &lt;!-- 激活profile的操作系统版本 --&gt; &lt;version&gt; 5.1.2600 &lt;/version&gt; &lt;/os&gt; &lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!-- 激活profile的属性的名称 --&gt; &lt;name&gt; mavenVersion &lt;/name&gt; &lt;!-- 激活profile的属性的值 --&gt; &lt;value&gt; 2.0.3 &lt;/value&gt; &lt;/property&gt; &lt;!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!-- 如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt; /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!-- 如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt; /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!-- 构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath /&gt;&lt;filtering /&gt;&lt;directory /&gt;&lt;includes /&gt;&lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt;&lt;filtering /&gt;&lt;directory /&gt;&lt;includes /&gt;&lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory /&gt;&lt;finalName /&gt;&lt;filters /&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt;&lt;artifactId /&gt;&lt;version /&gt;&lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt;&lt;phase /&gt;&lt;goals /&gt;&lt;inherited /&gt;&lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt;&lt;inherited /&gt;&lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt;&lt;artifactId /&gt;&lt;version /&gt;&lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt;&lt;phase /&gt;&lt;goals /&gt;&lt;inherited /&gt;&lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt;&lt;inherited /&gt;&lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled /&gt;&lt;updatePolicy /&gt;&lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt;&lt;updatePolicy /&gt;&lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt;&lt;name /&gt;&lt;url /&gt;&lt;layout /&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt;&lt;updatePolicy /&gt;&lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt;&lt;updatePolicy /&gt;&lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt;&lt;name /&gt;&lt;url /&gt;&lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports /&gt; &lt;!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt; &lt;/reporting&gt; &lt;!-- 参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; &lt;/distributionManagement&gt; &lt;!-- 参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt;&lt;updatePolicy /&gt;&lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt; banseon-repository-proxy &lt;/id&gt; &lt;!-- 远程仓库名称 --&gt; &lt;name&gt; banseon-repository-proxy &lt;/name&gt; &lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; http://192.168.1.169:9999/repository/ &lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt; default &lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 依赖的group ID --&gt; &lt;groupId&gt; org.apache.maven &lt;/groupId&gt; &lt;!-- 依赖的artifact ID --&gt; &lt;artifactId&gt; maven-artifact &lt;/artifactId&gt; &lt;!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt; 3.8.1 &lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt; jar &lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt; test &lt;/scope&gt; &lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt; spring-core &lt;/artifactId&gt; &lt;groupId&gt; org.springframework &lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!-- 所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!-- 使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!-- 报表插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!-- 报表插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!-- 被使用的报表插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!-- 报表插件的配置 --&gt; &lt;configuration /&gt; &lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id /&gt; &lt;!-- 产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!-- 配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!-- 这个集合里使用到哪些报表 --&gt; &lt;reports /&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt; banseon-maven2 &lt;/id&gt; &lt;name&gt; banseon maven2 &lt;/name&gt; &lt;url&gt; file://$&#123;basedir&#125;/target/deploy &lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt; banseon-maven2 &lt;/id&gt; &lt;name&gt; Banseon-maven2 Snapshot Repository &lt;/name&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/usr/local/maven-snapshot &lt;/url&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!-- 部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt; banseon-site &lt;/id&gt; &lt;!-- 部署位置的名称 --&gt; &lt;name&gt; business api website &lt;/name&gt; &lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!-- 构件新的group ID --&gt; &lt;groupId /&gt; &lt;!-- 构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!-- 构件新的版本号 --&gt; &lt;version /&gt; &lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; &lt;!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties /&gt; &lt;/project&gt;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/java学习总论","date":"2017-10-29T04:10:38.000Z","updated":"2017-10-29T04:10:38.000Z","comments":true,"path":"2017/10/29/Java/JavaEE/java学习总论/","link":"","permalink":"http://io.stelawliet.top/2017/10/29/Java/JavaEE/java学习总论/","excerpt":"","text":"java学习总论转载 2011年12月06日 17:20:48 标签： java / documentation / weblogic / ejb / jdk / websphere **713 一、 JDK (Java Development Kit)JDK 是整个Java的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具和Java基础的类库(rt.jar)。不论什么Java应用服务器实质都是内置了某个版本的JDK。因此掌握 JDK是学好Java的第一步。最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了自己的JDK，例如IBM公司开发的JDK，BEA公司的Jrocket，还有GNU组织开发的JDK等等。其中IBM的JDK包含的JVM（Java Virtual Machine）运行效率要比Sun JDK包含的JVM高出许多。而专门运行在x86平台的Jrocket在服务端运行效率也要比Sun JDK好很多。但不管怎么说，我们还是需要先把Sun JDK掌握好。1、 JDK的下载和安装JDK又叫做J2SE （Java2 SDK Standard Edition），可以从Sun的Java网站上下载到，http://java.sun.com/j2se/downloads.html ;，JDK当前最新的版本是J2SDK1.4.2，建议下载该版本的JDK，下载页面在这里：http: //java.sun.com/j2se/1.4.2/download.html。下载好的JDK是一个可执行安装程序，默认安装完毕后会在C:/Program Files/Java/目录下安装一套JRE（供浏览器来使用），在C:/j2sdk1.4.2下安装一套JDK（也包括一套JRE）。然后我们需要在环境变量PATH的最前面增加java的路径C:/j2sdk1.4.2/bin。这样JDK就安装好了。2、 JDK的命令工具JDK的最重要命令行工具：java： 启动JVM执行classjavac： Java编译器jar： Java打包工具javadoc： Java文档生成器这些命令行必须要非常非常熟悉，对于每个参数都要很精通才行。对于这些命令的学习，JDK Documentation上有详细的文档。二、 JDK DocumentationDocumentation 在JDK的下载页面也有下载连接，建议同时下载Documentation。Documentation是最最重要的编程手册，涵盖了整个Java所有方面的内容的描述。可以这样说，学习Java编程，大部分时间都是花在看这个Documentation上面的。我是随身携带的，写Java代码的时候，随时查看，须臾不离手。三、 应用服务器(App Server)App Server是运行Java企业组件的平台，构成了应用软件的主要运行环境。当前主流的App Server是BEA公司的Weblogic Server和IBM公司的Websphere以及免费的Jboss，选择其中一个进行学习就可以了，个人推荐Weblogic，因为它的体系结构更加干净，开发和部署更加方便，是Java企业软件开发人员首选的开发平台。下面简要介绍几种常用的App Server：1、 TomcatTomcat 严格意义上并不是一个真正的App Server，它只是一个可以支持运行Serlvet/JSP的Web容器，不过Tomcat也扩展了一些App Server的功能，如JNDI，数据库连接池，用户事务处理等等。Tomcat被非常广泛的应用在中小规模的Java Web应用中，因此本文做一点下载、安装和配置Tomcat的介绍：Tomcat是Apache组织下Jakarta项目下的一个子项目，它的主网站是：http://jakarta.apache.org/tomcat/ ;，Tomcat最新版本是Tomcat4.1.27，软件下载的连接是：http: //www.apache.org/dist/jakarta/tomcat-4/binaries/ ;。下载Tomcat既可以直接下载zip包，也可以下载exe安装包（个人建议zip更干净些），不管哪种情况，下载完毕安装好以后（zip直接解压缩就可以了）。需要设置两个环境变量：JAVA_HOME=C:/j2sdk1.4.2CATALINA_HOME=D:/tomcat4 (你的Tomcat安装目录)这样就安装好了，启动Tomcat运行CATALINA_HOME/bin/startup.bat，关闭Tomcat运行shutdown.bat脚本。 Tomcat启动以后，默认使用8080端口，因此可以用浏览器访问http://localhost:8080来测试Tomcat是否正常启动。Tomcat提供了两个Web界面的管理工具，URL分别是：http://localhost:8080/admin/index.jsp ;http://localhost:8080/manager/html ;在启用这两个管理工具之前，先需要手工配置一下管理员用户和口令。用一个文本工具打开CATALINA_HOME/conf/tomcat-users.xml这个文件，加入如下几行：这样用户“robbin”就具备了超级管理员权限。重新启动Tomcat以后，你就可以使用该用户来登陆如上的两个管理工具，通过Web方式进行Tomcat的配置和管理了。2、 BEA WeblogicWeblogic 可以到BEA的网站上免费注册之后下载到最新的Weblogic8.1企业版，License可以免费使用1年时间，其实这已经完全足够了。 Weblogic的下载连接：http://commerce.bea.com/index.jsp，Weblogic的在线文档：http: //edocs.bea.com/ ;。3、 IBM WebshpereWebsphere同样可以下载到免费的试用版本，到IBM的developerWorks网站可以看到Websphere试用产品的下载和相关的Websphere的资料， developerWorks中文网站的连接是：http://www-900.ibm.com/developerWorks/cn/wsdd/ ;，Websphere的下载连接：http: //www7b.software.ibm.com/wsdd/downloads/WASsupport.html ;。4、 JbossJboss 是免费开源的App Server，可以免费的从Jboss网站下载：http://www.jboss.org/index.html，然而Jboss的文档是不免费，需要花钱购买，所以为我们学习Jboss设置了一定的障碍。在Jdon上有几篇不错的Jboss配置文档，可以用来参考：http: //www.jdon.com/idea.html ;四、 Java应用的运行环境Java的应用可以简单分为以下几个方面：1、 Java的桌面应用桌面应用一般仅仅需要JRE的支持就足够了。2、 Java Web应用Java的Web应用至少需要安装JDK和一个web容器（例如Tomcat），以及一个多用户数据库，Web应用至少分为三层：Browser层：浏览器显示用户页面Web层：运行Servlet/JSPDB层：后端数据库，向Java程序提供数据访问服务3、 Java企业级应用企业级应用比较复杂，可以扩展到n层，最简单情况会分为4层：Browser层：浏览器显示用户页面Client层：Java客户端图形程序（或者嵌入式设备的程序）直接和Web层或者EJB层交互Web层：运行Servlet/JSPEJB层：运行EJB，完成业务逻辑运算DB层：后端数据库，向Java程序提供数据访问服务4、 Java嵌入式应用Java嵌入式应用是一个方兴未艾的领域，从事嵌入式开发，需要从Sun下载J2ME开发包，J2ME包含了嵌入式设备专用虚拟机KVM，和普通的JDK中包含的JVM有所不同。另外还需要到特定的嵌入式厂商那里下载模拟器。Java Learning Path（二）、书籍篇学习一门新的知识，不可能指望只看一本，或者两本书就能够完全掌握。需要有一个循序渐进的阅读过程。我推荐Oreilly出版的Java系列书籍。在这里我只想补充一点看法，很多人学习Java是从《Thinking in Java》这本书入手的，但是我认为这本书是不适合初学者的。我认为正确的使用这本书的方法应该是作为辅助的读物。《Thinking in Java》并不是在完整的介绍Java的整个体系，而是一种跳跃式的写作方法，是一种类似tips的方法来对Java很多知识点进行了深入的分析和解释。对于初学者来说，最好是找一本Java入门的书籍，但是比较完整的循序的介绍Java的语法，面向对象的特性，核心类库等等，在看这本书的同时，可以同步来看《Thinking in Java》，来加深对Java的理解和原理的运用，同时又可以完整的了解Java的整个体系。对于Java的入门书籍，蔡学镛推荐的是Oreilly的《Exploring Java, 2nd Edition》 或者《Java in a Nutshell,2nd Edition（针对C++背景）》，我并没有看过这两本书。其实我觉得电子工业出版社的《Java 2编程详解》或者《Java 2从入门到精通》就很不错。在所有的Java书籍当中，其实最最有用的，并不是O′reilly的 Java Serials，真正最最有用处是JDK的Documentation！几乎你想获得的所有的知识在Documentation里面全部都有，其中最主要的部分当然是Java基础类库的API文档，是按照package来组织的，对于每一个class都有详细的解释，它的继承关系，是否实现了某个接口，通常用在哪些场合，还可以查到它所有的public的属性和方法，每个属性的解释，意义，每个方法的用途，调用的参数，参数的意义，返回值的类型，以及方法可能抛出的异常等等。可以这样来说，所有关于Java编程方面的书籍其实都不过是在用比较通俗易懂的语言，和良好的组织方式来介绍 Documentation里面的某个package里面包含的一些类的用法而已。所以万变不离其宗，如果你有足够的能力来直接通过 Documentation来学习Java的类库，那么基本上就不需要看其他的书籍了。除此之外，Documentation也是编程必备的手册，我的桌面上有三个Documentation的快捷方式，分别是J2SDK1.4.1的Documentation，Servlet2.3的 Documentation和J2SDKEE1.3.1的Documentation。有了这个三个Documentation，什么其他的书籍都不需要了。对于Java Web 编程来说，最核心的是要熟悉和掌握HTTP协议，这个就和Java无关了，在熟悉HTTP协议之后，就需要熟悉Java的实现HTTP协议的类库，也就是 Servlet API，所以最重要的东西就是Servlet API。当然对于初学者而言，直接通过Servlet API来学习Web编程有很大的难度，我推荐O′reilly的《Java Server Pages 》这本书来学习Web 编程。EJB 的书籍当中，《Enterprise JavaBeans, 2nd Edition》是一本很不错的书， EJB的学习门槛是比较高，入门很难，但是这本书完全降低了学习的难度，特别重要的一点是，EJB的学习需要结合一种App Server的具体实现，所以在学习EJB的同时，必须同步的学习某种App Server，而这本书相关的出了三本书，分别是Weblogic6.1，Websphere4.0和JBoss3.0上面部署书中例子的实做。真是既有理论，又有实践。在学习EJB的同时，可以边看边做，EJB的学习会变得很轻松。但是这本书也有一个问题，就是版本比较旧，主要讲 EJB1.1规范和部分EJB2.0的规范。而Ed Roman写的《Mastering EJB 2.0》这本书完全是根据EJB2.0规范写的，深入浅出，覆盖了EJB编程的各个方面，并且还有很多编程经验tips，也是学习EJB非常推荐的书籍之一。如果是结合Weblogic来学习J2EE的话，《J2EE应用与BEA Weblogic Server》绝对是首选读物，虽然是讲述的Weblogic6.0，仍然值得购买，这本书是BEA官方推荐的教材，作者也是BEA公司的工程师。现在中文版已经随处可见了。这本书结合Weblogic介绍了J2EE各个方面的技术在Weblogic平台上的开发和部署，实践指导意义非常强。在掌握了Java平台基础知识和J2EE方面的知识以后，更进一步的是学习如何运用OO的方法进行软件的设计，那么就一定要学习“设计模式”。Sun公司出版了一本《J2EE核心模式》，是每个开发Java企业平台软件的架构师必备的书籍。这本书全面的介绍了J2EE体系架构的各种设计模式，是设计师的必读书籍。Java Learning Path（三）过程篇每个人的学习方法是不同的，一个人的方法不见得适合另一个人，我只能是谈自己的学习方法。因为我学习Java是完全自学的，从来没有问过别人，所以学习的过程基本上完全是自己摸索出来的。我也不知道这种方法是否是比较好的方法，只能给大家提供一点参考了。学习Java的第一步是安装好JDK，写一个Hello World，? 其实JDK的学习没有那么简单，关于JDK有两个问题是很容易一直困扰Java程序员的地方：一个是CLASSPATH的问题，其实从原理上来说，是要搞清楚JRE的ClassLoader是如何加载Class的；另一个问题是package和import问题，如何来寻找类的路径问题。把这两个问题摸索清楚了，就扫除了学习Java和使用JDK的最大障碍。推荐看一下王森的《Java深度历险》，对这两个问题进行了深入的探讨。第二步是学习Java的语法。Java的语法是类C++的，基本上主流的编程语言不是类C，就是类C++的，没有什么新东西，所以语法的学习，大概就是半天的时间足够了。唯一需要注意的是有几个不容易搞清楚的关键字的用法，public，protected，private，static，什么时候用，为什么要用，怎么用，这可能需要有人来指点一下，我当初是完全自己琢磨出来的，花了很久的时间。不过后来我看到《Thinking in Java》这本书上面是讲了这些概念的。第三步是学习Java的面向对象的编程语言的特性的地方。比如继承，构造器，抽象类，接口，方法的多态，重载，覆盖，Java的异常处理机制。对于一个没有面向对象语言背景的人来说，我觉得这个过程需要花很长很长时间，因为学习Java之前没有 C++的经验，只有C的经验，我是大概花了一个月左右吧，才彻底把这些概念都搞清楚，把书上面的例子反复的揣摩，修改，尝试，把那几章内容反复的看过来，看过去，看了不下5遍，才彻底领悟了。不过我想如果有C++经验的话，应该一两天时间足够了。那么在这个过程中，可以多看看《Thinking in Java》这本书，对面向对象的讲解非常透彻。可惜的是我学习的时候，并没有看到这本书，所以自己花了大量的时间，通过自己的尝试和揣摩来学会的。第四步就是开始熟悉Java的类库。Java的基础类库其实就是JDK安装目录下面jre/lib/rt.jar这个包。学习基础类库就是学习rt.jar。基础类库里面的类非常非常多。据说有3000多个，我没有统计过。但是真正对于我们来说最核心的只有4个，分别是java.lang.;java.io.;java.util.;java.sql.;这四个包的学习，每个包的学习都可以写成一本厚厚的教材，而O′reilly也确实是这样做的。我觉得如果时间比较紧，是不可能通过读四本书来学习。我觉得比较好的学习方法是这样的：首先要通读整个package的框架，了解整个package的class，interface，exception的构成，最好是能够找到介绍整个包框架的文章。这些专门介绍包的书籍的前几章应该就是这些总体的框架内容介绍。对包整体框架的把握并不是要熟悉每个类的用法，记住它有哪些属性，方法。想记也记不住的。而是要知道包有哪些方面的类构成的，这些类的用途是什么，最核心的几个类分别是完成什么功能的。我在给人培训的时候一般是一次课讲一个包，所以不可能详细的介绍每个类的用法，但是我反复强调，我给你们讲这些包的不是要告诉你们类的方法是怎么调用的，也不要求你们记住类的方法调用，而是要你们了解，Java给我们提供了哪些类，每个类是用在什么场合，当我遇到问题的时候，我知道哪个类，或者哪几个类的组合可以解决我的问题，That′all！，当我们具体写程序的时候，只要你知道该用哪个类来完成你的工作就足够了。编码的时候，具体的方法调用，是边写代码，边查Documentation，所有的东西都在Documentation里面，不要求你一定记住，实际你也记不住 3000多个类的总共将近10万个方法调用。所以对每个包的总体框架的把握就变得极为重要。第五步，通过上面的学习，如果学的比较扎实的话，就打好了Java的基础了，剩下要做的工作是扫清Documentation里面除了上面4个包之外的其他一些比较有用处的类。相信进展到这一步，Java的自学能力已经被培养出来了，可以到了直接学习Documentation的水平了。除了要做GUI编程之外，JDK里面其他会有用处的包是这些：java.text.;java.net.;javax.naming.;这些包里面真正用的比较多的类其实很少，只有几个，所以不需要花很多时间。第六步，Java Web 编程Web 编程的核心是HTTP协议，HTTP协议和Java无关，如果不熟悉HTTP协议的话，虽然也可以学好Servlet/JSP编程，但是达不到举一反三，一通百通的境界。所以HTTP协议的学习是必备的。如果熟悉了HTTP协议的话，又有了Java编程的良好的基础，学习Servlet/JSP简直易如反掌，我学习Servlet/JSP就用了不到一周的时间，然后就开始用JSP来做项目了。在Servlet/JSP的学习中，重头仍然是Servlet Documentation。Servlet API最常用的类很少，花比较少的时间就可以掌握了。把这些类都看一遍，多写几个例子试试。Servlet/JSP编程本质就是在反复调用这些类来通过 HTTP协议在Web Server和Brower之间交谈。另外对JSP，还需要熟悉几个常用JSP的标记，具体的写法记不住的话，临时查就是了。此外Java Web编程学习的重点要放在Web Application的设计模式上，如何进行业务逻辑的分析，并且进行合理的设计，按照MVC设计模式的要求，运用Servlet和JSP分别完成不同的逻辑层，掌握如何在Servlet和JSP之间进行流程的控制和数据的共享，以及Web Application应该如何配置和部署。第七步，J2EE编程以上的学习过程如果是比较顺利的话，进行到这一步，难度又陡然提高。因为上面的知识内容都是只涉及一个方面，而像EJB，JMS，JTA等核心的J2EE规范往往是几种Java技术的综合运用的结晶，所以掌握起来难度比较大。首先一定要学习好JNDI，JNDI是App Server定位服务器资源（EJB组件，Datasouce，JMS）查找方法，如果对JNDI不熟悉的话，EJB，JMS这些东西几乎学不下去。 JNDI其实就是javax.naming.这个包，运用起来很简单。难点在于服务器资源文件的配置。对于服务器资源文件的配置，就需要看看专门的文档规范了，比如web.xml的写法，ejb-jar.xml的写法等等。针对每种不同的App Server，还有自己的服务资源配置文件，也是需要熟悉的。然后可以学习JTA，主要是要理解JTA对于事务的控制的方法，以及该在什么场合使用JTA。这里可以简单的举个例子，我们知道一般情况可以对于一个数据库连接进行事务控制(conn.setAutoCommit (false),….,conn.commit())，做为一个原子操作，但是假设我的业务需求是要把对两个不同数据库的操作做为一个原子操作，你能做的到吗？这时候只能用JTA了。假设操作过程是先往A数据库插一条记录，然后删除B数据库另一个记录，我们自己写代码是控制不了把整个操作做为一个原子操作的。用JTA的话，由App Server来完成控制。在学习EJB之前要学习对象序列化和RMI，RMI是EJB的基础。接着学习JMS和EJB，对于EJB来说，最关键是要理解EJB是如何通过RMI来实现对远端对象的调用的，以及在什么情况下要用到EJB。在学习完EJB，JMS这些东西之后，你可能会意识到要急不可待学习两个领域的知识，一个是UML，另一个是Design Pattern。Java企业软件的设计非常重视框架(Framework)的设计，一个好的软件框架是软件开发成功的必要条件。在这个时候，应该开始把学习的重点放在设计模式和框架的学习上，通过学习和实际的编程经验来掌握EJB的设计模式和J2EE的核心模式。J2EE规范里面，除了EJB，JMS，JTA，Servlet/JSP，JDBC之外还有很多很多的企业技术，这里不一一进行介绍了。另外还有一个最新领域Web Services。Web Services也完全没有任何新东西，它像是一种黏合剂，可以把不同的服务统一起来提供一个统一的调用接口，作为使用者来说，我只要获得服务提供者给我的WSDL（对服务的描述），就够了，我完全不知道服务器提供者提供的服务究竟是EJB组件，还是.Net组件，还是什么CORBA组件，还是其他的什么实现，我也不需要知道。Web Services最伟大的地方就在于通过统一的服务提供方式和调用方式，实现了整个Internet服务的共享，是一个非常令人激动的技术领域。Web Services好像目前还没有什么很好的书籍，但是可以通过在网络上面查资料的方式来学习。Java Learning Path（四） 方法篇Java 作为一门编程语言，最好的学习方法就是写代码。当你学习一个类以后，你就可以自己写个简单的例子程序来运行一下，看看有什么结果，然后再多调用几个类的方法，看看运行结果，这样非常直观的把类给学会了，而且记忆非常深刻。然后不应该满足把代码调通，你应该想想看如果我不这样写，换个方式，再试试行不行。记得哪个高人说过学习编程就是个破坏的过程，把书上的例子，自己学习Documentation编写的例子在运行通过以后，不断的尝试着用不同的方法实现，不断的尝试破坏代码的结构，看看它会有什么结果。通过这样的方式，你会很彻底的很精通的掌握Java。举个例子，我们都编过Hello Worldpublic class HelloWorld {public static void main(String[] args) {System.out.println(“Hello World”);}}很多初学者不是很理解为什么main方法一定要这样来定义public static void main(String[] args)，能不能不这样写？包括我刚学习Java的时候也有这样的疑问。想知道答案吗？很简单，你把main改个名字运行一下，看看报什么错误，然后根据出错信息进行分析；把main的public取掉，在试试看，报什么错误；static去掉还能不能运行；不知道main方法是否一定要传一个 String[]数组的，把String[]改掉，改成int[]，或者String试试看；不知道是否必须写args参数名称的，也可以把args改成别的名字，看看运行结果如何。我当初学习Java的时候就是这样做的，把Hello World程序反复改了七八次，不断运行，分析运行结果，最后就彻底明白为什么了main方法是这样定义的了。此外，我对于staic，public，private，Exception，try{ }catch {}finally{}等等等等一开始都不是很懂，都是把参考书上面的例子运行成功，然后就开始破坏它，不断的根据自己心里面的疑问来重新改写程序，看看能不能运行，运行出来是个什么样子，是否可以得到预期的结果。这样虽然比较费时间，不过一个例子程序这样反复破坏几次之后。我就对这个相关的知识彻底学通了。有时候甚至故意写一些错误的代码来运行，看看能否得到预期的运行错误。这样对于编程的掌握是及其深刻的。其中特别值得一提的是JDK有一个非常棒的调试功能，-verbosejava ?Cverbosejavac ?Cverbose 以及其它很多JDK工具都有这个选项-verbose 可以显示在命令执行的过程中，JVM都依次加载哪里Class，通过这些宝贵的调试信息，可以帮助我们分析出JVM在执行的过程中都干了些什么。另外，自己在学习过程中，写的很多的这种破坏例程，应该有意识的分门别类的保存下来，在工作中积累的典型例程也应该定期整理，日积月累，自己就有了一个代码库了。遇到类似的问题，到代码库里面 Copy &amp; Paste ，Search &amp; Replace，就好了，极大提高了开发速度。最理想的情况是把一些通用的例程自己再抽象一层，形成一个通用的类库，封装好。那么可复用性就更强了。所以我觉得其实不是特别需要例程的，自己写的破坏例程就是最好的例子，如果你实在对自己写的代码不放心的话，我强烈推荐你看看JDK基础类库的Java源代码。在JDK安装目录下面会有一个src.zip，解开来就可以完整的看到整个JDK基础类库，也就是rt.jar的Java源代码，你可以参考一下 Sun是怎么写Java程序的，规范是什么样子的。我自己在学习Java的类库的时候，当有些地方理解的不是很清楚的时候，或者想更加清晰的理解运作的细节的时候，往往会打开相应的类的源代码，通过看源代码，所有的问题都会一扫而空。Java Learning Path（五）资源篇1、 http://java.sun.com/ ;(英文)Sun的Java网站，是一个应该经常去看的地方。不用多说。2、 http://www-900.ibm.com/developerWorks/cn/ ;IBM的developerWorks网站，英语好的直接去英文主站点看。这里不但是一个极好的面向对象的分析设计网站，也是Web Services，Java，Linux极好的网站。强烈推荐！！！3、 http://www.java-cn.com/ ;(中文)JAVA 中文站，目前国内资料最全、会员最多的JAVA技术网站，人气极高。有《JAVA电子书库》、《JAVA视频库》(国内唯一)、《JAVA技术文摘库》、《JAVA源代码库》、《JAVA工具库》、《招聘求职广场》等主要栏目，还有一些专家栏目。目前会员有5万多，VIP会员近1000人。无论是菜鸟还是老鸟，都能在此网站中找到自己所需要的东东！！ 最强烈推荐！！！！！！4、 http://www.javaworld.com/ ;(英文)关于Java很多新技术的讨论和新闻。想多了解Java的方方面面的应用，这里比较好。5、 http://dev2dev.bea.com.cn/index.jsp ;BEA的开发者园地，BEA作为最重要的App Server厂商，有很多独到的技术，在Weblogic上做开发的朋友不容错过。6、 http://www.huihoo.com/ ;灰狐动力网站，一个专业的中间件网站，虽然不是专业的Java网站，但是在J2EE企业应用技术方面有深厚的造诣。7、 http://www.theserverside.com/home/ ;(英文)TheServerSide是一个著名的专门面向Java Server端应用的网站。8、 http://www.javaresearch.org/ ;Java研究组织，有很多优秀的Java方面的文章和教程，特别是在JDO方面的文章比较丰富。9、 http://www.cnjsp.org/ ;JSP技术网站，有相当多的Java方面的文章和资源。10、 http://www.jdon.com/ ;Jdon论坛，是一个个人性质的中文J2EE专业技术论坛，在众多的Java的中文论坛中，Jdon一个是技术含量非常高，帖子质量非常好的论坛。11、 http://sourceforge.net/ ;SourgeForge是一个开放源代码软件的大本营，其中也有非常非常丰富的Java的开放源代码的著名的软件。","categories":[],"tags":[]},{"title":"","slug":"MD/idea/ JRebel热部署","date":"2017-10-28T11:12:37.000Z","updated":"2017-12-25T16:32:33.000Z","comments":true,"path":"2017/10/28/MD/idea/ JRebel热部署/","link":"","permalink":"http://io.stelawliet.top/2017/10/28/MD/idea/ JRebel热部署/","excerpt":"","text":"Intellij IDEA使用 JRebel 搭配 maven-jetty-plugin插件实现热部署1. 在pom.xml文件中依赖jetty在&lt;build&gt;标签的子标签&lt;plugins&gt;标签下加入以下内容: 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.11.v20160721&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;5&lt;/scanIntervalSeconds&gt; &lt;httpConnector&gt; &lt;port&gt;9999&lt;/port&gt; &lt;/httpConnector&gt; &lt;/configuration&gt;&lt;/plugin&gt; 其中port可以指定端口号,jetty访问默认不需要项目名,直接通过 localhost:9999访问即可 2. 修改idea运行配置Run Configuration 修改idea运行配置Run Configuration 修改idea运行配置Run Configuration 3. 安装JRebel热部署插件 安装JRebel热部署插件 4. 破解JRebel首先下载破解文件 4.1 解压补丁，替换jar包与licence文件将本机 /Users/&lt;你的用户名&gt;/.jrebel/jrebel.lic替换为下载的jrebel.lic 4.2 将补丁解压包里的文件分别覆盖一下文件,注意文件夹的名字哦/Users/&lt;你的用户名&gt;/IdeaIC2016.1/config/plugins/jr-ide-idea/lib/jrebel6/jrebel.jar/Users/&lt;你的用户名&gt;/IdeaIC2016.1/config/plugins/jr-ide-idea/lib/jrebel/jrebel.jar 5. 重启Idea使JRebel生效，并取消勾选汇报使用数据 重启Idea使JRebel生效，并取消勾选汇报使用数据 6. 勾选需要监控的热部署的模块 勾选需要监控的热部署的模块 7. 通过JRebel来Debug运行项目 通过JRebel来Debug运行项目 8. 控制台打印如下输出表示配置成功 控制台打印如下输出表示配置成功 修改文件后按 Ctrl + (Shift) +F9 来Make项目，使得JRebel热部署最新代码","categories":[],"tags":[]},{"title":"","slug":"MD/idea/IDEA单元测试入门","date":"2017-10-28T10:53:38.000Z","updated":"2017-10-28T10:55:21.000Z","comments":true,"path":"2017/10/28/MD/idea/IDEA单元测试入门/","link":"","permalink":"http://io.stelawliet.top/2017/10/28/MD/idea/IDEA单元测试入门/","excerpt":"","text":"IntelliJ IDEA单元测试入门转载 2016年08月09日 20:10:17 **17701 参考文章地址地址：JUnit4单元测试入门教程 ​ IDEA单元测试及代码覆盖率 ​ IDEA添加jar包的三种方式 本文按以下顺序讲解JUnit4的使用 下载jar包 单元测试初体验 自动生成测试类 执行顺序 @Test的属性 代码覆盖率 下载jar包在github上，把以下两个jar包都下载下来。下载地址：点击打开链接 下载junit-4.12.jar，junit-4.12-javadoc.jar（文档），junit-4.12-sources.jar（源码）。 下载hamcrest-core-1.3.jar，hamcrest-core-1.3-javadoc.jar（文档），hamcrest-core-1.3-sources.jar（源码）。 最前面那个pom是Maven的配置文件，如果你需要的话也下载下来。 ## 单元测试初体验先创建个简单的项目体验下单元测试是怎么一回事吧。 我创建一个项目叫JUnit4Demo，刚创建好的工程目录如下图，然后在External Libraries中导入刚下载的那两个jar包。 ​ 通过Libraries添加Jar包 1.打开 File -&gt; Project Structure -&gt;Modules-&gt; 在Dependencies 下添加jar包 ​ 2、+ -&gt; Library… -&gt; java -&gt; 选择jar的路径添加。 添加jar包后如下图所示。 ​ 3、创建一个类com.hera.util.Math，然后输入一个求阶乘的方法： ​ 4、创建一个队Math方法的单元测试： ​ 创建一个和src同级别的文件夹叫test(逻辑代码放src里，测试代码放test里是个好习惯)。​ 接着在IntelliJ IDEA里还要把这个test文件夹要设置成测试文件的根目录，右键选中​ Mark Directory As - Test Sources Root。 ​ ​ 创建一个测试类： ​ IntelliJ IDEA提供了一个快捷操作Cmd + Shift + T作为类和测试之间的导航。同时允许用户在那里创建一个测试类。IntelliJ IDEA提供了一个快捷操作Cmd + Shift + T作为类和测试之间的导航。同时允许用户在那里创建一个测试类。 ​ 为测试类MathTest添加测试方法： ​ ​ ​ 运行： run MathTest 。右下方一条绿色条说明测试通过，如果把120改成别的数字那么就会测试不通过显色红色条。JUnit4有一句话叫：“keeps the bar green to keep the code clean”。 ​ 解释一下MathTest，就六个地方要讲：​ 第一，导入了org.junit.Test;和org.junit.Assert.*;这两个包，注意后者是静态导入import static。​ 第二，testFactorial是在要测试的方法名Factorial前加个test（这也是个好习惯）。​ 第三，所有测试方法返回类型必须为void且无参数。​ 第四，一个测试方法之所以是个测试方法是因为@Test这个注解。​ 第五，assertEquals的作用是判断两个参数是否相等，例子中120是预期结果，new Math().factorial(5)是实 际结果。但是通常不应该只比较一个值，要测试多几个特殊值，特别是临界值。 ​ 例如Math().factorial(0)和Math().factorial(-1)等。​ 第六，assertEquals除了比较两个int，还重载了好多次可以比较很多种类型的参数。而且JUnit4包含一堆 assertXX方法，assertEquals只是其中之一，这些assertXX统称为断言。刚不是下载了junit-4.12- javadoc.jar这个文档吗，解压后打开index.html如下图还有一堆断言。 ​ ​ 执行顺序JUnit4利用JDK5的新特性Annotation，使用注解来定义测试规则。这里讲一下以下几个常用的注解： @Test：把一个方法标记为测试方法 @Before：每一个测试方法执行前自动调用一次 @After：每一个测试方法执行完自动调用一次 @BeforeClass：所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用static修饰 @AfterClass：所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用static修饰 @Ignore：暂不执行该测试方法 我们来试验一下，我新建一个测试类AnnotationTest，然后每个注解都用了，其中有两个用@Test标记的方法分别是test1和test2，还有一个用@Ignore标记的方法test3。然后我还创建了一个构造方法，这个构造方法很重要一会会引出一个问题。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.xuhongchuan.util;import org.junit.*;import static org.junit.Assert.*;/** * Created by xuhongchuan on 2015/7/18. */public class AnnotationTest &#123; public AnnotationTest() &#123; System.out.println(&quot;构造方法&quot;); &#125; @BeforeClass public static void setUpBeforeClass() &#123; System.out.println(&quot;BeforeClass&quot;); &#125; @AfterClass public static void tearDownAfterClass() &#123; System.out.println(&quot;AfterClass&quot;); &#125; @Before public void setUp() &#123; System.out.println(&quot;Before&quot;); &#125; @After public void tearDown() &#123; System.out.println(&quot;After&quot;); &#125; @Test public void test1() &#123; System.out.println(&quot;test1&quot;); &#125; @Test public void test2() &#123; System.out.println(&quot;test2&quot;); &#125; @Ignore public void test3() &#123; System.out.println(&quot;test3&quot;); &#125;&#125; 运行结果如下： 12345678910BeforeClass构造方法Beforetest1After构造方法Beforetest2AfterAfterClass ​ 解释一下：@BeforeClass和@AfterClass在类被实例化前（构造方法执行前）就被调用了，而且只执行一次，通常用来初始化和关闭资源。@Before和@After和在每个@Test执行前后都会被执行一次。@Test标记一个方法为测试方法没什么好说的，被@Ignore标记的测试方法不会被执行，例如这个模块还没完成或者现在想测试别的不想测试这一块。 ​ 以上有一个问题，构造方法居然被执行了两次。所以我这里要说明一下，JUnit4为了保证每个测试方法都是单元测试，是独立的互不影响。所以每个测试方法执行前都会重新实例化测试类。 ​ 我再给你看一个实验： ​ 添加一个成员变量 1int i = 0; 然后把test1改为： 12i++;System.out.println(&quot;test1的i为&quot; + i); test2改为： 12i++;System.out.println(&quot;test2的i为&quot; + i); 执行结果： 12345678910BeforeClass构造方法Beforetest1的i为1After构造方法Beforetest2的i为1AfterAfterClass ​ 可以看到test1和test2的i都只自增了一次，所以test1的执行不会影响test2，因为执行test2时又把测试类重新实例化了一遍。如果你希望test2的执行受test1的影响怎么办呢？把int i改为static的呗。 ​ 最后关于这些注解还有一个要说明的就是，你可以把多个方法标记为@BeforeClass、@AfterClass、@Before、@After。他们都会在相应阶段被执行。 @Test的属性最后来说一下@Test的两个属性 excepted timeoutexcepted属性是用来测试异常的，我们回到Math类，拿其中的求阶乘方法factorial()来说。如果传进来一个负数我们是希望抛出异常的，那要测试会不会抛异常怎么办呢？我在测试类MathTest添加一个测试方法： ​ ​ 这个方法就是(expected = Exception.class)和fail(“factorial参数为负数没有抛出异常”);之间的配合。就是这个测试方法会检查是否抛出Exception异常（当然也可以检测是否抛出其它异常），如果抛出了异常那么测试通过（因为你的预期就是传进负数会抛出异常）。没有抛出异常则测试不通过执行fail(“factorial参数为负数没有抛出异常”); ​ 然后说下timeout属性，这个是用来测试性能的，就是测试一个方法能不能在规定时间内完成。回到Math类，我创建一个数组排序的方法，用的是冒泡排序。 ​ 12345678910111213public void sort(int[] arr) &#123; //冒泡排序 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //控制比较轮数 for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; //控制每轮的两两比较次数 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; ​ 然后偶在测试类MathTest创建测试方法，随机生成一个长度为50000的数组然后测试排序所用时间。timeout的值为2000，单位和毫秒，也就是说超出2秒将视为测试不通过。 123456789101112@Test(timeout = 2000)public void testSort() throws Exception &#123; int[] arr = new int[50000]; //数组长度为50000 int arrLength = arr.length; //随机生成数组元素 Random r = new Random(); for (int i = 0; i &lt; arrLength; i++) &#123; arr[i] = r.nextInt(arrLength); &#125; new Math().sort(arr);&#125; 运行结果测试不通过，且提示TestTimedOutException。 ​ 那怎么办，修改代码提升性能呗。回到Math方法改为下sort()。这次我用快速排序，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void sort(int[] arr) &#123; //快速排序 if (arr.length &lt;= 1) &#123; return; &#125; else &#123; partition(arr, 0, arr.length - 1); &#125;&#125;static void partition(int[] arr, int left, int right) &#123; int i = left; int j = right; int pivotKey = arr[left]; //基准数 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= pivotKey) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= pivotKey) &#123; i++; &#125; if (i &lt; j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; if (i != left) &#123; arr[left] = arr[i]; arr[i] = pivotKey; &#125; if (i - left &gt; 1) &#123; partition(arr, left, i - 1); &#125; if (right - j &gt; 1) &#123; partition(arr, j + 1, right); &#125;&#125; ​ 然后再运行一下测试类MathTest，绿色条出现了，测试通过妥妥的。 编辑测试设置 ​ 我们可以通过Run → Edit Configurations或工具栏上的标签来调整我们的测试运行配置。 ​ ​ 在Configuration选项卡,用户可以选择需要运行的测试。例如,您可以从一个类、程序包、测试套件或甚至模式中运行所有的测试。这里的Fork模式让用户在一个单独的进程运行每个测试。 ​ 在代码覆盖标签你可以调整覆盖率设置。目前IntelliJ IDEA支持两种测量覆盖率引擎。默认情况下它使用自己的引擎，当然用户也可以选择JaCoCo引擎。用户也可以在这里选择覆盖率模式。Tracing{span{ mode模式会增加消耗,但测量会更精确。 ​ 运行覆盖 ​ 收集覆盖率,用户需要通过Run → Run ‘MyClassTest’ with Coverage或工具栏上的选项运行特定模式的测试。 ​ 当覆盖模式运行至少一个测试之后,IDE将会在Project工具窗口显示每个程序包、类的覆盖率数据，同时在Coverage工具窗和编辑器中也会显示。 ​ 编辑器中的覆盖率 如果用户添加另一个方法到MyClass，并运行覆盖率测MyClass,就会发现,没有被测试覆盖到的代码都将高亮显示为红色。覆盖的代码颜色则是绿色。如果一些代码是只覆盖部分,那没将显示为黄色。 Idea配置JUnit4单元测试入门原创 2017年01月07日 13:48:20 标签： junit / idea / 单元测试 **1679 pom.xml文件配置 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;123456 然后创建一个和src同级别的文件夹叫test(逻辑代码放src里，测试代码放test里是个好习惯)。接着在IntelliJ IDEA里还要把这个test文件夹要设置成测试文件的根目录,右键选中 Mark Directory As -&gt; Test Sources Root。然后创建测试类(包名一致，类名在要测试的类名后加上Test也是个好习惯)。 12345678910public class IndexBuilderTest &#123; @Test public void testStart() throws Exception &#123; System.out.println(&quot;---testStrat()----&quot;); IndexBuilder indexBuilder=new IndexBuilder(); indexBuilder.start();// assertEquals(true,false); &#125;&#125;12345678910 然后选中MathTest类ctrl + shift + F10运行一下。 JUnit4利用JDK5的新特性Annotation，使用注解来定义测试规则。这里讲一下以下几个常用的注解： 123456@Test：把一个方法标记为测试方法@Before：每一个测试方法执行前自动调用一次@After：每一个测试方法执行完自动调用一次@BeforeClass：所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用static修饰@AfterClass：所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用static修饰@Ignore：暂不执行该测试方法","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/SSH框架总结","date":"2017-10-28T07:28:34.000Z","updated":"2017-10-29T09:14:39.000Z","comments":true,"path":"2017/10/28/Java/JavaEE/Java框架/spring/SSH框架总结/","link":"","permalink":"http://io.stelawliet.top/2017/10/28/Java/JavaEE/Java框架/spring/SSH框架总结/","excerpt":"","text":"SSH框架总结（框架分析+环境搭建+实例源码下载） 标签： sshSpringStrutsHibernate Java（31） img](http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg) SSM*（4）* ![img 转载自： SSH框架总结（框架分析+环境搭建+实例源码下载） 首先，SSH不是一个框架，而是多个框架（struts+spring+hibernate）的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。 集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层）。 Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持。Spring一方面作为一个轻量级的IoC容器，负责查找、定位、创建和管理对象及对象之间的依赖关系，另一方面能使Struts和Hibernate更好地工作。 由SSH构建系统的基本业务流程是： 1、在表示层中，首先通过JSP页面实现交互界面，负责传送请求(Request)和接收响应(Response)，然后Struts根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。 2、在业务层中，管理服务组件的Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。 3、在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果。 采用上述开发模型，不仅实现了视图、控制器与模型的彻底分离，而且还实现了业务逻辑层与持久层的分离。这样无论前端如何变化，模型层只需很少的改动，并且数据库的变化也不会对前端有所影响，大大提高了系统的可复用性。而且由于不同层之间耦合度小，有利于团队成员并行工作，大大提高了开发效率。 下面我们再详细看一下组成SSH的这三个框架 一、Spring 1、什么是Spring？ 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 2、Spring的特性 img 具体自己百度吧 所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码 3、为什么使用Spring？ Spring的以上特性使得开发人员使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 二、Struts 1、什么是Struts？ 它通过采用 Java Servlet/JSP 技术，实现了基于Java EEWeb应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。 2、Struts1的核心构成 img 在 Struts1 中，由一个名为 ActionServlet 的 Servlet 充当 控制器(Controller)的角色，根据描述模型、视图、控制器对应关系的 struts-config.xml 的配置文件，转发视图(View)的请求，组装响应数据模型（Model）。 在 MVC 的模型（Model）部分，经常划分为两个主要子系统（系统的内部数据状态与改变数据状态的逻辑动作），这两个概念子系统分别具体对应 Struts 1里的 ActionForm 与 Action 两个需要继承实现超类。在这里，Struts 1可以与各种标准的数据访问技术结合在一起，包括Enterprise Java Beans（EJB）, JDBC 与 JNDI。 在 Struts 1的视图（View） 端，除了使用标准的JavaServer Pages（JSP）以外，还提供了大量的标签库使用，同时也可以与其他表现层组件技术（产品）进行整合，比如 Velocity Templates，XSLT 等。 通过应用 Struts 的框架，最终用户可以把大部分的关注点放在自己的业务逻辑（Action）与 映射关系的配置文件（struts-config.xml）中。 3、Struts1的基本执行流程 详见《STRUTS基本工作流程》 4、什么是struts2 Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品 5、strut2的体系结构 解析： 当Web容器收到请求（HttpServletRequest）它将请求传递给一个标准的的过滤链包括 流程（ActionContextCleanUp）过滤器，然后经过Other filters(SiteMesh ,etc), 接下来需要调用FilterDispatcher核心控制器，然后它调用ActionMapper确定请求那个Action，ActionMapper返回一个收集Action详细信息的ActionMaping对象。 接下来FilterDispatcher将控制权委派给ActionProxy,ActionProxy调用配置管理器(ConfigurationManager) 从配置文件中读取配置信息(struts.xml)，然后创建ActionInvocation对象，ActionInvocation在调用Action之前会依次的调用所用配置拦截器（Interceptor N） 一旦执行结果返回结果字符串ActionInvocation负责查找结果字符串对应的(Result）然后执行这个Result Result会调用一些模版（JSP） 来呈现页面，之后拦截器(Interceptor N)会在被执行(顺序和Action执行之前相反)最后响应(HttpServletResponse)被返回在web.xml中配置的那些过滤器和（核心控制器）（FilterDispatcher）。 6、为什么使用Struts？ 首先，Struts 是MVC的一种实现，它将 Servlet和 JSP 标记（属于 J2EE 规范）用作实现的一部分。Struts继承了MVC的各项特性，并根据J2EE的特点，做了相应的变化与扩展，减弱了业务逻辑接口和数据接口之间的耦合，以及让视图层更富于变化 另外， struts具有页面导航功能，使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。 7、 Struts1和Struts2的区别 详见《Struts1 和 Struts2》 三、Hibernate 1、什么是Hibernate？ Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任 2、Hibernate核心构成 具体就不展开了 3、Hibernate基本执行流程 img 为什么使用Hibernate？ \\1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 2、Hibernate是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作，将软件开发人员从大量相同的数据持久层相关编程工作中解放出来，使开发更对象化了。 3、移植性好，支持各种数据库，如果换个数据库只要在配置文件中变换配置就可以了，不用改变hibernate代码。 4、支持透明持久化，因为hibernate操作的是纯粹的（pojo）java类，没有实现任何接口，没有侵入性。所以说它是一个轻量级框架。 最后附上SSH1和SSH2框架搭建的实例，点击即可下载 SSH1框架搭建实例（spring2+struts1+hibernate3）采用旧版本，详见代码中注释 SSH2框架搭建实例（spring3.2+strust2.3.4+hibernate4.2）全部采用最新版本，详见代码中注释 开发环境搭建，参照我的另一篇博客 《Win7(64) + eclipse（64）+ tomcat7（64）+ jdk7（64）开发环境配置》 [html] view plain copy 一些说明： 索要代码的邮箱，我基本上都发过了，如果有漏发，请联系我。 还是希望大家去csdn下载页去下载。如果速度慢，可以去这里http://pan.baidu.com/s/1eQh7FXo 开发环境配置。http://blog.csdn.net/shan9liang/article/details/8807784 ​ 在war中，找到application-common.xml。修改数据源，指定自己的数据库即可。项目部署后，会自动映射表。 ​ ​ &lt;bean id=”dataSource” class=”org.apache.commons.dbcp.BasicDataSource” destroy-method=”close”&gt; ​ 以上是oracle的配置。 如果使用其他数据库，请在lib目录下，加入驱动包。并修改数据源。 强烈建议： https://code.csdn.net/shan9liang/tgb 这是在CSDN CODE托管的，采用ssh搭建的一个考勤管理系统，maven项目，比原来那个更规范了，建议用这个，而且我会持续更新，逐渐加入各种主流框架，相信我。 。不过不是eclipse项目，需要手工导入eclipse，最近特喜欢用intellij。建议直接用git clone。","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/Java框架/spring/SSM框架详细整合教程 ","date":"2017-10-28T07:26:25.000Z","updated":"2017-10-28T07:26:25.000Z","comments":true,"path":"2017/10/28/Java/JavaEE/Java框架/spring/SSM框架详细整合教程 /","link":"","permalink":"http://io.stelawliet.top/2017/10/28/Java/JavaEE/Java框架/spring/SSM框架详细整合教程 /","excerpt":"","text":"SSM框架详细整合教程 标签： SSM 2017-06-08 20:40 344人阅读 评论(0) 收藏;) 举报 img 分类：SSM（4） img 目录(?)[+] 转载自：SSM框架详细整合教程1、基本概念1.1、Spring​ Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 1.2、SpringMVC​ Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 1.3、MyBatis​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 2、开发环境搭建以及创建Maven Web项目参看之前的博文：http://www.cnblogs.com/zyw-205520/p/4767633.html 3、SSM整合 下面主要介绍三大框架的整合，至于环境的搭建以及项目的创建，参看上面的博文。这次整合我分了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，此外有2个资源文件：jdbc.propertis和log4j.properties。完整目录结构如下（最后附上源码下载地址）： ​ 使用框架的版本： ​ Spring 4.0.2 RELEASE ​ Spring MVC 4.0.2 RELEASE ​ MyBatis 3.2.6 3.1、Maven引入需要的JAR包​ 在pom.xml中引入jar包 [ 复制代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.javen.maven01&lt;/groupId&gt; &lt;artifactId&gt;maven01&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;maven01 Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;maven01&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;80&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; [ 复制代码 3.2、整合SpringMVC3.2.1、配置spring-mvc.xml配置里面的注释也很详细，主要是自动扫描控制器，视图模式，注解的启动这三个。 [ 复制代码 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.javen.controller&quot; /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;!--经本人(兵工厂三剑客)测试，这里貌似应该写成location=&quot;/resources/&quot; mapping=&quot;/resources/**&quot; 1不然会提示No mapping found for HTTP request with URI 1--&gt; 1&lt;!--本人也是新手，至于是不是该这样修改，暂时不明白原理，但是本人照着写的代码，确实出现了这个问题，修改过后就可以了--&gt; 1&lt;mvc:resources location=&quot;/resources/**&quot; mapping=&quot;/resources&quot;/&gt; 12 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mediaTypes&quot;&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt; &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt; &lt;entry key=&quot;htm&quot; value=&quot;text/htm&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;defaultViews&quot;&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJacksonJsonView&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; [ 复制代码 3.2.2、配置web.xml文件 配置的spring-mvc的Servlet就是为了完成SpringMVC+MAVEN的整合。 web.xml [ 复制代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;!-- &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; --&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; --&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; --&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; [ 复制代码 3.2.3、Log4j的配置 为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 ​ Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，参看我转载的一篇博文，很详细：http://blog.csdn.net/zhshulin/article/details/37937365 下面给出配置文件目录： log4j.properties [ 复制代码 123456789101112131415161718log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log #定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB # 输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125;][%c]%m%n [ 复制代码 3.2.4、使用Jetty测试 img [ 复制代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.javen.model;public class User &#123; private Integer id; private String userName; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, userName=&quot; + userName + &quot;, password=&quot; + password + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125; [ 复制代码 [ 复制代码 1234567891011121314151617181920212223242526272829303132333435363738package com.javen.controller;import javax.servlet.http.HttpServletRequest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod;import com.javen.model.User; @Controller @RequestMapping(&quot;/user&quot;) // /user/**public class UserController &#123; private static Logger log=LoggerFactory.getLogger(UserController.class); // /user/test?id=1 @RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter(&quot;id&quot;)); System.out.println(&quot;userId:&quot;+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword(&quot;123&quot;); user.setUserName(&quot;javen&quot;); &#125; log.debug(user.toString()); model.addAttribute(&quot;user&quot;, user); return &quot;index&quot;; &#125; &#125; [ 复制代码 ​ 在浏览器中输入：http://localhost/user/test?id=1 img 到此 SpringMVC+Maven 整合完毕 3.3 Spring与MyBatis的整合 取消3.2.2 web.xml中注释的代码 3.3.1、建立JDBC属性文件jdbc.properties（文件编码修改为utf-8） [ 复制代码 1234567891011121314driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mavenusername=rootpassword=root#定义初始连接数 initialSize=0 #定义最大连接数 maxActive=20 #定义最大空闲 maxIdle=20 #定义最小空闲 minIdle=1 #定义最长等待时间 maxWait=60000 [ 复制代码 此时的目录结构为 3.3.2、建立spring-mybatis.xml配置文件​ 这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。 spring-mybatis.xml [ 复制代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.javen&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/javen/mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.javen.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; [ 复制代码 3.4、JUnit测试 经过以上步骤，我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。 3.4.1、创建测试用表既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为： [ 复制代码 1234567891011121314151617-- ------------------------------ Table structure for `user_t`-- ----------------------------DROP TABLE IF EXISTS `user_t`;CREATE TABLE `user_t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(40) NOT NULL, `password` varchar(255) NOT NULL, `age` int(4) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_t-- ----------------------------INSERT INTO `user_t` VALUES (&apos;1&apos;, &apos;测试&apos;, &apos;345&apos;, &apos;24&apos;);INSERT INTO `user_t` VALUES (&apos;2&apos;, &apos;javen&apos;, &apos;123&apos;, &apos;10&apos;); [ 复制代码 3.4.2、利用MyBatis Generator自动创建代码参考博文：http://blog.csdn.net/zhshulin/article/details/23912615 这个可根据表自动创建实体类、MyBatis映射文件以及DAO接口，当然，我习惯将生成的接口名改为IUserDao，而不是直接用它生成的UserMapper。如果不想麻烦就可以不改。完成后将文件复制到工程中。如图： ​ 3.4.3、建立Service接口和实现类​ 下面给出具体的内容： IUserService.jave [ 复制代码 12345678package com.javen.service; import com.javen.model.User; public interface IUserService &#123; public User getUserById(int userId); &#125; [ 复制代码 UserServiceImpl.java [ 复制代码 1234567891011121314151617181920package com.javen.service.impl;import javax.annotation.Resource; import org.springframework.stereotype.Service; import com.javen.dao.IUserDao;import com.javen.model.User;import com.javen.service.IUserService; @Service(&quot;userService&quot;) public class UserServiceImpl implements IUserService &#123; @Resource private IUserDao userDao; public User getUserById(int userId) &#123; // TODO Auto-generated method stub return this.userDao.selectByPrimaryKey(userId); &#125; &#125; [ 复制代码 3.4.4、建立测试类 测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。 ​ 如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。 [ 复制代码 123456789101112131415161718192021222324252627282930313233343536package com.javen.testmybatis;import javax.annotation.Resource; import org.apache.log4j.Logger; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.alibaba.fastjson.JSON; import com.javen.model.User;import com.javen.service.IUserService; @RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;&quot;classpath:spring-mybatis.xml&quot;&#125;) public class TestMyBatis &#123; private static Logger logger = Logger.getLogger(TestMyBatis.class); // private ApplicationContext ac = null; @Resource private IUserService userService = null; // @Before // public void before() &#123; // ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // userService = (IUserService) ac.getBean(&quot;userService&quot;); // &#125; @Test public void test1() &#123; User user = userService.getUserById(1); // System.out.println(user.getUserName()); // logger.info(&quot;值：&quot;+user.getUserName()); logger.info(JSON.toJSONString(user)); &#125; &#125; [ 复制代码 测试结果 3.4.5、建立UserController类UserController.java 控制器 [ 复制代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.javen.controller;import java.io.File;import java.io.IOException;import java.util.Map;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.apache.commons.io.FileUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.javen.model.User;import com.javen.service.IUserService; @Controller @RequestMapping(&quot;/user&quot;) // /user/**public class UserController &#123; private static Logger log=LoggerFactory.getLogger(UserController.class); @Resource private IUserService userService; // /user/test?id=1 @RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter(&quot;id&quot;)); System.out.println(&quot;userId:&quot;+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword(&quot;123&quot;); user.setUserName(&quot;javen&quot;); &#125; log.debug(user.toString()); model.addAttribute(&quot;user&quot;, user); return &quot;index&quot;; &#125; // /user/showUser?id=1 @RequestMapping(value=&quot;/showUser&quot;,method=RequestMethod.GET) public String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter(&quot;id&quot;)); System.out.println(&quot;userId:&quot;+userId); User user = this.userService.getUserById(userId); log.debug(user.toString()); model.addAttribute(&quot;user&quot;, user); return &quot;showUser&quot;; &#125; // /user/showUser2?id=1 @RequestMapping(value=&quot;/showUser2&quot;,method=RequestMethod.GET) public String toIndex2(@RequestParam(&quot;id&quot;) String id,Model model)&#123; int userId = Integer.parseInt(id); System.out.println(&quot;userId:&quot;+userId); User user = this.userService.getUserById(userId); log.debug(user.toString()); model.addAttribute(&quot;user&quot;, user); return &quot;showUser&quot;; &#125; // /user/showUser3/&#123;id&#125; @RequestMapping(value=&quot;/showUser3/&#123;id&#125;&quot;,method=RequestMethod.GET) public String toIndex3(@PathVariable(&quot;id&quot;)String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println(&quot;userId:&quot;+userId); User user = this.userService.getUserById(userId); log.debug(user.toString()); model.put(&quot;user&quot;, user); return &quot;showUser&quot;; &#125; // /user/&#123;id&#125; @RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.GET) public @ResponseBody User getUserInJson(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println(&quot;userId:&quot;+userId); User user = this.userService.getUserById(userId); log.info(user.toString()); return user; &#125; // /user/&#123;id&#125; @RequestMapping(value=&quot;/jsontype/&#123;id&#125;&quot;,method=RequestMethod.GET) public ResponseEntity&lt;User&gt; getUserInJson2(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println(&quot;userId:&quot;+userId); User user = this.userService.getUserById(userId); log.info(user.toString()); return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK); &#125; //文件上传、 @RequestMapping(value=&quot;/upload&quot;) public String showUploadPage()&#123; return &quot;user_admin/file&quot;; &#125; @RequestMapping(value=&quot;/doUpload&quot;,method=RequestMethod.POST) public String doUploadFile(@RequestParam(&quot;file&quot;)MultipartFile file) throws IOException&#123; if (!file.isEmpty()) &#123; log.info(&quot;Process file:&#123;&#125;&quot;,file.getOriginalFilename()); &#125; FileUtils.copyInputStreamToFile(file.getInputStream(), new File(&quot;E:\\\\&quot;,System.currentTimeMillis()+file.getOriginalFilename())); return &quot;succes&quot;; &#125;&#125; [ 复制代码 3.4.6、新建jsp页面file.jsp [ 复制代码 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;上传文件&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;/user/doUpload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; [ 复制代码 index.jsp 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; showUser.jsp [ 复制代码 1234567891011&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;user.userName&#125; &lt;/body&gt; &lt;/html&gt; [ 复制代码 至此，完成Spring+SpingMVC+mybatis这三大框架整合完成。 3.4.7、部署项目输入地址：http://localhost/user/jsontype/2 img 项目下载地址：https://github.com/Javen205/SSM ​ 参考博客：http://blog.csdn.net/gebitan505/article/details/44455235","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/MAVEN/Maven仓库管理之Nexus ","date":"2017-10-28T07:18:47.000Z","updated":"2017-10-28T07:18:47.000Z","comments":true,"path":"2017/10/28/Java/JavaEE/MAVEN/Maven仓库管理之Nexus /","link":"","permalink":"http://io.stelawliet.top/2017/10/28/Java/JavaEE/MAVEN/Maven仓库管理之Nexus /","excerpt":"","text":"Maven仓库管理之Nexus [TOC] ​ 我分两部分来介绍，首先介绍一下Maven的仓库，然后在说一下如何通过Nexus来建立我们自己的仓库，以及如何使用。 Maven 仓库​ 在以前使用Ant的时候，我们会建立一个lib目录在存放我们的jar包，比如项目所依赖的第三方包，每建立一个项目都要建立一个lib，不停的做copy工作，不仅是对于磁盘的浪费，而且也造成了版本管理上的麻烦。而且我们还需要通过提交到svn上来对lib进行管理，但是svn对于这种二进制文件的管理并不出色。 ​ Maven仓库的初衷就是为了解决这个问题。 maven仓库是所有常用的第三方依赖包的集中营。这样所有的Maven项目就可以从这个仓库中获取所需要的资源，Maven仓库中对jar通过Group Id, Atifact Id, version 来管理，所以Maven项目可以很方便的进行依赖管理。你不需要自己来管理这个庞大的资源仓库，当然你可以创建一个公司层面的仓库，这个我在这个章节的后面会介绍。 Maven 仓库的两个概念：本地仓库和远程仓库​ 本地仓库是远程仓库的一个缓冲和子集，当你构建Maven项目的时候，首先会从本地仓库查找资源，如果没有，那么Maven会从远程仓库下载到你本地仓库。这样在你下次使用的时候就不需要从远程下载了。如果你所需要的jar包版本在本地仓库没有，而且也不存在于远程仓库，Maven在构建的时候会报错，这种情况可能发生在有些jar包的新版本没有在Maven仓库中及时更新。 ​ Maven缺省的本地仓库地址为${user.home}/.m2/repository 。也就是说，一个用户会对应的拥有一个本地仓库。当然你可以通过修改${user.home}/.m2/settings.xml 配置这个地址： 12345&lt;settings&gt; ... &lt;localRepository&gt; D:/java/repository&lt;/localRepository&gt; ...&lt;/settings&gt; 如果你想让所有的用户使用统一的配置，那么你可以修改${M2_HOME}/conf/setting.xml 还可以通过在运行时指定目录（不推荐这么做）： 1mvn clean install -Dmaven.repo.local=/home/juven/myrepo/ ​ 当我们创建一个简单的Maven项目后(只需要在pom.xml配置好依赖项)，运行mvn clean install就可以把项目构建好，maven会自动从中央仓库下载所需的依赖项(即jar包）。这个中央仓库定义在${M2_HOME}/lib/maven-2.0.10-uber.jar 里面。你可以在里面找到/org/apache/maven/project/pom-4.0.0.xml这个文件，在这个文件里面定义了中央仓库的地址： 1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt; central&lt;/id&gt; &lt;name&gt; Maven Repository Switchboard&lt;/name&gt; &lt;layout&gt; default&lt;/layout&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt; false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 在 POM 中配置远程仓库 当某个依赖项存在于第三方的公共仓库时，我们需要配置其他远程仓库呢。下面是在pom.xml里面配置一个远程仓库的例子： 1234567891011121314151617181920212223242526272829303132&lt;repositories&gt; &lt;repository&gt; // 其他远程仓库 &lt;/repository&gt; &lt;repository&gt; &lt;id&gt; maven-net-cn&lt;/id&gt; &lt;name&gt; Maven China Mirror&lt;/name&gt; &lt;url&gt; http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt; true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt; false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; // 其他maven插件仓库 &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt; maven-net-cn&lt;/id&gt; &lt;name&gt; Maven China Mirror&lt;/name&gt; &lt;url&gt; http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt; true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt; false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; ​ 这里我们可以看到，允许配置多个repository和 plugin repository，其中true告诉Maven可以从这个仓库下载releases版本的构件，而false告诉Maven不要从这个仓库下载snapshot版本的构件。 Maven在使用第三方构件和插件时是分开来配置的,所以如果我们也希望插件的下载也通过我们的本地仓库来下载,那么我们就需要配置pluginRepository. 之所以不允许从某些仓库下载snapshot版本，是因为snapshot版本不稳定，但是某些snapshot版本，比如公司内部正在开发的项目, 是必须的 至于，这是配置Maven从什么地方下载插件构件，Maven的所有行为都是通过插件来完成的。 的配置与类似，这里就不多说了。 在 settings.xml 中配置远程仓库​ pom.xml的作用范围限于一个项目， 但一个公司/组织通常不只开发一个项目，那么为了避免重复配置，那么我们可以把一些公共配置放在${MAVEN_HOME}/conf/setting.xml(或${user.home}/.m2/setting.xml中。下面是在setting.xml中配置一个远程仓库的例子. 1234567891011121314151617&lt;settings&gt; &lt;profiles&gt; &lt;profile&gt; &lt;!-- 其他profile --&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;myProfiel&lt;/id&gt; &lt;!-- 在这里加入&lt;repositories&gt;及&lt;pluginRepositories&gt; --&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 声明哪些profile被激活，或根据某些条件激活 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;myProfiel&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/settings&gt; ​ 这里通过元素来激活这个profile，这样我们就可以全局的使用这个配置，不再需要为每个POM做重复的配置了（也可以针对特定的条件激活，比如某些profile只有在使用JDK 1.4时才生效)。 ​ 在实际的操作过程中，setting.xml最好不要配置远程仓库，最好能够通过nexus建立公司或者组织自己的仓库，然后把地址指向自己的仓库，后面我会介绍为什么要这么做以及怎么做。 配置maven仓库镜像​ 当你连接中央仓库时速度很慢，或有些国外的第三方仓库无法被访问时，你可以在setting.xml中为这些仓库指定一个镜像来加快下载依赖项的速度。下面是一个配置镜像的例子 123456789101112131415&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;!-- 其他镜像库 --&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt; maven-net-cn&lt;/id&gt; &lt;name&gt; Maven China Mirror&lt;/name&gt; &lt;url&gt; http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ...&lt;/settings&gt; 这里的 必须指定某个的Id. 如果想为所有的仓库做镜像， 那么可以改为：* 利用 Nexus 来构建企业级 Maven 仓库Nexus简介​ Nexus是一个Maven仓库管理器，用来搭建私有仓库服务器。建立公司/组织的私有仓库的的好处是便于管理，节省公网带宽，利用内网下载依赖项速度快，还有一个非常有用的功能就是能有效管理内部项目的SNAPSHOT版本，实现各个模块间的共享. 安装 Nexus​ 可以从http://nexus.sonatype.org/downloads/ 获取最新版本的nexus，本文以1.3.4为例进行说明。 ​ Nexus提供了两种安装方式，内嵌Jetty的捆绑包（bundle）和WAR包。前者解压后即可单独运行，只要系统中安装了JRE， 后者需要一个Servlet容器来运行. 使用捆绑包安装​ 如果你使用Windows，那么下载nexus-webapp-1.3. 4**-bundle.zip，并将其解压至任意目录，如D:/**tools，然后转到D:**tools\\nexus-webapp-1.3.4\\bin\\jsw\\indows-x86-32 ，双击运行Nexus.bat。 如果你是在linux下安装，那么就下载nexus-webapp-1.3. 4 -bundle.tar.gz，解压后运行nexus.sh。nexus还支持solaris,macos等操作系统。​ 当你在控制台看到“Started SelectChannelConnector@0.0.0.0:8081”之后，说明Nexus启动成功了。 打开浏览器，访问http://127.0.0.1:8081/nexus，使用管理员的帐号(admin)和密码(admin123)登录， 会看到如下的页面： img 在这里可以进行管理仓库，配置Nexus系统，管理任务，管理用户，角色，权限，查看系统的RSS源，管理及查看系统日志等操作。 使用War包安装 ​ 下载WAR包，然后将其发布到servlet容器中即可 ​ 到此我们已经安装好Nexus,下面介绍一下Nexus常用的功能和使用方法。 配置**中央仓库** 在左边菜单栏里选择Repositories, 会看到如下的界面： 其中右边栏上半部分列出当前nexus管理的repository，黑体字是类型为group的repository. 这里简单介绍下几种repository的类型: hosted，本地仓库。通常我们会部署自己的构件到这一类型的仓库。比如公司/组织开发的项目 proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库或一些第三方公共仓库。 group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用依赖项时，无需引用多个仓库了，只需要引用一个类型为group的repository即可。 Maven central是Maven的中央仓库，点击它并选择configuration标签栏，我们会看到下面的页面： img 这里有几个配置项是经常用到的： Override local storage location: 该选项允许配置 Nexus本地仓库的存放地址，用来覆盖其默认的存放地址 Remote storage location: 该选项允许配置远程仓库的地址。一般为了提高代理速度，你可以将其修改为国内的镜像地址。默认值是http://repo1.maven.org/maven2/ Download remote indexes: 该选项配置是否下载远程索引文件。 建议配置为true，这样我们便可以通过nexus的搜索功能来搜索我们需要的依赖项。 添加代理仓库(proxy)​ nexus默认提供了Maven central这个代理仓库，如果你需要添加其他代理仓库，那么可以点击左边栏页面上的Repositories链接，然后在右边栏页面上依次点击add -&gt; add proxy repository, 随后出现以下页面： img ​ 根据提示填写相关信息保存即可。 管理本地仓库(hosted)​ Nexus预定义了三种本地仓库，分别是Releases, Snapshots, 3rd Party. 下面分别介绍一下这三种类型仓库的作用 Releases: 存放稳定版本的构件。比如我们完成了一个版本的下数组件的开发,就可以把它发布到这里。 Snapshots: 存放快照版本的构件。 比如一个下数组件在完成所有开发和测试工作之前，是不应该发布到release仓库的，但可能其他项目只需用到这个组件的某些接口，只要这些接口完成了开发并通过测试，就可以拿来使用, 从而实现多个项目并行开发。 3rd Party: 存放其他第三方构件。你可能会问， 不是有中央仓库和其他第三方公共仓库来管理这些依赖项了吗？没错。但由于某些开源项目出现的时间比maven要早，因此他们大都没有采用maven方式进行构建。 其他还包括包括一些非开源或使用maven 1.x构建的组件. 我们可以把这类组件通通添加到这里。创建本地仓库的方法很简单。点击Repository面板上方的Add按钮，然后选择Hosted Repository，然后在下方的配置面板中输入相关信息。 注意根据自己的需要选择本地仓库的类型 仓库组(group)​ 通过前面介绍我们了解到, 可以建立多个代理仓库和本地仓库. 但如果没有仓库组的概念，那么当需要引用这些仓库时, 就需要将他们逐个添加到pom.xml或setting.xml. 仓库组是为了简化仓库的引用而提出的。有了仓库组的概念, 我们可以把仓库根据不同目的进行分组，比如把常用的归到一组或根据访问权限分组， 然后直接声明引用某个仓库组即可. 下面是pom.xml中声明引用一个nexus仓库组的例子： 1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-public&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 可以看到声明引用一个仓库组和一个普通的远程仓库，配置的写法完全一样。 maven本身没有仓库组的概念 ​ Nexus中预设了2个仓库组， 分别是public repositories和public snapshot repositories. 如图: img public repository默认包含本地仓库的Releases, snapshots和3rd party以及代理仓库的Maven Central. 你可以在Configuration配置页添加其他仓库到这个仓库组。 如果需要，你还可以创建一个仓库组,方法是点击 Add-&gt;Repository Group, 当New Repository Group界面后,填入ID, name 等相关信息, 然后在右边Available Repositories 栏里可以选择你要添加的仓库到你新建的仓库组. img 通过 Nexus 搜索构件​ 在开发过程中过程中，我们往往只记得某个构件的大致名字，这时我们可以通过nexus提供的构件搜索功能查询该构件的完整配置信息(groupId,artifactId,version)．如果通过nexus搜不到某个的构件，那说明这个构件不在当前nexus所登记的仓库中，可能需要添加额外的代理仓库或手工上传某个构件。 ​ 在使用nexus的搜索功能之前，必须先让nexus所登记的仓库建立索引文件, Nexus默认是不为每个仓库建立索引文件的,因为建立像中央仓库这样的索引文件需要耗费比较大的网络带宽和事件,仅索引文件就要几十兆. 要开启中央仓库的索引文件下载功能需要在Maven Central的配置页中， 把Download Remote Indexes改为true. 如图: img ​ 这样设置之后, Nexus会自动从远程中央仓库下载索引文件, 为了检验索引文件自动下载是否生效,可以切换到Browse标签页，如图： img 如果出现类似于以上文件夹,那说明索引文件已经建立成功. ​ 下面我们试一下搜索功能, 搜索栏输入testing, 查询结果如下： img 这是模糊查询的结果，当然如果你知道更多信息，比如版本号等，你可以使用高级搜索，点击高级搜索后，右边界面会提供集中搜索方式：keyword, classname, GAV, checksum img 比如我们这里选择GAV模式. 假设我只知道artifact的名字（如testng）和版本号（如5.8）, 其他的我不知道, 那么就在artifact 和 version处分别输入testng 和 5.8 , 搜索结果如下: img 如果你不知道知道构件的名称, 只知道classname, 那么你也可以通过class name 的方式搜索,这里就不再赘述。 当你选中某项搜索结果， 页面的下方会出现这个构件的详细信息, 并且会列出这个构件的Maven依赖配置, 你可以直接拷贝到你的pom文件中使用,这是个非常实用的功能: img 在 Maven 中使用**Nexus**​ 到此我们介绍了如何安装和使用Nexus以及其基本配置, 那么如何在Maven来使用Nexus本地仓库呢？其实和配置远程仓库的方法一样。下面是在settings.xml中添加了一个nexus本地仓库的例子： 1234567891011121314151617181920212223242526272829303132333435&lt;profiles&gt; ... &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; ...&lt;/profiles&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 你也可以在pom.xml中声明引用某个nexus仓库。 构件部署 有些时候我们需要部署构件到Nexus的3rd party, 比如我们在中央仓库找不到我们需要的构件, 我们可以通过Nexus的UI界面来上传构件: 点击左边菜单栏的 Repositories, 然后点击右边界面的3rd party, 选择界面下方的Artifact Upload, 这个时候出现以下界面: img 上传构件需要两个步骤,一个是定义文件的上传,再就是构件的实体文件.第一部分定义文件可以是POM文件, 这也是比较推荐的方式, 如果没有pom文件,可以选择以参数的形式输入。第二部分是上传构件的实体文件。这里简单说一下Classifier和Extension, 这两个都是选填项. Classifier用来区别同功能的构件用于不同的场景, 比如这个构件是分别针对JDK14和JDK15做了2个功能一样的Jar, 这个时候你就需要指定这个构件的Classifier为JDK14还是JDK15. Extension是指扩展名,如果不提供,那么会自动取这个构件的Packaging Type作为扩展名, 比如ear, jar, war 等等. (Packaging Type是在第一步中通过pom文件或者手工输入得到的) ​ 刚才说了3rd party的部署, 对于releases 和 snapshots的部署也是一样的操作过程. ​ 一般我们会通过UI 界面来部署一些缺失的构件。对于自己开发的构件还有另一种简单的部署方式， 即通过命令mvn deploy进行部署。但使用这种部署方式需要在pom.xml中添加一些配置，比如： 12345678910111213141516&lt;project&gt; … &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; … &lt;/project&gt; 这里告诉Maven当我要发布release版本或者snapshot版本时，把构建好的成品上传到哪个服务器地址。 最后还要在setting.xml里面配置一个有部署权限的Nexus的帐号和密码 12345678910111213141516&lt;settings&gt; … &lt;servers&gt; &lt;server&gt; &lt;id&gt; nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt; nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; … &lt;/settings&gt; 至此 我们就可以通过命令mvn deploy来发布我们项目到本地仓库了. 这里我们使用了admin来进行部署，一般建议使用一个具有部署权限的账号执行部署操作。 补充1、 发现配置了nexus仓库组之后，下载构件抛异常0-10-3 下午05时09分43秒: Build error for /com.newyulong.iptv.domain.entity/pom.xml; org.apache.maven.plugin.PluginResolutionException: Plugin org.apache.maven.plugins:maven-resources-plugin:2.4.1 or one of its dependencies could not be resolved: Missing:-———1) org.apache.maven.plugins:maven-resources-plugin:maven-plugin:2.4.1 Try downloading the file manually from the project website. Then, install it using the command:​ mvn install:install-file -DgroupId=org.apache.maven.plugins -DartifactId=maven-resources-plugin -Dversion=2.4.1 -Dpackaging=maven-plugin -Dfile=/path/to/file Alternatively, if you host your own repository you can deploy the file there:​ mvn deploy:deploy-file -DgroupId=org.apache.maven.plugins -DartifactId=maven-resources-plugin -Dversion=2.4.1 -Dpackaging=maven-plugin -Dfile=/path/to/file -Durl=[url] -DrepositoryId=[id] -———1 required artifact is missing. for artifact: org.apache.maven.plugins:maven-resources-plugin:maven-plugin:2.4.1 from the specified remote repositories: Nexus (http://localhost:8181/nexus/content/groups/public , releases=true, snapshots=false) 这里的主要原因是配置nexus里面的Public Repositories 顺序和条件出错，导致不能下载构件。比如这个public repositories： img 这个是正确的配置顺序。其中左边的是正在使用的定义好的仓库，右边的是候选的仓库。在这个例子中，nexus下载构件的顺序是Releases –&gt;Snapshots –&gt; 3rd party –&gt; Maven Central。 ​ 好多公司处于安全考虑，要求使用用代理访问公网，而nexus经常需要往maven repository中心下载东西，因此需要给nexus的仓库设置代理。 原文地址：&lt;http:// http://blog.csdn.net/cuker919/article/details/5922007&gt;","categories":[],"tags":[]},{"title":"","slug":"Java/JavaEE/MAVEN/MAVEN环境配置","date":"2017-10-27T11:51:59.000Z","updated":"2017-10-27T11:51:59.000Z","comments":true,"path":"2017/10/27/Java/JavaEE/MAVEN/MAVEN环境配置/","link":"","permalink":"http://io.stelawliet.top/2017/10/27/Java/JavaEE/MAVEN/MAVEN环境配置/","excerpt":"","text":"配置maven环境变量（首先要确保java环境变量已经配置好）： 1⃣️ 先双击Binary tar.gz archive文件，解压到文件目录下； 2⃣️ 查看文件路径：1）首先，打开终端； 2）再将apache-maven-3.5.0 文件夹拖入到终端内，文件夹路径就会显示出来； 3⃣️ 在终端打开配置环境变量到文件： 1）在终端输入 vim ~/.bash_profile，进入到环境变量配置文件里面； 2）进入后，是read模式，按下 i (编辑)键，进入insert模式； 3）将环境变量加入其实，环境变量如下： export MAVEN_HOME=/Users/robbie/apache-maven-3.3.3 export PATH=$PATH:$MAVEN_HOME/bin 4）按下 ESC，退出insert模式； 5）输入 :wq (保存修改)退出当前文件； 6）使修改的环境变量bash_profile文件生效，输入 source .bash_profile，按下Enter键即可.","categories":[],"tags":[]},{"title":"Linux——Vim编辑器命令基础","slug":"Linux/command/Vi命令","date":"2017-10-27T09:34:44.000Z","updated":"2018-07-04T11:47:42.000Z","comments":true,"path":"2017/10/27/Linux/command/Vi命令/","link":"","permalink":"http://io.stelawliet.top/2017/10/27/Linux/command/Vi命令/","excerpt":"","text":"Linux——Vim编辑器命令基础参考 Vi是一个命令行界面下的文本编辑工具，Vim是Vi的一个增强版。 vim或vi命令可以启动vim编辑器vim + 目标文件路径 使用vim打开文件如果目标文件存在，则vim打开该文件如果目标文件不存在，则vim会新建该文件，并打开 vi的三种模式：1、命令模式（常规模式）任何模式下按ESC键都会返回命令模式。命令模式下可以通过键入不同的命令完成选择、复制、粘贴、撤销等操作。2、插入模式在命令模式中按“i”键即可进入插入模式，插入模式下可以输入编辑文本内容；按ESC键可返回命令模式。3、ex模式在命令模式下按“：”键可进入ex模式，ex模式下可以保存、修改、退出vim。 命令模式：i 在光标前插入文本o 在当前行的下面插入新行dd 删除整行yy 将当前行的内容放入缓冲区（复制当前行）p 将缓冲区中的内容放入光标后（粘贴）数字yy 复制N行r 替换当前字符（先按r，再按要替换的新字符）u 撤销上一个操作/关键字 查找关键字（按N键可以在找到的这些关键字之间来回切换） ex模式：w 保存当前修改q 退出q！ 强制退出，不保存任何修改wq 先保存后退出x 保存并退出set nu / set number 显示行号！ 系统命令 执行一条系统命令并显示结果sh 切换到命令行，之后再按Ctrl + D 即可返回vim","categories":[{"name":"Linux","slug":"Linux","permalink":"http://io.stelawliet.top/categories/Linux/"},{"name":"Vim","slug":"Linux/Vim","permalink":"http://io.stelawliet.top/categories/Linux/Vim/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://io.stelawliet.top/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://io.stelawliet.top/tags/vim/"}]},{"title":"","slug":"Java/JavaEE/MAVEN/ntelliJ IDEA 配置Maven","date":"2017-10-27T08:17:41.000Z","updated":"2017-10-27T08:17:41.000Z","comments":true,"path":"2017/10/27/Java/JavaEE/MAVEN/ntelliJ IDEA 配置Maven/","link":"","permalink":"http://io.stelawliet.top/2017/10/27/Java/JavaEE/MAVEN/ntelliJ IDEA 配置Maven/","excerpt":"","text":"使用IntelliJ IDEA 配置Maven（入门）原创 2016年05月20日 13:56:27 [TOC] 1. 下载Maven官方地址：http://maven.apache.org/download.cgi 下载 解压并新建一个本地仓库文件夹 解压新建本地仓库 2.配置本地仓库路径 打开此文件 这里写图片描述 3.配置maven环境变量 点击更改设置 点击环境变量 新建M2_HOME 配置Path 查询是否配置成功 4.在IntelliJ IDEA中配置maven打开-File-Settings 配置maven 5.新建maven WEB项目打开-File-New-Project点击NEXT 创建maven项目 点击NEXT 这里写图片描述 添加的配置为 archetypeCatalog=internal点击NEXT 这里写图片描述 点击NEXT 这里写图片描述 点击Finish后项目开始创建点击右下角查看进去 这里写图片描述 6.maven web模板项目结构 这里写图片描述 这里写图片描述 这里写图片描述 同样在main下新建test测试文件夹,再在此文件夹下新建java测试源码文件夹和resource测试资源文件夹 这里写图片描述 也可以右键项目-选择Open Module Settings打开项目配置页面更改 这里写图片描述 7.配置依赖jar包 这里写图片描述 jar包配置搜索官方地址：http://mvnrepository.com/","categories":[],"tags":[]},{"title":"","slug":"MD/idea/Intellij_IDEA使用","date":"2017-10-26T14:00:22.000Z","updated":"2017-11-03T08:20:21.000Z","comments":true,"path":"2017/10/26/MD/idea/Intellij_IDEA使用/","link":"","permalink":"http://io.stelawliet.top/2017/10/26/MD/idea/Intellij_IDEA使用/","excerpt":"","text":"Intellij IDEA 的使用 前言： 为什么我要选择intellij idea呢？原因有三 1.以前公司的项目 在myeclipse10中不稳定 myeclipse说不定什么时候就崩溃卡死了 而intellij很稳定 2.界面高端洋气 用我朋友的话说 看着跟搞苹果开发一样 3.项目的支持上比较好 基本上web项目都可以导入进来 比如mybatis的官方项目 是maven的 在myeclipse中就不能直接导入 intellij支持了 目前基本上所有的项目 尤其是maven项目 推荐一下黄勇的这篇《使用 IDEA + Maven + Git 快速开发 Java Web 应用》http://my.oschina.net/huangyong/blog/175363 下面步入正题： 1.黑色主题 中文乱码修改修改黑色主题 Settings-&gt;Appearences -&gt;Themes-&gt;Darcula 系统提示重启加载主题 重启后Settings-&gt;Appearences -&gt;勾选Override default fonts by 出现这种情况 不用害怕 只用随便选择一个乱码的 点击保存 中文汉字就出来了 2.WEB项目的部署 以及自动编译Intellij中 web的程序 部署 不同于myeclipse和eclipse 需要把项目打成一个Artifacts(成品包)的war包 然后在 配置的tomcat的Deployment中选择对应的war包 具体的可以看下这个帖子 http://my.oschina.net/tsl0922/blog/94621 我要强调的是 非maven的项目 比如网上下载的eclipse或者myeclipse项目 首选要检查项目设置 F4 或者 Ctrl+ALT+SHIFT+S 或者 快捷栏中 点项目设置 img 以JFinal项目为例子 导入项目后 打开项目设置 img 1.首先修改Modules 选择 SDK 也就是你系统上的JDK 然后把项目中的不支持红色的选项去掉 img 2.添加项目的类型 支持 比如你这个项目 是Spring的项目 可以加上Spring 以及在对应Spring的配置中 手中选中spring的配置文件 加上Web项目的支持 制定web.xml的路径 以为web的目录 如果是maven项目 这些都不用管 但是非maven项目 因为目录结构不同 IDEA默认找的 项目下的web目录 所以项目往往不能正确部署 或者部署不正确 都是这个地方的原因 这个Modules 设置正确后 就可以创建Artifaces了 IDEA右下角也会提示你的Create Artifaces 3.添加项目的lib依赖 img 需要选择项目中的 web-inf中的lib 默认是不会自动加进来的 如果是maven项目 这个就不要管了 4.选择Artifaces的exploded war包 （如果是之前点击右下角系统的提示创建 就不用这样了） img 5修改项目的输出目录 img 修改项目的编译输出目录 最好改为 jfinal_demo_for_jsp\\target\\ROOT（或者项目名） 因为maven的编译目录就是target目录 所以我们最好也按照maven的规则 6.项目 在服务器中的部署 img 选中我们的artifaces的war包 右边可以自定义项目的访问 名 左下角是 我们的项目 在服务器第一次启动时 需要做的事情 1.编译java类 2.打包部署war 这两个项目编译运行过 就可以给两个去掉了 以后我们再启动项目 就不用在去编译打包部署了 7.项目的服务器配置 img 在服务器配置中 注意几个地方 1.start browser 项目启动后 自动打开浏览器 访问对应的连接 2.on update action ：当发现更新时的操作 选择update classes and resources on frame deactivation: 当IDEA 切换时的操作 （比如缩下去 打开网页） 选择update classes and resources 也就是 自动编译 自动部署的功能 很多人说Intellij IDEA 不能自动编译 就是这个这个地方没设置好 3.可以选择端口 一个是jvm的端口 一个是tomcat的端口 如果我们同时运行多个项目 可以选择修改端口 就能直接同时运行多个项目 4.项目运行后 这两个就不需要了 或者我们是maven项目 直接可以在maven中 packages 打包 编译 这两个也都不需要了 然后启动项目 就会弹出我们的项目首页了 总结一下 里面需要注意的几个地方 1.modules里面 添加项目类型 以及配置文件是否指定正确 2.lib文件的添加 3.artifacts 选择exploded 的war包 选择编译目录 4.服务起中 配置 热部署 端口 等 3.多项目的同时部署intellij中工作空间和项目的概念和 myeclipse稍微有点不同 这个大家可以查看相关资料 之前@黄勇 大哥发的java框架对比 就是一个项目中 有多个modules 因为黄勇的项目 都是maven项目 就没有过多需要修改配置的地方 当时modules和artifacts里面好像都没有修改 多个子项目 可以在tomcat的deployment 同时部署 只用给每个项目 在右侧修改一下项目名字就OK了 img 4.相关插件提高工作效率1.JRebel插件 实现热部署可以集成JRebel 实现热部署 安装Tasks插件 集成JIRA等任务管理 1.修改idea.properties 在intellij的安装目录 bin\\目录下 修改到你的非C盘目录目录下 默认使用的 # idea.config.path=${user.home}/.IntelliJIdea/ 这样的好处是 当你更换系统时 intellij的配置和插件都在 可以直接继续使用 2.安装JRebel插件 Settings - Plugins - Browse repositories… 搜索JRebel 然后右键 Download and Install 里面其实有很多插件 具体插件的功能 可以去官网进行查看 http://plugins.jetbrains.com/?idea 插件会下载 安装在 E:.IntelliJIdea\\config\\plugins 也就是刚才配置的 config\\plugins下 3.JRebel 破解 需要替换E:.IntelliJIdea\\config\\plugins\\jr-ide-idea\\lib\\jrebel 下的jrebel.jar 以及在intellij中 指定对应的lrc文件 img img 然后重启下intellij JRebel就可以使用了 热部署效果非常的好 修改东西都不用重启 而且项目在长期运行中也不会出现崩溃 （以前热部署遇到过session崩溃的问题） 如果是maven项目 修改配置文件也都不用重启 比如mybatis的xml文件等 除了web.xml修改好像需要 4 如果JRebel不起作用 可以使用下面的方法 img 在Modules下 添加JRebel的支持 勾选 并点击后面的Generate rebel.xml 在你项目的配置文件中找到生成的rebel.xml 你会发现 它里面有两个目录 一个是java类的编译目录 一个是webroot的目录 也就是JRebel的监控目录 它会监控那个两个目录 如果发生文件变化 就在内存中重新加载对应的资源 非maven项目的静态资源发生变化后 如果不能热部署 可能就是JRebel监控的目录不太对 可以自己指定一下正确的目录 2.Tasks插件 集成任务管理 img img # Intellij中可以安装task插件 与jira等任务跟踪管理系统进行集成安装插件后 会在系统任务栏上显示 任务插件 显示当前的任务 以及最近的任务每个任务 可以创建不同的视图在不同视图下 会自动记录 当前任务下 修改过的页面所以这个功能相当的棒 当我们有多个jira任务时 可以随时切换任务任务完成后 我们可以根据任务对应的changelist 去提交当前任务下 修改过的文件 破解文件的连接地址 http://note.youdao.com/share/?id=33c21fb3c24e81c2781872525e22ade2&amp;type=note 5.其它的一些技巧配置（未完待续）# # PS:2013-11-28 Facets的作用 img img img","categories":[],"tags":[]},{"title":"","slug":"MD/tomcat的数据源","date":"2017-10-26T13:58:38.000Z","updated":"2017-10-26T13:58:38.000Z","comments":true,"path":"2017/10/26/MD/tomcat的数据源/","link":"","permalink":"http://io.stelawliet.top/2017/10/26/MD/tomcat的数据源/","excerpt":"","text":"IDEA 配置 tomcat的数据源 img 1、F4打开module setting面板，找到facets 配置项，这个配置项非常重要，里面可配置tomcat加载的web.xml和context.xml文件所在的路径，部署的时候IDEA会自动读取。（PS：外部导入的项目，也一定要在这里配置好，不然自动部署时会出现错误。） 2、若没有facets-web项，则自己添加一个，然后点击add application server specific descriptor,选择tomcat context descriptor和默认配置文件路径，保存即可。 3、在web面板里打开META-INF/context.xml文件（这个文件在第2步配置后，会自动创建。），直接把数据源的配置参数填入即可。（IDEA给人的惊喜有很多，越用越坚定要用。） 4、在项目的web.xml文件上，配置引用关系。 5、最后在代码里调用； img","categories":[],"tags":[]},{"title":"","slug":"MD/idea/Intellij_idea_配置","date":"2017-10-26T09:39:29.000Z","updated":"2017-10-26T16:37:02.000Z","comments":true,"path":"2017/10/26/MD/idea/Intellij_idea_配置/","link":"","permalink":"http://io.stelawliet.top/2017/10/26/MD/idea/Intellij_idea_配置/","excerpt":"","text":"IntelliJ IDEA WEB项目的部署配置以下内容是我网上找的比较全面了，其中关于facets配置很多地方都没有说明，其实很重要，我加入了自己的理解。其他来自网络。在导入一个项目有问题时，建议先创建一个正确的web项目，然后对比配置项，一般就能找到导入项目的配置问题在哪里了。 [TOC] 1.前言​ 虽说Intellij IDEA已经用了四个多月，里面大部分功能还是比较熟悉的，但是很多细节地方还是搞不清楚，这几天公司另一个小组也换成了Intellij IDEA，帮他们迁移项目的时候，因为是非maven项目，遇到了很多问题，自己又研究了一番，下面整理一下 2.项目配置（Project Structure）2.1 Projectproject compliler output：配置的是项目中的默认编译输出总目录 里面英文也说明了，每个模块可以自己设置特殊的输出目录 所以这个基本上没用 2.2 Modules项目的模块，一个项目中可以有多个子项目，每个子项目相当于一个模块 一般我们项目只是单独的一个，所以只需要配置一个模块，我们可以给模块添加框架 [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180046588-2086383898.png) 根据我们项目中的使用到东西，添加对应的框架，并在框架里面确定一下相关的配置文件（因为不同IDE下，项目的文件结构可能不同 所以导入的项目我们要注意一下配置） 模块配置根目下 分为了三个标签：Sources—— Paths—— Depedencies [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180048682-1561762741.png) Sources标签下 主要显示项目的目录资源 那些是项目部署的时候需要的目录 有颜色提示 （比如绿色是测试目录 橘色是target的目录 这些部署的时候都不需要 大红色是我的项目下没有的 蓝色是真正需要部署） Paths标签下 [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180050604-223718264.png) 可以指定项目的编译输出目录 也就是项目类 和 测试类的编译输出地址（替换掉了Project的默认输出地址） Depedencies是项目的依赖 [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180052885-1152828564.png) 我们可以点击右侧的+号 添加lib 比如tomcat的lib 默认加进来就是Provided （和maven的里面的jar依赖差不多） Provided 也就是项目部署的时候是忽略的 只是再编译项目的时候进行使用 Compile 是跟随着项目部署的 Test也是不部署的 2.3 Libraries里面可以添加项目jar包 并且可以把多个jar放在一个组里面 类似于jar包整理 这个下添加的jar 会在Depedencies中显示（反之不可以） 2.4 Facts配置的是关于容器的配置文件，比如Tomcat要读取的web.xml和context.xml文件，就在这里指定和配置后，没有的会自动生产，尤其是外部导入的web项目一定要手动到这里配置下。 2.5 Artifacts项目的打包部署设置，这个是项目配置里面比较关键的地方 [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180055292-261680886.png) 注意红框的地方 第一个是我们需要添加项目的部署包 注意选择是exploded的war包 第二个是项目的输出目录 非maven项目这个可以设置到任何地方 （ maven项目的需要特殊注意 这个后面再说） 第三个是输出结构（output layout） 参考图中的几个文件 （maven项目如果不使用maven的打包编译 注意图中WEB-INF下的lib要有项目部署的jar） 3.非Maven项目的创建部署创建File——New Project——Java——Web Application （注意New Project里面不是选择的web 而是java） intellij中web项目 默认网页根目录是web 项目配置可参考2中的几个地方 根据自己的需求自己修改 artifact中out directory 可以指定到任何地方 项目打包编译到指定的目录下 在intellij中启动tomcat 都会以对应war包out directory的设置的目录为工作空间 tomcat配置请参考http://my.oschina.net/u/140593/blog/177042#OSC_h1_2 中的2-7 4.Maven项目的部署在intellij中 maven项目还是可以按照maven的打包编译 参考图中的几个生命周期 手动去执行 [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180058588-1093447979.png) 因为maven项目的约定 是项目打包编译到 target目录下 所以我们在2中配置都应该去遵循maven的配置约定进行修改 这样我们的项目在文件修改或者热部署的时候 intellij的编译才能和maven项目保持一致 （如果是在intellij中创建maven项目 那个intellij会给你配置好所有的配置 基本不用修改 我们可以创建一个springmvc的例子进行参考） 需要注意的地方是： maven项目 artifact中out directory 的目录名 一定要和pom文件中build的finalName一致 另外pom文件中 要配置\\war\\ 比如pom中配置的项目bulid finalName叫做ROOT 那么我们的out directory为 E:\\项目积累\\test1\\target\\ROOT 通过maven编译以及打包项目后 在服务器的配置中，可以去掉下图红色区域的两个选项，避免每次启动时都重新编译和打包 [ img](http://images2015.cnblogs.com/blog/762929/201606/762929-20160613180101495-1690615514.png) 5.总结本文基本总结了intellij中web项目部署的问题，以及如何去配置。来源： http://blog.csdn.net/z69183787/article/details/41416189","categories":[],"tags":[]},{"title":"firewall-cmd命令记","slug":"firewall","date":"2017-10-20T15:01:31.000Z","updated":"2018-06-25T03:55:54.000Z","comments":true,"path":"2017/10/20/firewall/","link":"","permalink":"http://io.stelawliet.top/2017/10/20/firewall/","excerpt":"","text":"打开tcp传输的8080端口，--permanent重启也有效1firewall-cmd --permanent --zone=public --add-port=8080/tcp 显示以配置的端口1firewall-cmd --list-port 重载配置1firewall-cmd --reload firewall-cmd –permanent –zone=public –add-rich-rule=”rule family=”ipv4” source address=”180.151.83.30/24” service name=”ssh” reject” 123firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;180.151.83.30/24&apos; port port=80 protocol=tcp reject&quot;firewall-cmd --reload 重新加载防火墙配置，不然firewall-cmd --list-all-zones不会显示刚加上的规则","categories":[{"name":"linux","slug":"linux","permalink":"http://io.stelawliet.top/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://io.stelawliet.top/tags/linux/"},{"name":"firewall-cmd","slug":"firewall-cmd","permalink":"http://io.stelawliet.top/tags/firewall-cmd/"},{"name":"vps","slug":"vps","permalink":"http://io.stelawliet.top/tags/vps/"}]},{"title":"JSP&JavaBean","slug":"Java/JavaEE/JSP&JavaBean","date":"2017-10-18T11:30:33.000Z","updated":"2018-07-04T11:42:09.000Z","comments":true,"path":"2017/10/18/Java/JavaEE/JSP&JavaBean/","link":"","permalink":"http://io.stelawliet.top/2017/10/18/Java/JavaEE/JSP&JavaBean/","excerpt":"","text":"[TOC] ##JSP三大指令 一个jsp页面中，可以有0~N个指令的定义！ page：\\&lt;%@page language=”java” info=”xxx”…%&gt; pageEncoding和contentType： pageEncoding：它指定当前jsp页面的编码，只要不说谎，就不会有乱码！在服务器要把jsp编译成.java时需要使用pageEncoding! contentType：它表示添加一个响应头：Content-Type！等同与response.setContentType(“text/html;charset=utf-8”); 如果两个属性只提供一个，那么另一个的默认值为设置那一个。 如果两个属性都没有设置，那么默认为iso import：导包！可以出现多次 errorPage和isErrorPage errorPage：当前页面如果抛出异常，那么要转发到哪一个页面，由errorPage来指定isErrorPage：它指定当前页面是否为处理错误的页面！当该属性为true时，这个页面会设置状态码为500！而且这个页面可以使用9大内置对象中的exception! 123456789101112131415161718192021&lt;error-page&gt;&lt;error-code&gt;404&lt;/error-code&gt;&lt;location&gt;/error/errorPage.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/errorPage.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.RuntimeException&lt;/exception-type&gt; &lt;location&gt;/index.jsp&lt;/location&gt; &lt;/error-page&gt; autoFlush和buffer autoFlush：指定jsp的输出流缓冲区满时，是否自动刷新！默认为true，如果为false，那么在缓冲区满时抛出异常！ buffer：指定缓冲区大小，默认为8kb，通常不需要修改！ isELIgnored：是否忽略el表达式，默认值为false，不忽略，即支持！ 基本没有： language：指定当前jsp编译后的语言类型，默认值为java。 info：信息！ isThreadSafe：当前的jsp是否支持并发访问！ session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象！ extends：让jsp生成的servlet去继承该属性指定的类！ include –&gt; 静态包含 与RequestDispatcher的include()方法的功能相似！ \\&lt;%@include%&gt; 它是在jsp编译成java文件时完成的！他们共同生成一个java(就是一个servlet)文件，然后再生成一个class！ RequestDispatcher的include()是一个方法，包含和被包含的是两个servlet，即两个.class！他们只是把响应的内容在运行时合并了！ 作用：把页面分解了，使用包含的方式组合在一起，这样一个页面中不变的部分，就是一个独立jsp，而我们只需要处理变化的页面。 taglib –&gt; 导入标签库 两个属性： prefix：指定标签库在本页面中的前缀！由我们自己来起名称！uri: 指定标签库的位置！\\&lt;%@taglib prefix=”s” uri=”/struts-tags”%&gt; 前缀的用法\\&lt;s:text&gt; JSP九个内置对象 out –&gt; jsp的输出流，用来向客户端响应 page –&gt; 当前jsp对象！ 它的引用类型是Object，即真身中有如下代码：Object page = this; config –&gt; 它对应真身中的ServletConfig对象！ pageContext 一个顶9个！ request –&gt; HttpServletEequest response –&gt; HttpServletResponse exception –&gt; Throwable session –&gt; HttpSession application –&gt; ServletContext pageContext 一个顶9个！ Servlet中有三大域，而JSP中有四大域，它就是最后一个域对象！ ServletContext：整个应用程序session：整个会话(一个会话中只有一个用户)request：一个请求链！pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据！域对象代理其他域：pageContext.setAttribute(“xxx”, “XXX”, PageContext.SESSION_SCOPE);全域查找：pageContext.findAttribute(“xxx”);从小到大，依赖查找！获取其他8个内置对象： JSP动作标签 这些jsp的动作标签，与html提供的标签有本质的区别。 动作标签是由tomcat(服务器)来解释执行！它与java代码一样，都是在服务器端执行的！ html由浏览器来执行！ &lt;jsp:forward&gt;：转发！它与RequestDispatcher的forward方法是一样的，一个是在Servlet中使用，一个是在jsp中使用！ &lt;jsp:include&gt;：包含：它与RequestDispatcher的include方法是一样的，一个是在Servlet中使用，一个是在jsp中使用！ &lt;%@include&gt;和&lt;jsp:include&gt;有什么不同！ &lt;jsp:param&gt;：它用来作为forward和include的子标签！用来给转发或包含的页面传递参数！ JavaBeanjavaBean的规范：1. 必须要有一个默认构造器 2. 提供get/set方法，如果只有get方法，那么这个属性是只读属性！ 3. 属性：有get/set方法的成员，还可以没有成员，只有get/set方法。属性名称由get/set方法来决定！而不是成员名称！ 4. 方法名称满足一定的规范，那么它就是属性！boolean类型的属性，它的读方法可以是is开头，也可以是get开头！ 内省： 内省类 –&gt; Bean信息 –&gt; 属性描述符 –&gt; 属性的get/set对应的Method！ — &gt; 可以反射了！ commons-beanutils，它是依赖内省完成！ 导包： commons-beanutils.jarcommons-logging.jar ​ 12345BeanUtils.getProperty(Object bean, String propertyName)BeanUtils.setProperty(Object bean, String propertyName, String propertyValue)BeanUtils.populate(Map map, Object bean)CommontUtils.toBean(Map map, Class class) jsp中与javaBean相关的标签 jsp:useBean –&gt; 创建或查询bean &lt;jsp:useBean id=&quot;user1&quot; class=&quot;cn.itcast.domain.User&quot; scope=&quot;session&quot;/&gt; 在session域中查找名为user1的bean，如果不存在，创建之 &lt;jsp:useBean id=&quot;user1&quot; class=&quot;cn.itcast.domain.User&quot; scope=&quot;session&quot;/&gt; jsp:setProperty &lt;jsp:setProperty property=&quot;username&quot; name=&quot;user1&quot; value=&quot;admin&quot;/&gt; 设置名为user1的这个javabean的username属性值为admin jsp:getProperty &lt;jsp:getProperty property=&quot;username&quot; name=&quot;user1&quot;/&gt; 获取名为user1的javabean的名为username属性值 EL表达式####EL是JSP内置的表达式语言 jsp2.0开始，不让再使用java脚本，而是使用el表达式和动态标签来替代java脚本！ EL替代的是&lt;%= … %&gt;，也就是说，EL只能做输出！ EL表达式来读取四大域 ${xxx}，全域查找名为xxx的属性，如果不存在，输出空字符串，而不是null。 ${pageScope.xxx}、${requestScope.xxx}、${sessionScope.xxx}、${applicationScope.xxx}，指定域获取属性！ javaBean导航1234567891011121314&lt;%Address address = new Address(); address.setCity(\"北京\"); address.setStreet(\"西三旗\"); Employee emp = new Employee(); emp.setName(\"李小四\"); emp.setSalary(123456); emp.setAddress(address); request.setAttribute(\"emp\", emp);%&gt; &lt;h3&gt;使用el获取request域的emp&lt;/h3&gt; $&#123;requestScope.emp.address.street &#125; &lt;!-- request.getAttribute(\"emp\").getAddress().getStreet() --&gt; EL可以输出的东西都在11个内置对象中！11个内置对象，其中10个是Map！pageContext不是map，它就是PageContext类型，1个项9个。 param：对应参数，它是一个Map，其中key参数名，value是参数值，适用于单值的参数。 paramValues：对应参数，它是一个Map，其中key参数名，value是多个参数值，适用于多值的参数。 header：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值请求头 headerValues：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值请求头 initParam：获取&lt;context-param&gt;内的参数！ 12345678&lt;context-param&gt; &lt;param-name&gt;xxx&lt;/param-name&gt; &lt;param-value&gt;XXX&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;yyy&lt;/param-name&gt; &lt;param-value&gt;YYY&lt;/param-value&gt;&lt;/context-param&gt; ${initParam.xxx} cookie：Map&lt;String,Cookie&gt;类型，其中key是cookie的name，value是cookie对象。 ${cookie.username.value} pageContext：它是PageContext类型！${pageContext.request.contextPath} EL函数库（由JSTL提供的）导入标签库：&lt;%@ tablib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt;String toUpperCase(String input)：把参数转换成大写String toLowerCase(String input)：把参数转换成小写int indexOf(String input, String substring)：从大串，输出小串的位置！boolean contains(String input, String substring)：查看大串中是否包含小串boolean containsIgnoreCase(String input, String substring)：忽略大小写的，是否包含boolean startsWith(String input, String substring)：是否以小串为前缀boolean endsWith(String input, String substring)：是否以小串为后缀String substring(String input, int beginIndex, int endIndex)：截取子串String substringAfter(String input, String substring)：获取大串中，小串所在位置后面的字符串substringBefore(String input, String substring)：获取大串中，小串所在位置前面的字符串String escapeXml(String input)：把input中“&lt;”、”&gt;”、”&amp;”、”‘“、”””，进行转义String trim(String input)：去除前后空格String replace(String input, String substringBefore, String substringAfter)：替换String[] split(String input, String delimiters)：分割字符串，得到字符串数组int length(Object obj)：可以获取字符串、数组、各种集合的长度！String join(String array[], String separator)：联合字符串数组！ 自定义函数库 写一个java类，类中可以定义0~N个方法，但必须是static，而且有返回值的！ 在WEB-INF目录下创建一个tld文件 1234&lt;function&gt; &lt;name&gt;fun&lt;/name&gt; &lt;function-class&gt;cn.itcast.fn.MyFunction&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String fun()&lt;/function-signature&gt;&lt;/function&gt; 在jsp页面中导入标签库&lt;%@ taglib prefix=&quot;it&quot; uri=&quot;/WEB-INF/tlds/itcast.tld&quot; %&gt; 在jsp页面中使用自定义的函数：${it:fun() }","categories":[{"name":"java","slug":"java","permalink":"http://io.stelawliet.top/categories/java/"},{"name":"javaee","slug":"java/javaee","permalink":"http://io.stelawliet.top/categories/java/javaee/"},{"name":"jsp","slug":"java/javaee/jsp","permalink":"http://io.stelawliet.top/categories/java/javaee/jsp/"}],"tags":[{"name":"javaee","slug":"javaee","permalink":"http://io.stelawliet.top/tags/javaee/"},{"name":"jsp","slug":"jsp","permalink":"http://io.stelawliet.top/tags/jsp/"}]},{"title":"","slug":"MD/未命名","date":"2017-10-10T14:41:32.000Z","updated":"2017-12-25T16:32:49.000Z","comments":true,"path":"2017/10/10/MD/未命名/","link":"","permalink":"http://io.stelawliet.top/2017/10/10/MD/未命名/","excerpt":"","text":"#JAVA this is the first markdown. ##Servlet ###request 吹响上低音号 2233","categories":[],"tags":[]},{"title":"","slug":"JavaScript/jQuery.Cookie","date":"2014-04-27T05:07:14.000Z","updated":"2014-04-27T05:07:14.000Z","comments":true,"path":"2014/04/27/JavaScript/jQuery.Cookie/","link":"","permalink":"http://io.stelawliet.top/2014/04/27/JavaScript/jQuery.Cookie/","excerpt":"","text":"jquery.cookie [ Build Status](https://travis-ci.org/carhartl/jquery-cookie.png?branch=master)](https://travis-ci.org/carhartl/jquery-cookie) [![Code Climate](https://codeclimate.com/github/carhartl/jquery-cookie.png) A simple, lightweight jQuery plugin for reading, writing and deleting cookies. If you’re viewing this at https://github.com/carhartl/jquery-cookie, you’re reading the documentation for the master branch.View documentation for the latest release (1.4.1). Build Status Matrix[ Selenium Test Status](https://saucelabs.com/browser-matrix/jquery-cookie.svg) InstallationInclude script after the jQuery library (unless you are packaging scripts somehow else): 1&lt;script src=\"/path/to/jquery.cookie.js\"&gt;&lt;/script&gt; Do not include the script directly from GitHub (http://raw.github.com/...). The file is being served as text/plain and as such being blockedin Internet Explorer on Windows 7 for instance (because of the wrong MIME type). Bottom line: GitHub is not a CDN. The plugin can also be loaded as AMD or CommonJS module. UsageCreate session cookie: 1$.cookie('the_cookie', 'the_value'); Create expiring cookie, 7 days from then: 1$.cookie('the_cookie', 'the_value', &#123; expires: 7 &#125;); Create expiring cookie, valid across entire site: 1$.cookie('the_cookie', 'the_value', &#123; expires: 7, path: '/' &#125;); Read cookie: 12$.cookie('the_cookie'); // =&gt; \"the_value\"$.cookie('not_existing'); // =&gt; undefined Read all available cookies: 1$.cookie(); // =&gt; &#123; \"the_cookie\": \"the_value\", \"...remaining\": \"cookies\" &#125; Delete cookie: 12345// Returns true when cookie was found, false when no cookie was found...$.removeCookie('the_cookie');// Same path as when the cookie was written...$.removeCookie('the_cookie', &#123; path: '/' &#125;); Note: when deleting a cookie, you must pass the exact same path, domain and secure options that were used to set the cookie, unless you’re relying on the default options that is. ConfigurationrawBy default the cookie value is encoded/decoded when writing/reading, using encodeURIComponent/decodeURIComponent. Bypass this by setting raw to true: 1$.cookie.raw = true; jsonTurn on automatic storage of JSON objects passed as the cookie value. Assumes JSON.stringify and JSON.parse: 1$.cookie.json = true; Cookie OptionsCookie attributes can be set globally by setting properties of the $.cookie.defaults object or individually for each call to $.cookie() by passing a plain object to the options argument. Per-call options override the default options. expiresexpires: 365 Define lifetime of the cookie. Value can be a Number which will be interpreted as days from time of creation or a Date object. If omitted, the cookie becomes a session cookie. pathpath: &apos;/&apos; Define the path where the cookie is valid. By default the path of the cookie is the path of the page where the cookie was created (standard browser behavior). If you want to make it available for instance across the entire domain use path: &#39;/&#39;. Default: path of page where the cookie was created. Note regarding Internet Explorer: Due to an obscure bug in the underlying WinINET InternetGetCookie implementation, IE’s document.cookie will not return a cookie if it was set with a path attribute containing a filename. (From Internet Explorer Cookie Internals (FAQ)) This means one cannot set a path using path: window.location.pathname in case such pathname contains a filename like so: /check.html (or at least, such cookie cannot be read correctly). domaindomain: &apos;example.com&apos; Define the domain where the cookie is valid. Default: domain of page where the cookie was created. securesecure: true If true, the cookie transmission requires a secure protocol (https). Default: false. ConvertersProvide a conversion function as optional last argument for reading, in order to change the cookie’s valueto a different representation on the fly. Example for parsing a value into a number: 12$.cookie('foo', '42');$.cookie('foo', Number); // =&gt; 42 Dealing with cookies that have been encoded using escape (3rd party cookies): 12$.cookie.raw = true;$.cookie('foo', unescape); You can pass an arbitrary conversion function. ContributingCheck out the Contributing Guidelines AuthorsKlaus Hartl","categories":[],"tags":[]}]}